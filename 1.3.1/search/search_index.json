{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to StepUp Core","text":"<p>StepUp is a simple, powerful and universal build tool, a modern alternative to Make.</p> <p>StepUp, like most build tools, schedules and executes commands in parallel. The scheduling takes into account that input files for a command must be available before starting it. Build tools also keep track of which other commands can create these files.</p> <p>This is the documentation for StepUp Core, the basic framework for StepUp, without any domain-specific functionality. Domain-specific features are implemented in extension packages. Currently, there is only the StepUp RepRep extension for creating reproducible reports: papers, presentations, theses, etc.</p>"},{"location":"#what-does-stepup-look-like","title":"What Does StepUp Look Like?","text":"<p>The following screen recording provides a quick visual impression of StepUp\u2019s terminal user interface.</p>"},{"location":"#why-was-stepup-core-created","title":"Why Was StepUp Core Created?","text":"<p>StepUp is a greenfield project inspired by similar tools, such as Ninja, pydoit and tup.</p> <p>The defining feature of StepUp is that it treats the generation and execution of the build graph as one and the same thing. This may sound abstract, so let\u2019s clarify this by reviewing how build tools work and have evolved over time.</p> <p>Traditional build tools run programs in parallel, which you must define in advance by writing all steps and their dependencies in a text file, such as a <code>Makefile</code>. In practice, humans rarely write such files. Instead, they are often generated by other tools, such as CMake or Automake, which handle the configuration and discovery of build steps. This separation into generation and execution simplifies the build tool, but it also prevents steps from being defined using information from the output of previous steps.</p> <p>More modern build tools, such as Bazel, Meson and Buck2 have also abandoned the traditional separation between build generator and executor. They introduce a domain-specific language (DSL), such as Starlark, to specify the build steps. These DSLs are designed to be powerful for build tasks, but are limited in what they can do for security reasons.</p> <p>For software compilation, established build tools usually make acceptable assumptions, and workarounds exist for certain exceptions, see for example <code>depfile</code>, <code>deps</code>, <code>dyndep</code> and <code>generator rule</code> in Ninja. In build scenarios other than software compilation, e.g., building a scientific publication from LaTeX sources and raw data, these workarounds are too limited. For example, if a LaTeX source contains <code>\\input</code> commands with TeX files generated by a Python script, it cannot be decided in advance whether these generated files reference additional input files, e.g., figures. In such cases, it is natural to determine all inputs of a LaTeX document on the fly instead of doing so in advance. (StepUp RepRep\u2019s predecessor, RepRepBuild, generated build instructions for Ninja and addressed this problem with an elaborate generator rule.)</p> <p>StepUp overcomes such difficulties by taking a different approach. The <code>stepup</code> command starts a background process that can receive build steps from any step in the build process, via Remote Procedure Calls (RPCs). It uses this information to extend its workflow, which is internally represented by a partial directed acyclic graph. This process is bootstrapped by an initial <code>plan.py</code> script containing the first RPC calls. Each build step can use intermediate results to add new information to the workflow. Steps can even be added rather late in the build, if this is necessary to correctly define such steps.</p> <p>The program tup deserves a special mention in this brief review. StepUp\u2019s algorithm for rebuilding steps (in response to changed inputs) strongly resembles that of tup. The build algorithm in both programs traverse upwards through the build graph. The \u201cUp\u201d part of StepUp\u2019s name acknowledges this inspiration, with \u201cStep\u201d reflecting how StepUp defines operations as individual steps.</p>"},{"location":"#other-noteworthy-features","title":"Other noteworthy features","text":"<ul> <li> <p>StepUp build scripts are written in Python, in so-called <code>plan.py</code> files.</p> </li> <li> <p>StepUp supports partial directed acyclic graph (PDAG) execution, similar to tup.   StepUp is radical in the sense that it always assumes partial knowledge of the DAG.   For example, at startup it will already run steps before it has complete knowledge of the workflow.</p> </li> <li> <p>StepUp always runs background processes (a director and several workers) to execute steps,   and a terminal frontend to control or interrupt the build.   The director starts with a run phase to execute steps in parallel until the build is complete.   When StepUp completes the build, it switches to a watch phase to register file changes.   When the user requests a rerun, it knows exactly which part of the DAG needs to be rebuilt.   This allows efficient edit-build iterations to incrementally build and refine a project.</p> </li> <li> <p>A file must either be declared static (written by the user) or built (created by a step)   before it can be used as input for steps.   StepUp will never use a file without knowing if it is static or built.   Static file declarations are uncommon in other build tools and   allow StepUp to correctly execute steps with partial knowledge of the workflow.</p> </li> <li> <p>Old outputs are automatically removed   when the steps creating those files are removed from the workflow.   This cleanup is only performed after a completely successful build.</p> </li> <li> <p>Rich pattern-matching rules make it easy to multiplex a step over multiple similar inputs.</p> </li> <li> <p>Steps do not need to have output files.   They will be rerun if inputs have changed since the last run.</p> </li> <li> <p>Environment variables can be defined as dependencies,   so that steps will rerun if they depend on variables that have changed.</p> </li> <li> <p>If a step\u2019s input files have changed, a file hash is used to determine whether the file   is different from a previous run before the step is re-run.   This prevents unnecessary step executions in two common scenarios:</p> <ul> <li>A file is changed and then reverted to its original state.</li> <li>Switching between branches in Git.</li> </ul> </li> <li> <p>The StepUp terminal user interface provides easy-to-follow progress information.</p> </li> <li> <p>A keyboard shortcut can be defined in most IDEs to start   a new run phase of an active StepUp director.   The command <code>python -c 'from stepup.core.interact import run; run()'</code> will instruct the director to run pending steps due to file changes.</p> </li> <li> <p>While a step is running, it can inform StepUp that it needs additional inputs,   in which case the step will be rescheduled for later execution   (after the additional inputs have become available).   Similarly, a step can define additional outputs during its execution.</p> </li> </ul>"},{"location":"#when-to-use-stepup","title":"When to use StepUp?","text":"<ul> <li>The software compilation assumptions of other build tools get in the way.</li> <li>You want to define the build graph in a language you already know: Python.</li> <li>Writing out all dependencies upfront is difficult or impossible.</li> <li>You enjoy living on the edge.</li> </ul>"},{"location":"changelog/","title":"Changelog","text":"<p>All notable changes to this project will be documented in this file.</p> <p>The format is based on Keep a Changelog, and this project adheres to Semantic Versioning.</p>"},{"location":"changelog/#unreleased","title":"Unreleased","text":""},{"location":"changelog/#v1.3.1","title":"1.3.1 - 2024-09-17","text":""},{"location":"changelog/#fixed","title":"Fixed","text":"<ul> <li>Fix incorrect parsing of <code>?*</code> and <code>*?</code> wildcards in the <code>nglob</code> module.</li> </ul>"},{"location":"changelog/#v1.3.0","title":"1.3.0 - 2024-08-27","text":""},{"location":"changelog/#added","title":"Added","text":"<ul> <li>Add support for standard output and error redirection in the script driver.   The dictionary returned by the <code>info</code> or <code>case_info</code> functions   can include <code>\"stdout\"</code> and/or <code>\"stderr\"</code> items.   The values of these two fields are paths to which the standard output and/or error   of the run part of the script are redirected.</li> <li>All API functions that define a step now return a <code>StepInfo</code> instance,   which may contain useful information (e.g. output paths) to define follow-up steps.   This is mainly useful for API extensions that define higher-level functions to create steps,   e.g. as in StepUp RepRep.</li> <li>The classes <code>NGlobMulti</code> has a new method <code>single()</code>   and <code>NGlobMatch</code> has a new property <code>single</code>.   These are only valid when there is a unique match,   i.e. when the <code>files</code> method or property has exactly one path.</li> </ul>"},{"location":"changelog/#changed","title":"Changed","text":"<ul> <li>Migrate <code>load_module_file</code> to stepup-reprep.</li> <li>Replace watchdog   by asyncinotify   to avoid a long-standing issue in watchdog.</li> <li>:warning: API-breaking :warning:   When a step is defined with a working directory different from <code>'./'</code>,   relative paths provided in other arguments to the <code>step()</code> function   are interpreted relative to the given working directory,   not the current working directory of the running process.</li> <li>The directory <code>.stepup</code> is no longer created when running <code>stepup</code>   without a <code>plan.py</code>.</li> <li>The files in <code>.stepup/logs</code> have been renamed to <code>*.log</code> files under <code>.stepup</code>.</li> </ul>"},{"location":"changelog/#fixed_1","title":"Fixed","text":"<ul> <li>Fix bug in the translation of relative paths before they are sent to the director process.</li> <li>Add trailing slash to <code>workdir</code> argument of <code>stepup.core.api.step()</code> if it is missing.</li> <li>Fix mistake in worker log filenames.</li> <li>Fix bug in back translation of paths when substituted in a step command.</li> <li>Improve compatibility of nglob with Python\u2019s built-in glob.</li> </ul>"},{"location":"changelog/#v1.2.8","title":"1.2.8 - 2024-06-28","text":""},{"location":"changelog/#fixed_2","title":"Fixed","text":"<ul> <li>Modify the script driver so that <code>info</code> and <code>case_info</code> may return empty dictionaries.</li> </ul>"},{"location":"changelog/#v1.2.7","title":"1.2.7 - 2024-06-24","text":""},{"location":"changelog/#fixed_3","title":"Fixed","text":"<ul> <li>Add workaround for Python==3.11 bug with RPC over sockets.   The RPC server (created with <code>asyncio.start_unix_server</code>) closes before all requests are handled.   A stop event is now included for all RPC handlers   to wait with stopping the server until every request is handled.   This is a known issue fixed in Python 3.12.1:   https://github.com/python/cpython/issues/120866</li> </ul>"},{"location":"changelog/#v1.2.6","title":"1.2.6 - 2024-06-13","text":""},{"location":"changelog/#fixed_4","title":"Fixed","text":"<ul> <li>Do not watch files when running StepUp non-interactively.   This makes non-interactive mode a workaround for a nasty watchdog bug,   which crops up when working on larger StepUp projects.   See https://github.com/gorakhargosh/watchdog/issues/275</li> </ul>"},{"location":"changelog/#v1.2.5","title":"1.2.5 - 2024-06-13","text":""},{"location":"changelog/#fixed_5","title":"Fixed","text":"<ul> <li>Effectively make watching recursive when a directory is added that is known in the workflow.</li> <li>The function <code>amend()</code> now always returns <code>True</code> when the RPC client is a dummy.   This fixes early exits from scripts that used <code>amend()</code> when they are called manually.</li> <li>Prevent the <code>Cannot watch non-existing directory</code> error by ensuring that deferred glob matches   exist before they are included as static files in the graph.</li> <li>Check that local scripts have a shebang line before trying to execute them.</li> <li>Improved continuous integration setup</li> <li>Minor documentation improvements</li> <li>Minor code cleanups</li> </ul>"},{"location":"changelog/#v1.2.4","title":"1.2.4 - 2024-05-27","text":""},{"location":"changelog/#changed_1","title":"Changed","text":"<ul> <li>Include \u201chidden\u201d files when globbing.</li> </ul>"},{"location":"changelog/#fixed_6","title":"Fixed","text":"<ul> <li>Do not refuse to replay unchanged step that declares its own static inputs.</li> <li>Make recursive glob consistent with Python\u2019s built-in glob in <code>step.core.nglob</code>.</li> <li>Pool definitions are stored in workflow and replayed correctly when a step is skipped.</li> </ul>"},{"location":"changelog/#v1.2.3","title":"1.2.3 - 2024-05-19","text":""},{"location":"changelog/#changed_2","title":"Changed","text":"<ul> <li>Completed and revised docstrings in <code>stepup.core.nglob</code>,   and added this module to the reference documentation.</li> </ul>"},{"location":"changelog/#fixed_7","title":"Fixed","text":"<ul> <li>Improve hash computation of a symbolic links in <code>stepup.core.hash</code>.</li> </ul>"},{"location":"changelog/#v1.2.2","title":"1.2.2 - 2024-05-16","text":""},{"location":"changelog/#changed_3","title":"Changed","text":"<ul> <li>Documentation updates.</li> </ul>"},{"location":"changelog/#fixed_8","title":"Fixed","text":"<ul> <li>Make <code>cleanup</code> command work in project subdirectories when <code>STEPUP_ROOT</code> is set.</li> <li>Avoid useless wait when running a <code>plan.py</code> script outside of <code>stepup</code>.</li> </ul>"},{"location":"changelog/#v1.2.1","title":"1.2.1 - 2024-05-07","text":""},{"location":"changelog/#fixed_9","title":"Fixed","text":"<ul> <li>Fixed packaging mistake that confused PyCharm and Pytest.</li> </ul>"},{"location":"changelog/#v1.2.0","title":"1.2.0 - 2024-05-02","text":""},{"location":"changelog/#added_1","title":"Added","text":"<ul> <li>Export of graphs to Graphviz DOT files.</li> <li>The <code>cleanup</code> script for manually cleaning up outputs.</li> </ul>"},{"location":"changelog/#changed_4","title":"Changed","text":"<ul> <li>Documentation updates.</li> <li>Limit acyclic constraint to the supplier-consumer graph.   This means a step can declare a static file and then amend it as input.</li> <li>Refactoring of the file <code>stepup.core.watcher</code> module:<ul> <li>Replace dependency <code>watchfiles</code> by <code>watchdog</code>.</li> <li>Rename functions in <code>stepup.core.interact</code>:<ul> <li><code>watch_add</code> -&gt; <code>watch_update</code></li> <li><code>watch_del</code> -&gt; <code>watch_delete</code></li> </ul> </li> <li>Separate watcher and runner coroutines with reduced risk for race conditions related to   <code>watch_delete</code> and <code>watch_update</code> to address <code>TimeoutError</code>.</li> <li>Place custom asyncio utilities in <code>stepup.core.asyncio</code>.</li> <li>The watcher also tracks changes to static files while steps are being executed.</li> <li>Directories are watched as soon as they are created.</li> </ul> </li> <li>The function <code>stepup.core.interact.graph</code> takes a prefix argument instead of a full filename,   e.g. <code>graph</code> instead of <code>graph.txt</code>.</li> </ul>"},{"location":"changelog/#fixed_10","title":"Fixed","text":"<ul> <li>More graceful error message when the director process crashes early.</li> <li>Fix compatibility with asciinema terminal recording.</li> <li>Raise <code>ConnectionResetError</code> in <code>SocketSyncRPCClient</code> instead of blocking forever when   the director process crashes.</li> </ul>"},{"location":"changelog/#v1.0.0","title":"1.0.0 - 2024-04-25","text":"<p>Initial release</p>"},{"location":"development/","title":"Developer Notes","text":"<p>If you would like to contribute, please read CONTRIBUTING.md.</p>"},{"location":"development/#development-install-and-unit-tests","title":"Development Install and Unit Tests","text":"<p>A local installation for testing and development can be installed using the following commands:</p> <pre><code>git clone git@github.com:reproducible-reporting/stepup-core.git\ncd stepup-core\npre-commit install\npython -m venv venv\n</code></pre> <p>Put the following lines in <code>.envrc</code>:</p> <pre><code>source venv/bin/activate\nexport XDG_CACHE_HOME=\"${VIRTUAL_ENV}/cache\"\n</code></pre> <p>Finally, run the following commands:</p> <pre><code>echo 'source venv/bin/activate' &gt; .envrc\ndirenv allow\npip install -U pip\npip install -e .[dev]\npytest -vv\n</code></pre>"},{"location":"development/#documentation","title":"Documentation","text":"<p>The documentation is created using MkDocs. mike is used to manage documentation of different versions</p> <p>Edit the documentation Markdown files with a live preview by running:</p> <pre><code>mkdocs serve\n</code></pre> <p>(Keep this running.) Then open the live preview in your browser at http://127.0.0.1:8000/ and edit Markdown files in your IDE.</p> <p>Please, use Semantic Line Breaks because it facilitates reviewing documentation changes.</p>"},{"location":"development/#tutorial-example-outputs","title":"Tutorial Example Outputs","text":"<p>If you wish to regenerate the output of the examples, run <code>stepup</code> in the <code>docs</code> directory:</p> <pre><code>cd docs\nstepup -n\n</code></pre> <p>Note that some scripts use Graphviz to generate diagrams, so you must have it installed on your system.</p>"},{"location":"development/#how-to-make-a-release","title":"How to Make a Release","text":"<ul> <li>Mark the release in <code>docs/changelog.md</code>.</li> <li>Make a new commit and tag it with <code>vX.Y.Z</code>.</li> <li>Trigger the PyPI GitHub Action: <code>git push origin main --tags</code>.</li> <li>Publish a documentation version with <code>mike deploy {version} -u stable -p</code></li> </ul>"},{"location":"installation/","title":"Installation","text":"<p>Requirements:</p> <ul> <li>POSIX operating system: Linux, macOS or WSL. StepUp cannot run natively on Windows.</li> <li>Python \u2265 3.11</li> <li>Pip</li> </ul> <p>It is assumed that you know how to use Pip. We recommend performing the installation in a Python virtual environment and activating such environments with direnv.</p> <p>The core package can be installed with:</p> <pre><code>pip install stepup\n</code></pre> <p>The StepUp RepRep extension (for reproducible reporting) is installed with:</p> <pre><code>pip install stepup-reprep\n</code></pre>"},{"location":"license/","title":"License","text":""},{"location":"license/#source-code-license","title":"Source code license","text":"<p>StepUp Core is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.</p> <p>StepUp Core is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.</p> <p>You should have received a copy of the GNU General Public License along with this program. If not, see https://www.gnu.org/licenses/.</p>"},{"location":"license/#documentation-license","title":"Documentation license","text":"<p>StepUp Core\u2019s documentation is distributed under the Creative Commons CC BY-SA 4.0 license.</p>"},{"location":"advanced_topics/amending_static_inputs/","title":"Amending Static Inputs","text":"<p>Occasionally, it may be convenient to declare a static file and then use it as input in the same script. As of StepUp 1.2.0, this is allowed and no longer treated as a cyclic dependency.</p>"},{"location":"advanced_topics/amending_static_inputs/#example","title":"Example","text":"<p>Create the following <code>plan.py</code>, which declares a static file, amends it as input, and then opens it to print it to the standard output.</p> <pre><code>#!/usr/bin/env python\nfrom stepup.core.api import amend, static\n\nstatic(\"config.txt\")\namend(inp=\"config.txt\")\nwith open(\"config.txt\") as fh:\n    print(fh.read().strip())\n</code></pre> <p>Also create a <code>config.txt</code> file with some contents.</p> <p>In more realistic scenarios, <code>config.txt</code> may be used to decide which steps to add etc. For a more elaborate example, take a look at the <code>plan.py</code> that is used to run all tutorial examples.</p> <p>Make <code>plan.py</code> executable and run it as follows:</p> <pre><code>chmod +x plan.py\nstepup -n -w1\n</code></pre> <p>You should get the following terminal output:</p> <pre><code>  DIRECTOR \u2502 Listening on /tmp/stepup-########/director\n  DIRECTOR \u2502 Launched worker 0\n     PHASE \u2502 run\n     START \u2502 ./plan.py\n   SUCCESS \u2502 ./plan.py\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 Standard output \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nThis is a config file.\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n  WORKFLOW \u2502 Dumped to .stepup/workflow.mpk.xz\n  DIRECTOR \u2502 Stopping workers.\n  DIRECTOR \u2502 See you!\n</code></pre>"},{"location":"advanced_topics/amending_steps/","title":"Amending steps","text":"<p>Every step in StepUp can inform the director process of additional inputs or environment variables it uses, or of additional (volatile) outputs it creates. However, defining an amended input will fail when that file is not yet built nor known as a static file. In this case, the step can end early and will be rescheduled by the director process when the amended input becomes available.</p> <p>The <code>amend()</code> function implements this feature and is convenient in various scenarios:</p> <ul> <li> <p>This is particularly useful when a step uses input files that refer to other input files.   It may happen that some of these other input files still need to be generated by other steps.   Once built, the other inputs may again refer to more input files, etc.   Such dependencies cannot be discovered in advance, simply because not all inputs are available before running the steps that generate them.   (This is a common scenario when writing LaTeX documents of which parts are generated by scripts.)</p> </li> <li> <p>Another use case is that some steps may take their default configuration from environment variables if some command-line options are missing.   In this case, <code>amend</code> can be used to specify the environment variables used.</p> </li> <li> <p>Some steps may produce a list of volatile outputs, some of which are difficult to know upfront.   One may specify such volatile outputs with <code>amend</code> after they have been created.</p> </li> </ul> <p>To the best of our knowledge, there is no equivalent of <code>amend</code> in other build tools. Some features in Ninja cover what can be achieved with <code>amend</code>.</p>"},{"location":"advanced_topics/amending_steps/#example","title":"Example","text":"<p>Example source files: advanced_topics/amending_steps/</p> <p>This example intentionally creates a simple scenario with an amended input. This is a somewhat silly example to illustrate the concept. You may achieve the same result without amending, because you have full control over all scripts in the example.</p> <p>Create the following <code>plan.py</code>, where the first step is a script that will discover it needs an additional input.</p> <pre><code>#!/usr/bin/env python\nfrom stepup.core.api import static, step\n\nstatic(\"step.py\")\nstep(\"./step.py\", inp=[\"step.py\", \"sources.txt\"])\nstep(\"echo input.txt &gt; ${out}\", out=\"sources.txt\")\nstep(\"echo You better read this. &gt; input.txt\", out=\"input.txt\", optional=True)\n</code></pre> <p>In addition, create a file <code>input.txt</code> with some arbitrary contents and the following <code>step.py</code> script:</p> <pre><code>#!/usr/bin/env python\nfrom stepup.core.api import amend\n\n# Parse the sources.txt file\nwith open(\"sources.txt\") as fh:\n    paths_inp = fh.read().split()\n\n# Write all files from source.txt to the standard output.\nkeep_going = amend(inp=paths_inp)\nif keep_going:\n    # This branch is only executed if the amended input is present.\n    for path_inp in paths_inp:\n        print(f\"Contents of {path_inp}:\")\n        with open(path_inp) as fh:\n            print(fh.read())\n</code></pre> <p>Make the scripts executable and fire up StepUp to see how it deals with the amended input:</p> <pre><code>chmod +x step.py plan.py\nstepup -n -w1\n</code></pre> <p>You should get the following terminal output:</p> <pre><code>  DIRECTOR \u2502 Listening on /tmp/stepup-########/director\n  DIRECTOR \u2502 Launched worker 0\n     PHASE \u2502 run\n     START \u2502 ./plan.py\n   SUCCESS \u2502 ./plan.py\n     START \u2502 echo input.txt &gt; sources.txt\n   SUCCESS \u2502 echo input.txt &gt; sources.txt\n     START \u2502 ./step.py\nRESCHEDULE \u2502 ./step.py\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 Rescheduling due to unavailable amended inputs \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\ninput.txt\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n     START \u2502 echo You better read this. &gt; input.txt\n   SUCCESS \u2502 echo You better read this. &gt; input.txt\n     START \u2502 ./step.py\n   SUCCESS \u2502 ./step.py\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 Standard output \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nContents of input.txt:\nYou better read this.\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n  WORKFLOW \u2502 Dumped to .stepup/workflow.mpk.xz\n  DIRECTOR \u2502 Stopping workers.\n  DIRECTOR \u2502 See you!\n</code></pre> <p>The output shows that <code>./step.py</code> first stopped early due to the missing file <code>input.txt</code>. Once this became clear, StepUp scheduled the optional step to generate the requested input. Later, StepUp ran <code>./step.py</code> again.</p>"},{"location":"advanced_topics/amending_steps/#try-the-following","title":"Try the Following","text":"<ul> <li> <p>Run StepUp again without making any changes.   As expected, all steps are skipped.   The <code>workflow.mpk.xz</code> file also stores the amended information,   so these don\u2019t need to be rediscovered later.</p> </li> <li> <p>Modify the <code>plan.py</code> file to include a second amended input, for example, <code>other.txt</code>.   Run StepUp with these changes.   Because <code>sources.txt</code> contains a new file, StepUp will try re-running   <code>./step.py</code>, which will amend new inputs that require the step to be rescheduled again.</p> </li> </ul>"},{"location":"advanced_topics/blocked_steps/","title":"Blocked Steps","text":"<p>As discussed in the previous tutorial, StepUp has several mechanisms to ignore certain steps. As a rule, StepUp will always try to execute all steps, and not doing so is the exception.</p> <p>A valid reason for ignoring some steps is illustrated in the following schematic:</p> <pre><code>     File           In development            File                 Costly\n|-------------|      |----------|      |-----------------|      |----------|\n|  input.txt  |  =&gt;  |  Step 1  |  =&gt;  |  converted.txt  |  =&gt;  |  Step 2  |\n|-------------|      |----------|      |-----------------|      |----------|\n</code></pre> <p>Imagine that <code>Step 2</code> is very expensive and you are developing a script for <code>Step 1</code>. In practice, it takes several iterations to get <code>Step 1</code> working properly. This can be verified by analyzing the file <code>converted.txt</code> or with unit tests.</p> <p>To avoid executing <code>Step 2</code> at every iteration in the development of <code>Step 1</code>, you can block this step. All step-creating functions accept an optional <code>block=True</code> keyword argument to prevent them from being executed. Blocking steps is a temporary measure, meant to be reverted once you\u2019re done with <code>Step 1</code>.</p> <p>Blocking steps has some consequences:</p> <ul> <li>Blocked steps remain in the PENDING state, meaning that outdated output files are not cleaned up automatically.</li> <li>At the end of the run phase, a list of blocked steps is shown, to remind the user that some steps are blocked.</li> <li>Subsequent steps, which use outputs of blocked or pending steps, also remain pending.</li> </ul>"},{"location":"advanced_topics/blocked_steps/#example","title":"Example","text":"<p>Example source files: advanced_topics/blocked_steps/</p> <p>The following <code>plan.py</code> illustrates the blocking mechanism. The copy commands are too simple and cheap to justify blocking, so this is just an example to illustrate the mechanism only.</p> <pre><code>#!/usr/bin/env python\nfrom stepup.core.api import copy, step\n\nstep(\"echo hello &gt; ${out}\", out=\"a.txt\")\ncopy(\"a.txt\", \"b.txt\", block=True)\ncopy(\"b.txt\", \"c.txt\")\n</code></pre> <p>Make this plan executable and run it with StepUp:</p> <pre><code>chmod +x plan.py\nstepup -n -w1\n</code></pre> <p>You should get the following terminal output:</p> <pre><code>  DIRECTOR \u2502 Listening on /tmp/stepup-########/director\n  DIRECTOR \u2502 Launched worker 0\n     PHASE \u2502 run\n     START \u2502 ./plan.py\n   SUCCESS \u2502 ./plan.py\n     START \u2502 echo hello &gt; a.txt\n   SUCCESS \u2502 echo hello &gt; a.txt\n   WARNING \u2502 2 steps remain pending due to blocked steps\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 Blocked steps \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nstep:cp -aT a.txt b.txt\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   WARNING \u2502 Skipping cleanup due to incomplete build.\n  WORKFLOW \u2502 Dumped to .stepup/workflow.mpk.xz\n  DIRECTOR \u2502 Stopping workers.\n  DIRECTOR \u2502 See you!\n</code></pre>"},{"location":"advanced_topics/blocked_steps/#try-the-following","title":"Try the Following","text":"<ul> <li> <p>Unblock the copy step, run StepUp, block it again, and run StepUp again.   Although the copy commands are no longer executed, their outputs (<code>b.txt</code> and <code>c.txt</code>)   are not cleaned up.   This is the expected behavior because automatic cleaning is only performed when all   (non-optional) steps have been executed successfully.</p> </li> <li> <p>Unblock the copy step, run StepUp, and then make the last copy command optional.   In this case, the output of the optional step (<code>c.txt</code>) will be removed.</p> </li> </ul>"},{"location":"advanced_topics/cyclic_dependencies/","title":"Cyclic dependencies","text":"<p>Cyclic dependencies are defined in StepUp as closed loops in the \u201csupplier \u279c consumer\u201d graph. One may construct these in a <code>plan.py</code>, which will result in an error message.</p> <p>In theory, one could also have cycles in the \u201ccreator \u279c product\u201d graph, but these are excluded by construction and therefore not relevant to discuss in the tutorial.</p>"},{"location":"advanced_topics/cyclic_dependencies/#example","title":"Example","text":"<p>Create the following <code>plan.py</code>, which is StepUp\u2019s equivalent of a snake biting its own tail:</p> <pre><code>#!/usr/bin/env python\nfrom stepup.core.api import copy\n\ncopy(\"a.txt\", \"b.txt\")\ncopy(\"b.txt\", \"a.txt\")\n</code></pre> <p>Make the plan executable and give it a try as follows:</p> <pre><code>chmod +x plan.py\nstepup -n -w1\n</code></pre> <p>You will get the following terminal output showing that this plan won\u2019t work.</p> <pre><code>  DIRECTOR \u2502 Listening on /tmp/stepup-########/director\n  DIRECTOR \u2502 Launched worker 0\n     PHASE \u2502 run\n     START \u2502 ./plan.py\n      FAIL \u2502 ./plan.py\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 Step info \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nCommand               ./plan.py\nReturn code           1\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 Standard error \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nTraceback (most recent call last):\n  File \"/home/toon/univ/reprep/stepup-core/docs/advanced_topics/cyclic_dependencies/./plan.py\", line 5, in &lt;module&gt;\n    copy(\"b.txt\", \"a.txt\")\n  File \"/home/toon/univ/reprep/stepup-core/stepup/core/api.py\", line 517, in copy\n    return step(\"cp -aT ${inp} ${out}\", inp=path_src, out=path_dst, optional=optional, block=block)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/home/toon/univ/reprep/stepup-core/stepup/core/api.py\", line 355, in step\n    step_key = RPC_CLIENT.call.step(\n               ^^^^^^^^^^^^^^^^^^^^^\n  File \"/home/toon/univ/reprep/stepup-core/stepup/core/rpc.py\", line 448, in __call__\n    _handle_error(body, name, args, kwargs)\n  File \"/home/toon/univ/reprep/stepup-core/stepup/core/rpc.py\", line 69, in _handle_error\n    raise RPCError(f\"An exception was raised in the server during the call {fmt_call}: \\n\\n{body}\")\nstepup.core.exceptions.RPCError: An exception was raised in the server during the call step('step:./plan.py', 'cp -aT b.txt a.txt', [Path('b.txt')], [], [Path('a.txt')], [], Path('./'), False, None, False):\nTraceback (most recent call last):\n  File \"/home/toon/univ/reprep/stepup-core/stepup/core/rpc.py\", line 194, in _handle_request\n    result = call(*bound.args, **bound.kwargs)\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/home/toon/univ/reprep/stepup-core/stepup/core/director.py\", line 376, in step\n    return self._workflow.define_step(\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/home/toon/univ/reprep/stepup-core/stepup/core/workflow.py\", line 622, in define_step\n    self.create_file(step_key, out_path, FileState.PENDING)\n  File \"/home/toon/univ/reprep/stepup-core/stepup/core/workflow.py\", line 375, in create_file\n    self.supply(creator_key, file_key)\n  File \"/home/toon/univ/reprep/stepup-core/stepup/core/cascade.py\", line 493, in supply\n    self.check_cyclic(supplier_key, consumer_key)\n  File \"/home/toon/univ/reprep/stepup-core/stepup/core/cascade.py\", line 447, in check_cyclic\n    self.report_cyclic(src_key, dst_key)\n  File \"/home/toon/univ/reprep/stepup-core/stepup/core/cascade.py\", line 422, in report_cyclic\n    raise CyclicError(\"\\n\".join(lines))\nstepup.core.exceptions.CyclicError: New relation introduces cyclic dependency\nsrc = step:cp -aT b.txt a.txt\ndst = file:a.txt\ncycle:\n  step:cp -aT b.txt a.txt\n  file:b.txt\n  step:cp -aT a.txt b.txt\n  file:a.txt\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   WARNING \u2502 1 step(s) failed, see error messages above\n   WARNING \u2502 Scheduler is put on hold. Not reporting pending steps.\n   WARNING \u2502 Skipping cleanup due to incomplete build.\n  WORKFLOW \u2502 Dumped to .stepup/workflow.mpk.xz\n   WARNING \u2502 Dissolving the workflow due to an exceptions while the graph was being changed.\n  DIRECTOR \u2502 Stopping workers.\n  DIRECTOR \u2502 See you!\n</code></pre>"},{"location":"advanced_topics/environment_variables/","title":"Environment Variables","text":"<p>When defining a step, one can specify the environment variables it uses (not their values). When starting StepUp with a different value for any of these variables, StepUp will know that it has to repeat the step instead of skipping it.</p> <p>One can only change an environment variable by stopping StepUp, changing the variable, and then starting StepUp again. One cannot modify environment variables while StepUp is running.</p>"},{"location":"advanced_topics/environment_variables/#example","title":"Example","text":"<p>Example source files: advanced_topics/environment_variables/</p> <p>Create the following <code>plan.py</code>:</p> <pre><code>#!/usr/bin/env python\nfrom stepup.core.api import step\n\nstep(\"echo ${MYVAR}\", env=\"MYVAR\")\n</code></pre> <p>Make it executable and run StepUp with a specific value of the variable:</p> <pre><code>chmod +x plan.py\nMYVAR=foo stepup -n -w1\n</code></pre> <p>You will see the following output:</p> <pre><code>  DIRECTOR \u2502 Listening on /tmp/stepup-########/director\n  DIRECTOR \u2502 Launched worker 0\n     PHASE \u2502 run\n     START \u2502 ./plan.py\n   SUCCESS \u2502 ./plan.py\n     START \u2502 echo ${MYVAR}\n   SUCCESS \u2502 echo ${MYVAR}\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 Standard output \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nfoo\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n  WORKFLOW \u2502 Dumped to .stepup/workflow.mpk.xz\n  DIRECTOR \u2502 Stopping workers.\n  DIRECTOR \u2502 See you!\n</code></pre> <p>The variable substitution is performed in the subshell of the worker. StepUp will not try to substitute <code>${MYVAR}</code> before starting the step. The special variables <code>${inp}</code> and <code>${out}</code> are exceptions to this rule, as discussed in the tutorial on dependencies.</p>"},{"location":"advanced_topics/environment_variables/#try-the-following","title":"Try the Following","text":"<ul> <li> <p>Repeat <code>MYVAR=foo stepup -n -w1</code> without making changes.   You will see that the <code>echo</code> step is skipped as expected.</p> </li> <li> <p>Now run <code>MYVAR=bar stepup -n -w1</code>.   This time, the variable change will cause the step to be executed.</p> </li> </ul>"},{"location":"advanced_topics/here_and_root/","title":"HERE and ROOT variables","text":"<p>When a worker runs a step, it defines several environment variables, including <code>HERE</code> and <code>ROOT</code>, which can be relevant for writing advanced scripts. (The workers also define variables starting with <code>STEPUP_</code>, but these are only useful to StepUp itself, not to end users.)</p> <p>The two variables are defined as follows:</p> <ul> <li><code>HERE</code> contains the relative path from the directory where StepUp was started to the current working directory of the step.</li> <li><code>ROOT</code> contains the opposite: the relative directory from the current working directory to the directory where StepUp was started.</li> </ul> <p>Hence, <code>HERE/ROOT</code> and <code>ROOT/HERE</code> normalize to the current directory: <code>./</code>.</p> <p>These variables can be useful in the following cases:</p> <ul> <li>For out-of-source builds, where you want to replicate the directory structure of the source material.   (See example below.)</li> <li>To reference a local script that is stored in the top-level directory of your project: <code>${ROOT}/script.py</code></li> </ul>"},{"location":"advanced_topics/here_and_root/#example","title":"Example","text":"<p>Example source files: advanced_topics/here_and_root/</p> <p>This example represents a minimal out-of-source build, which is nevertheless involving several files, due to the inherent complexity of out-of-source builds.</p> <p>Create a <code>source/</code> directory with the following <code>source/plan.py</code>:</p> <pre><code>#!/usr/bin/env python\nfrom stepup.core.api import mkdir, plan, static\n\nstatic(\"sub/\", \"sub/plan.py\")\nmkdir(\"../public/\")\nplan(\"sub/\")\n</code></pre> <p>Also create a <code>source/sub/</code> directory with a file <code>source/sub/example.txt</code> (arbitrary contents) and the following <code>source/sub/plan.py</code>:</p> <pre><code>#!/usr/bin/env python\nfrom stepup.core.api import copy, mkdir, static\n\nstatic(\"example.txt\")\ndst = \"${ROOT}/../public/${HERE}/\"\nmkdir(dst)\ncopy(\"example.txt\", dst)\n</code></pre> <p>Make the scripts executable and run everything as follows:</p> <pre><code>chmod +x plan.py sub/plan.py\nstepup -n -w1\n</code></pre> <p>You should get the following terminal output:</p> <pre><code>  DIRECTOR \u2502 Listening on /tmp/stepup-########/director\n  DIRECTOR \u2502 Launched worker 0\n     PHASE \u2502 run\n     START \u2502 ./plan.py\n   SUCCESS \u2502 ./plan.py\n     START \u2502 mkdir -p ../public/\n   SUCCESS \u2502 mkdir -p ../public/\n     START \u2502 ./plan.py  # wd=sub/\n   SUCCESS \u2502 ./plan.py  # wd=sub/\n     START \u2502 mkdir -p ../../public/sub/  # wd=sub/\n   SUCCESS \u2502 mkdir -p ../../public/sub/  # wd=sub/\n     START \u2502 cp -aT example.txt ../../public/sub/example.txt  # wd=sub/\n   SUCCESS \u2502 cp -aT example.txt ../../public/sub/example.txt  # wd=sub/\n  WORKFLOW \u2502 Dumped to .stepup/workflow.mpk.xz\n  DIRECTOR \u2502 Stopping workers.\n  DIRECTOR \u2502 See you!\n</code></pre> <p>The top-level <code>plan.py</code> provides some infrastructure: some static files and creating the public directory where the outputs will be created.</p> <p>The script <code>sub/plan.py</code> uses the <code>ROOT</code> and <code>HERE</code> variables in a way that is independent of the location of this <code>sub/plan.py</code>. It may therefore be fixed in an environment variable, for example:</p> <pre><code>export DST='../public/${HERE}'\n</code></pre> <p>Then you can get this path in any <code>plan.py</code> as follows:</p> <pre><code>from stepup.core.api import getenv\ndst = getenv(\"DST\", is_path=True)\n</code></pre> <p>The <code>is_path=True</code> option implies that the variable is a path defined globally. If it is a relative path, it will be interpreted relative to the working directory where StepUp was started and will be translated to the working directory of the script calling <code>getenv</code>. Any variables present in the environment variable will also be substituted once.</p>"},{"location":"advanced_topics/here_and_root/#try-the-following","title":"Try the Following","text":"<ul> <li> <p>Modify the scripts <code>plan.py</code> and <code>sub/plan.py</code> to utilize a <code>DST</code> variable as explained above.   To achieve this, define <code>DST</code> externally, for instance, by starting StepUp as <code>DST='../public/${HERE}' stepup -n -w1</code>.</p> </li> <li> <p>As a follow-up to the previous point, run StepUp with a different <code>DST</code> value.   For example: <code>DST='../out/${HERE}' stepup -n -w1</code>.   You will see that all old output files get cleaned up after the new output is created.</p> </li> </ul>"},{"location":"advanced_topics/introduction/","title":"Introduction","text":"<p>The advanced topic tutorials are recommended after completing the \u201cGetting Started\u201d tutorials and gaining some hands-on experience with StepUp.</p> <p>The following tutorials are useful for larger build workflows with more specialized needs, as well as for developing domain-specific StepUp extensions.</p>"},{"location":"advanced_topics/manual_cleaning/","title":"Manual Cleaning","text":"<p>The automatic cleaning discussed in a previous tutorial is StepUp\u2019s default mechanism for removing irrelevant and unwanted files. In exceptional situations, the automatic cleaning may not be sufficient, and a more manual solution may be required. Examples of such situations are:</p> <ul> <li> <p>A dependency has changed that StepUp cannot track, such as an upgrade of a system-wide tool used in your workflow.   In this situation, StepUp will not make the affected steps pending, and you may want to remove the affected outputs to rebuild them.</p> </li> <li> <p>You are planning a rather drastic reorganization of your project, including renaming some directories containing output files.   When directories are renamed, StepUp can no longer clean up old outputs in the renamed directories.   In this situation, you will want to clean up outputs manually before renaming directories.</p> </li> </ul> <p>Simply removing outputs with the <code>rm</code> command is possible but quickly becomes tedious for larger projects. The <code>cleanup</code> program, a companion to <code>stepup</code>, can selectively remove a large number of outputs with minimal end-user effort. You need to pass as arguments the files whose (indirect) outputs you want to remove. Such arguments can be one of the two things:</p> <ol> <li> <p>If a file is given, all outputs using this file as input will be removed.    Furthermore, if the file itself is also a build output, it will also be removed.</p> </li> <li> <p>If a directory is given, all outputs will be removed from this directory.    Furthermore, if the directory is created in the build, it will also be removed.</p> </li> </ol> <p>Files are removed recursively, so outputs of outputs are also cleaned up. <code>cleanup</code> will only remove files with status <code>PENDING</code>, <code>BUILT</code> or <code>VOLATILE</code>. Static files, i.e., files you have created, are never removed.</p> <p>There are a few gotchas you should be aware of:</p> <ol> <li> <p>The <code>cleanup</code> script sends a list of paths to be cleaned to the director process.    The director takes care of analyzing the workflow to decide which files need to be removed.    For this reason, an instance of <code>stepup</code> must be running for <code>cleanup</code> to work.</p> </li> <li> <p>By default, you need to run <code>cleanup</code> in the top-level directory where you also started <code>stepup</code>.    This requirement can be lifted by defining the top-level directory in the <code>STEPUP_ROOT</code> environment variable, as explained in the next tutorial.</p> </li> </ol> <p>If <code>cleanup</code> cannot connect to the StepUp director process, it will keep trying and print warning messages, for example:</p> <pre><code>Trying to contact StepUp director process.\nFile ./.stepup/director.log not found.  Waiting 0.1 seconds.\nSocket /tmp/stepup-c9a12bau/director read from ./.stepup/director.log does not exist. Stepup not running?  Waiting 0.2 seconds.\nSocket /tmp/stepup-c9a12bau/director read from ./.stepup/director.log does not exist. Stepup not running?  Waiting 0.3 seconds.\n...\n</code></pre> <p>When you see this, either start <code>stepup</code> in a second terminal or interrupt <code>cleanup</code> with Ctrl-C.</p>"},{"location":"advanced_topics/manual_cleaning/#try-the-following","title":"Try the Following","text":"<ul> <li> <p>The Static Named Glob tutorial provides a good test case for experimenting with <code>cleanup</code>.   For this example, run <code>stepup</code> without any arguments.   Then open a second terminal in the same directory and run <code>cleanup ch3/sec3_1_applications.txt</code>.   You will see that the following files have been deleted:</p> <ul> <li><code>ch3/sec3_1_applications.md</code></li> <li><code>public/ch3.md</code></li> </ul> </li> <li> <p>In the same way as in the previous point, try removing all outputs with <code>cleanup ./</code>.</p> </li> </ul>"},{"location":"advanced_topics/optional_steps/","title":"Optional Steps","text":"<p>By default, StepUp will build all steps created. As an exception, steps can be made optional by adding the <code>optional=True</code> option. This is the opposite of most build tools, where steps are only executed when they are targets.</p> <p>The reason for this difference is that conventional build tools work with rigid predefined graphs. By accepting command-line arguments with target steps, they introduce some flexibility: this lets the user control which part of the graph is executed.</p> <p>StepUp offers such flexibility in a different way. The basic premise is that all outdated or missing outputs need to be (re)built. It is the responsibility of the build tool to figure out which steps need executing. This responsibility should not be shifted to users by expecting them to specify targets. That said, some legitimate exceptions exist, in which ignoring steps is a desirable feature. These are supported by StepUp as follows:</p> <ul> <li> <p>One can define steps conditionally, e.g., as in the tutorial Static Glob Conditional.   Such conditionals are controlled by external factors and   are picked up by your <code>plan.py</code> without manual interventions.</p> </li> <li> <p>One can make steps optional, as in this tutorial.   This is useful when multiple steps are defined in a loop, as in the Static Glob tutorial, of which not all steps are required for the end result.   Use this feature wisely:   It is obviously inefficient to define a few thousand steps of which only a handful are needed.</p> </li> <li> <p>As shown in the next tutorial, one may also block steps,   as a temporary measure to speed up the edit-build cycle.</p> </li> </ul>"},{"location":"advanced_topics/optional_steps/#example","title":"Example","text":"<p>Example source files: advanced_topics/optional_steps/</p> <p>The example below uses the <code>script()</code> feature introduced in Script (Single Case) and Script (Multiple Cases) to create a somewhat entertaining example. However, practically all step-generating functions support the <code>optional</code> argument, and can thus be made optional in the same way.</p> <p>Create a first script <code>generate.py</code> that generates sequences of the logistic map for different values of the parameter r:</p> <pre><code>#!/usr/bin/env python\nfrom stepup.core.script import driver\n\n\ndef cases():\n    yield 2.2\n    yield 2.8\n    yield 3.2\n    yield 3.8\n\n\nCASE_FMT = \"logmap_{:5.3f}\"\n\n\ndef case_info(r):\n    return {\"out\": f\"logmap_{r:5.3f}.txt\", \"r\": r}\n\n\ndef run(out, r):\n    x = 0.1\n    with open(out, \"w\") as fh:\n        for _ in range(100):\n            print(f\"{x:10.5f}\", file=fh)\n            x = r * x * (1 - x)\n\n\nif __name__ == \"__main__\":\n    driver()\n</code></pre> <p>Then, write a <code>plot.py</code> script that plots only one of these sequences:</p> <pre><code>#!/usr/bin/env python\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nfrom stepup.core.script import driver\n\n\ndef info():\n    r = 3.2\n    return {\n        \"inp\": [\"matplotlibrc\", f\"logmap_{r:5.3f}.txt\"],\n        \"out\": \"plot_logmap.png\",\n    }\n\n\ndef run(inp, out):\n    mpl.rc_file(inp[0])\n    seq = np.loadtxt(inp[1])\n    fig, ax = plt.subplots()\n    ax.plot(seq)\n    ax.set_xlabel(\"n\")\n    ax.set_ylabel(\"x_n\")\n    fig.savefig(out)\n\n\nif __name__ == \"__main__\":\n    driver()\n</code></pre> <p>The <code>plan.py</code> file adds steps for both scripts, but makes the data generation optional:</p> <pre><code>#!/usr/bin/env python\nfrom stepup.core.api import script, static\n\nstatic(\"generate.py\", \"plot.py\", \"matplotlibrc\")\nscript(\"generate.py\", optional=True)\nscript(\"plot.py\")\n</code></pre> <p>Finally, make the scripts executable and run StepUp:</p> <pre><code>chmod +x generate.py plot.py plan.py\nstepup -n -w1\n</code></pre> <p>You should get the following output:</p> <pre><code>  DIRECTOR \u2502 Listening on /tmp/stepup-########/director\n  DIRECTOR \u2502 Launched worker 0\n     PHASE \u2502 run\n     START \u2502 ./plan.py\n   SUCCESS \u2502 ./plan.py\n     START \u2502 ./generate.py plan --optional\n   SUCCESS \u2502 ./generate.py plan --optional\n     START \u2502 ./plot.py plan\n   SUCCESS \u2502 ./plot.py plan\n     START \u2502 ./generate.py run -- 'logmap_3.200'\n   SUCCESS \u2502 ./generate.py run -- 'logmap_3.200'\n     START \u2502 ./plot.py run\n   SUCCESS \u2502 ./plot.py run\n  WORKFLOW \u2502 Dumped to .stepup/workflow.mpk.xz\n  DIRECTOR \u2502 Stopping workers.\n  DIRECTOR \u2502 See you!\n</code></pre> <p>Note that, in this case, it would be trivial to modify the <code>generate.py</code> script to only generate the sequence of interest. Whenever such a simpler approach is possible, it is always preferable. However, in more complex use cases, it is not always possible to figure out which steps are going to be needed or not. In such situations, optional steps can be convenient.</p>"},{"location":"advanced_topics/optional_steps/#try-the-following","title":"Try the Following","text":"<ul> <li> <p>Remove the <code>optional=True</code> keyword argument and rerun the plan.   As expected, additional text files with sequences will be created.</p> </li> <li> <p>Restore the <code>optional=True</code> keyword argument and rerun the plan.   As expected, the Automatic Cleaning feature   removes the outputs that were generated by steps that are no longer present in the workflow.</p> </li> </ul>"},{"location":"advanced_topics/pools/","title":"Pools","text":"<p>It is nearly always preferred to run steps in parallel when possible, so StepUp will launch any queued step as soon as a worker becomes available. A \u201cpool\u201d is a simple mechanism to limit parallelization in the few cases that this would be counterproductive:</p> <ol> <li> <p>Some programs behave poorly (have bugs) when multiple instances are running in parallel.    Here are a few examples encountered in the development of StepUp RepRep:</p> <ul> <li>Inkscape/issue4716</li> <li>markdown-katex/issue16</li> </ul> </li> <li> <p>Some steps may consume a lot of resources, such as memory,    and would require more resources than available when running in parallel.</p> </li> <li> <p>Software licenses may not allow for more than a given number of instances running in parallel.</p> </li> </ol> <p>One defines a pool with <code>pool(name, size)</code>. The size is the maximum number of steps running concurrently within the pool. Steps are assigned to a pool by defining them with the <code>pool=name</code> keyword argument.</p> <p>For StepUp, mainly the first use case (working around concurrency bugs) is relevant, for which the pool size is 1.</p>"},{"location":"advanced_topics/pools/#example","title":"Example","text":"<p>Example source files: advanced_topics/pools/</p> <p>The example here illustrates the use of a pool in a simple test case. The steps can run easily in parallel, so you can experiment with the pool size.</p> <p>Create the following <code>plan.py</code>:</p> <pre><code>#!/usr/bin/env python\nfrom stepup.core.api import pool, step\n\npool(\"test\", 2)\nstep(\"sleep 0.1; echo A\", pool=\"test\")\nstep(\"sleep 0.1; echo B\", pool=\"test\")\nstep(\"sleep 0.1; echo C\", pool=\"test\")\n</code></pre> <p>The <code>sleep</code> command ensures that each step lasts long enough to guarantee they will run in parallel when allowed.</p> <p>Make the plan executable and run it with StepUp:</p> <pre><code>chmod +x plan.py\nstepup -n -w4\n</code></pre> <p>You should get the following output:</p> <pre><code>  DIRECTOR \u2502 Listening on /tmp/stepup-########/director\n  DIRECTOR \u2502 Launched worker 0\n  DIRECTOR \u2502 Launched worker 1\n  DIRECTOR \u2502 Launched worker 2\n  DIRECTOR \u2502 Launched worker 3\n     PHASE \u2502 run\n     START \u2502 ./plan.py\n     START \u2502 sleep 0.1; echo A\n     START \u2502 sleep 0.1; echo B\n   SUCCESS \u2502 ./plan.py\n   SUCCESS \u2502 sleep 0.1; echo A\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 Standard output \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nA\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   SUCCESS \u2502 sleep 0.1; echo B\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 Standard output \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nB\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n     START \u2502 sleep 0.1; echo C\n   SUCCESS \u2502 sleep 0.1; echo C\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 Standard output \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nC\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n  WORKFLOW \u2502 Dumped to .stepup/workflow.mpk.xz\n  DIRECTOR \u2502 Stopping workers.\n  DIRECTOR \u2502 See you!\n</code></pre> <p>Initially, the <code>./plan.py</code> step and two <code>sleep+echo</code> commands are running in parallel. Despite having four workers, the third <code>sleep+echo</code> is only started after the previous two have finished.</p>"},{"location":"advanced_topics/pools/#try-the-following","title":"Try the Following","text":"<ul> <li> <p>Run <code>stepup -n -w4</code> again without making changes.   Skipping of steps requires some computation and comparison of hashes,   which is done by worker processes.   However, these hash computations are never subject to pool size restrictions.</p> </li> <li> <p>Change the pool size to <code>1</code> or <code>3</code> and verify that the output matches your expectations.   When you try this, StepUp will continue skipping steps.   To forcibly re-execute steps, you have two options:</p> <ol> <li>Remove the file <code>.stepup/workflow.mpk.xz</code> and start StepUp.</li> <li>Run StepUp interactively (without <code>-n</code>) and use the <code>f</code> key to start the workflow from scratch.</li> </ol> </li> </ul>"},{"location":"advanced_topics/static_deferred_glob/","title":"Static Deferred Glob","text":"<p>When dealing with massive datasets comprising tens of thousands of files, it doesn\u2019t make sense to render all of them as static when only a handful will actually be utilized. StepUp addresses this issue with the deferred glob feature, which makes previously unknown files static when:</p> <ol> <li>they are used as inputs of a new step and</li> <li>they match a deferred glob pattern.</li> </ol>"},{"location":"advanced_topics/static_deferred_glob/#example","title":"Example","text":"<p>Example source files: advanced_topics/static_deferred_glob/</p> <p>Create two text files with some content: <code>foo.txt</code> and <code>bar.txt</code>, and also the following <code>plan.py</code>:</p> <pre><code>#!/usr/bin/env python\nfrom stepup.core.api import glob, step\nfrom stepup.core.interact import graph\n\nglob(\"*.txt\", _defer=True)\nstep(\"cat foo.txt\", inp=\"foo.txt\")\ngraph(\"graph\")\n</code></pre> <p>Run the plan interactively with StepUp:</p> <pre><code>chmod +x plan.py\nstepup -n -w1\n</code></pre> <p>You should get the following screen output:</p> <pre><code>  DIRECTOR \u2502 Listening on /tmp/stepup-########/director\n  DIRECTOR \u2502 Launched worker 0\n     PHASE \u2502 run\n     START \u2502 ./plan.py\n   SUCCESS \u2502 ./plan.py\n     START \u2502 cat foo.txt\n   SUCCESS \u2502 cat foo.txt\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 Standard output \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nThis is foo.\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n  WORKFLOW \u2502 Dumped to .stepup/workflow.mpk.xz\n  DIRECTOR \u2502 Stopping workers.\n  DIRECTOR \u2502 See you!\n</code></pre> <p>As expected, <code>foo.txt</code> is used as a static file. Of course, this would also have been the case without the <code>_defer=True</code> option. The key difference is that with <code>_defer=True</code>, StepUp does not create a list of all matching <code>*.txt</code> files. This can be seen when examining the file <code>graph.txt</code>, which has no trace of <code>bar.txt</code>:</p> <pre><code>root:\n             version = v1\n             creates   file:./\n             creates   file:plan.py\n             creates   step:./plan.py\n\nfile:plan.py\n                path = plan.py\n               state = STATIC\n          created by   root:\n            consumes   file:./\n            supplies   step:./plan.py\n\nfile:./\n                path = ./\n               state = STATIC\n          created by   root:\n            supplies   file:foo.txt\n            supplies   file:plan.py\n            supplies   step:./plan.py\n            supplies   step:cat foo.txt\n\nstep:./plan.py\n             workdir = ./\n             command = ./plan.py\n               state = RUNNING\n          created by   root:\n            consumes   file:./\n            consumes   file:plan.py\n             creates   dg:'*.txt'\n             creates   step:cat foo.txt\n\ndg:'*.txt'\n          created by   step:./plan.py\n             creates   file:foo.txt\n\nfile:foo.txt\n                path = foo.txt\n               state = STATIC\n          created by   dg:'*.txt'\n            consumes   file:./\n            supplies   step:cat foo.txt\n\nstep:cat foo.txt\n             workdir = ./\n             command = cat foo.txt\n               state = QUEUED\n          created by   step:./plan.py\n            consumes   file:./\n            consumes   file:foo.txt\n</code></pre> <p>The node <code>dg:'*.txt;</code> in the graph (green octagon in the figures below) is the result of adding the <code>_defer=True</code> option. This node will create static files as they are needed by other steps. The deferred glob is ideal when there are a large number of files that could match the pattern, of which most are irrelevant for the build. For example, there could be thousands of <code>.txt</code> files in this scenario, but this would not have any effect on the resources consumed by StepUp.</p> <p>The supplier graph:</p> <p></p> <p>The creator graph:</p> <p></p>"},{"location":"advanced_topics/static_deferred_glob/#try-the-following","title":"Try the Following","text":"<ul> <li> <p>When using deferred globs, steps cannot create outputs that match the deferred glob.   This would mean that a built file could be made static when used as input later,   which is clearly inconsistent.   Try causing this error by adding a step <code>copy(\"foo.txt\", \"foo2.txt\")</code>.</p> </li> <li> <p>Remove the <code>_defer=True</code> option and inspect the corresponding <code>graph.txt</code>.   You should see that <code>bar.txt</code> is now indeed included in the graph.</p> </li> </ul>"},{"location":"advanced_topics/static_named_glob/","title":"Static Named Glob","text":"<p>Conventional glob patterns support a handful of different wildcards. For advanced use cases, StepUp also supports an in-house extension called \u201cnamed glob\u201d. For example, the following pattern will only match files with matching strings at the placeholders.</p> <pre><code>prefix_${*name}_something_${*name}.txt\n</code></pre> <p>The following will match:</p> <pre><code>prefix_aaa_something_aaa.txt\nprefix_bbb_something_bbb.txt\n</code></pre> <p>The following won\u2019t:</p> <pre><code>prefix_aaa_something_bbb.txt\nprefix_bbb_something_aaa.txt\n</code></pre> <p>Named globs are often useful when working with files distributed over multiple directories, each having a central file that repeats a part of the directory name.</p>"},{"location":"advanced_topics/static_named_glob/#example","title":"Example","text":"<p>Example source files: advanced_topics/static_named_glob/</p> <p>In the example below, each directory represents a chapter from course notes, containing source files for individual sections. In a realistic setting, one could envision building a PDF presentations from LaTeX sources instead. To keep the example independent of StepUp RepRep, text files will be copied to Markdown files, which will then be concatenated.</p> <p>Create the following directory layout with markdown files:</p> <pre><code>ch1/\nch1/sec1_1_introduction.txt\nch1/sec1_2_objectives.txt\nch2/\nch2/sec2_1_mathematical_requisites.txt\nch2/sec2_2_theory.txt\nch3/\nch3/sec3_1_applications.txt\nch3/sec3_2_discussion.txt\nch4/sec4_1_summary.txt\n</code></pre> <p>Create the following <code>plan.py</code>:</p> <pre><code>#!/usr/bin/env python\nfrom stepup.core.api import copy, glob, mkdir, step\n\n# Make all chapter directories static\nglob(\"ch*/\")\n\n# Enforce consistent chapter numbers throughout the match,\n# ignoring inconsistent txt files.\nmd_chapter = {}\nfor match in glob(\"ch${*ch}/sec${*ch}_${*sec}_${*name}.txt\", ch=\"[0-9]\", sec=\"[0-9]\"):\n    path_txt = match.single\n    path_md = path_txt[:-3] + \"md\"\n    copy(path_txt, path_md)\n    md_chapter.setdefault(match.ch, []).append(path_md)\n\n# Concatenate all markdown files per chapter\nmkdir(\"public/\")\nfor ch, paths_md in md_chapter.items():\n    step(\"cat ${inp} &gt; ${out}\", inp=paths_md, out=f\"public/ch{ch}.md\")\n</code></pre> <p>Note that the substrings matching the named glob patterns are accessible as attributes of the NGlobMatch object. For example, <code>match.ch</code> is the chapter number (as a string).</p> <p>Make the plan executable and run StepUp:</p> <pre><code>chmod +x plan.py\nstepup -n -w1\n</code></pre> <p>You should get the following output:</p> <pre><code>  DIRECTOR \u2502 Listening on /tmp/stepup-########/director\n  DIRECTOR \u2502 Launched worker 0\n     PHASE \u2502 run\n     START \u2502 ./plan.py\n   SUCCESS \u2502 ./plan.py\n     START \u2502 cp -aT ch1/sec1_1_introduction.txt ch1/sec1_1_introduction.md\n   SUCCESS \u2502 cp -aT ch1/sec1_1_introduction.txt ch1/sec1_1_introduction.md\n     START \u2502 cp -aT ch1/sec1_2_objectives.txt ch1/sec1_2_objectives.md\n   SUCCESS \u2502 cp -aT ch1/sec1_2_objectives.txt ch1/sec1_2_objectives.md\n     START \u2502 cp -aT ch2/sec2_1_mathematical_requisites.txt ch2/sec2_1_mathematical_requisites.md\n   SUCCESS \u2502 cp -aT ch2/sec2_1_mathematical_requisites.txt ch2/sec2_1_mathematical_requisites.md\n     START \u2502 cp -aT ch2/sec2_2_theory.txt ch2/sec2_2_theory.md\n   SUCCESS \u2502 cp -aT ch2/sec2_2_theory.txt ch2/sec2_2_theory.md\n     START \u2502 cp -aT ch3/sec3_1_applications.txt ch3/sec3_1_applications.md\n   SUCCESS \u2502 cp -aT ch3/sec3_1_applications.txt ch3/sec3_1_applications.md\n     START \u2502 cp -aT ch3/sec3_2_discussion.txt ch3/sec3_2_discussion.md\n   SUCCESS \u2502 cp -aT ch3/sec3_2_discussion.txt ch3/sec3_2_discussion.md\n     START \u2502 cp -aT ch4/sec4_1_summary.txt ch4/sec4_1_summary.md\n   SUCCESS \u2502 cp -aT ch4/sec4_1_summary.txt ch4/sec4_1_summary.md\n     START \u2502 mkdir -p public/\n   SUCCESS \u2502 mkdir -p public/\n     START \u2502 cat ch1/sec1_1_introduction.md ch1/sec1_2_objectives.md &gt; public/ch1.md\n   SUCCESS \u2502 cat ch1/sec1_1_introduction.md ch1/sec1_2_objectives.md &gt; public/ch1.md\n     START \u2502 cat ch2/sec2_1_mathematical_requisites.md ch2/sec2_2_theory.md &gt; public/ch2.md\n   SUCCESS \u2502 cat ch2/sec2_1_mathematical_requisites.md ch2/sec2_2_theory.md &gt; public/ch2.md\n     START \u2502 cat ch3/sec3_1_applications.md ch3/sec3_2_discussion.md &gt; public/ch3.md\n   SUCCESS \u2502 cat ch3/sec3_1_applications.md ch3/sec3_2_discussion.md &gt; public/ch3.md\n     START \u2502 cat ch4/sec4_1_summary.md &gt; public/ch4.md\n   SUCCESS \u2502 cat ch4/sec4_1_summary.md &gt; public/ch4.md\n  WORKFLOW \u2502 Dumped to .stepup/workflow.mpk.xz\n  DIRECTOR \u2502 Stopping workers.\n  DIRECTOR \u2502 See you!\n</code></pre>"},{"location":"advanced_topics/step_info/","title":"StepInfo objects","text":"<p>Note</p> <p>This feature is introduced in StepUp 1.3.0.</p> <p>The step() function always return an instance of StepInfo. This object holds arguments used to define the step, which may be useful for creating follow-up steps. All API functions that create a step by calling the step() function also return the StepInfo object.</p> <p>Especially for higher-level API functions that create more advanced steps, such as the ones in StepUp RepRep, it can be convenient to access the paths constructed inside the API function instead of reconstructing them manually in your <code>plan.py</code> script.</p> <p>The <code>StepInfo</code> object has <code>inp</code>, <code>env</code>, <code>out</code> and <code>vol</code> attributes, corresponding to the arguments passed into the <code>step()</code> function. The main difference to the arguments passed in, is that environment variables are substituted, the <code>step()</code> function always does.</p> <p>In addition, <code>StepInfo</code> has three methods: <code>filter_inp()</code>, <code>filter_out()</code> and <code>filter_vol()</code>, which can be used to get a subset of paths. These functions take the same arguments as those of the glob function and also return an NGlobMulti instance.</p> <p>Note that the <code>StepInfo</code> object will only contain information known at the time the step is defined. Amended information (inputs, outputs, \u2026) cannot be retreived from <code>StepInfo</code> objects.</p>"},{"location":"advanced_topics/step_info/#example","title":"Example","text":"<p>Let\u2019s assume you are using a library with an API function <code>create_fancy_pdf</code>, which takes a source directory as input and outputs a PDF file. (This is a hypothetical example for illustrative purposes.) You can find the full list of inputs and the output as follows:</p> <pre><code>from stepup.core.api import static, copy\nfrom stepup.fancy.api import create_fancy_pdf  # hypothetical API function\n\n# Plan the creation of the fancy PDF\nstatic(\"source/\")\nglob(\"source/**\", _defer=True)\ninfo = create_fancy_pdf(\"source/\")\n\n# Copy files related to the fancy PDF, e.g. to publish them or back up files.\nmkdir(\"../public\")\ncopy(info.filter_out(\"*.pdf\").single, \"../public/\")\nmkdir(\"../backup\")\nfor path_inp in info.inp:\n    copy(path_inp, \"../backup\")\n</code></pre>"},{"location":"advanced_topics/stepup_root/","title":"The STEPUP_ROOT variable","text":"<p>If you are working on a large project with several subdirectories, it may be useful to define the <code>STEPUP_ROOT</code> environment variable. It should contain the absolute path of the top-level directory where you would normally call the <code>stepup</code> and <code>cleanup</code> commands. (The top-level directory contains the <code>.stepup</code> subdirectory and the top-level <code>plan.py</code>.)</p> <p>With <code>STEPUP_ROOT</code> set, it is no longer necessary to change to the top-level directory before running <code>stepup</code> and <code>cleanup</code>. Also, the <code>cleanup</code> arguments will be interpreted correctly in subdirectories.</p> <p>You can manually set <code>STEPUP_ROOT</code> in the top-level directory as follows:</p> <pre><code>export STEPUP_ROOT=\"${PWD}\"\n</code></pre> <p>However, this can be tedious, as it has to be set each time you open a new terminal window. It is much easier to set such variables using direnv. Once direnv is configured on your system, you can create an <code>.envrc</code> file with the above <code>export</code> line in the top-level directory. Each time you change to the project directory or any of its subdirectories, the <code>STEPUP_ROOT</code> directory will automatically be set correctly.</p>"},{"location":"advanced_topics/variable_substitution/","title":"Variable Substitution","text":"<p>StepUp does not substitute environment variables is the command (first argument) of the <code>step()</code> function. As discussed in the tutorial on environment variables, the executing shell takes care of such substitutions.</p> <p>However, environment variables in all path-like arguments (e.g. <code>workdir</code>, <code>inp</code>, <code>out</code> and <code>vol</code>) of functions that take such arguments (<code>step()</code>, <code>amend()</code> etc.) are automatically substituted. This substitution takes place before the commands are sent to the director process and all used variables are communicated to the director with an <code>amend()</code> call.</p> <p>If a script needs an environment variable elsewhere, the function <code>getenv()</code> is recommended: It returns the value of the variable and calls <code>amend()</code> to tell the director that the current step depends on this variable.</p>"},{"location":"advanced_topics/variable_substitution/#example","title":"Example","text":"<p>Example source files: advanced_topics/variable_substitution/</p> <p>Create a <code>plan.py</code> with the following contents:</p> <pre><code>#!/usr/bin/env python\nfrom stepup.core.api import static, step\n\nstatic(\"step.py\", \"src_${MYVAR}.txt\")\nstep(\"./step.py &lt; ${inp} &gt; ${out}\", inp=\"src_${MYVAR}.txt\", out=\"dst_${MYVAR}.txt\")\n</code></pre> <p>In addition, create a script <code>step.py</code> as follows:</p> <pre><code>#!/usr/bin/env python\nimport sys\n\nfrom stepup.core.api import getenv\n\nmyname = repr(getenv(\"MYNUM\"))\nprint(f\"MYNUM={myname}\\n\")\nprint(\"Read from stdin:\")\nprint(sys.stdin.read())\n</code></pre> <p>Make the Python scripts executable and run them as follows:</p> <pre><code>chmod +x plan.py step.py\nMYVAR=foo stepup -n -w1\n</code></pre> <p>You should get the following terminal output:</p> <pre><code>  DIRECTOR \u2502 Listening on /tmp/stepup-########/director\n  DIRECTOR \u2502 Launched worker 0\n     PHASE \u2502 run\n     START \u2502 ./plan.py\n   SUCCESS \u2502 ./plan.py\n     START \u2502 ./step.py &lt; src_foo.txt &gt; dst_foo.txt\n   SUCCESS \u2502 ./step.py &lt; src_foo.txt &gt; dst_foo.txt\n  WORKFLOW \u2502 Dumped to .stepup/workflow.mpk.xz\n  DIRECTOR \u2502 Stopping workers.\n  DIRECTOR \u2502 See you!\n</code></pre> <p>The file <code>dst_foo.txt</code> will contain the following:</p> <pre><code>MYNUM=None\n\nRead from stdin:\nThis is src_foo\n</code></pre> <p>As shown in this example, the function <code>getenv()</code> returns <code>None</code> when a variable does not exist (or any other default you specify). When using variables like <code>${MYVAR}</code> in path-like arguments, the variable must exist or an exception is raised.</p>"},{"location":"advanced_topics/variable_substitution/#try-the-following","title":"Try the Following","text":"<ul> <li>Run StepUp without defining <code>MYVAR</code>: <code>stepup -n -w1</code>.   As explained above, this raises an exception.</li> <li>Run StepUp by also defining <code>MYNUM</code>: <code>MYVAR=foo MYNUM=1 stepup -n -w1</code>.   Now the string <code>'1'</code> is shown in the output <code>dst_foo.txt</code>.   Note that environment variables are always strings, and need to be converted to other types if needed.</li> </ul>"},{"location":"advanced_topics/volatile_outputs/","title":"Volatile Outputs","text":"<p>It may happen that steps produce auxiliary outputs that are not really of interest, but rather occur as a side effect. For example, LaTeX is notoriously productive in terms of output files. Some of these files will change with every run, e.g., because they contain timestamps.</p> <p>It is useful to inform StepUp of the existence of such volatile files, so they can be cleaned up when appropriate. However, there is no point in computing file hashes for them, as these files are not used as inputs later and may change for no good reason. One may pass a list of such files to the <code>vol</code> argument of the <code>step()</code> function.</p>"},{"location":"advanced_topics/volatile_outputs/#example","title":"Example","text":"<p>Example source files: advanced_topics/volatile_outputs/</p> <p>Create the following <code>plan.py</code>, with a single step that produces a trivially volatile output:</p> <pre><code>#!/usr/bin/env python\nfrom stepup.core.api import step\n\nstep(\"date &gt; date.txt\", vol=\"date.txt\")\n</code></pre> <p>Make the plan executable and run it as follows:</p> <pre><code>chmod +x plan.py\nstepup -n -w1\n</code></pre> <p>The file <code>date.txt</code> will contain the current time. You should get the following terminal output:</p> <pre><code>  DIRECTOR \u2502 Listening on /tmp/stepup-########/director\n  DIRECTOR \u2502 Launched worker 0\n     PHASE \u2502 run\n     START \u2502 ./plan.py\n   SUCCESS \u2502 ./plan.py\n     START \u2502 date &gt; date.txt\n   SUCCESS \u2502 date &gt; date.txt\n  WORKFLOW \u2502 Dumped to .stepup/workflow.mpk.xz\n  DIRECTOR \u2502 Stopping workers.\n  DIRECTOR \u2502 See you!\n</code></pre>"},{"location":"advanced_topics/volatile_outputs/#try-the-following","title":"Try the Following","text":"<ul> <li> <p>Remove the file <code>date.txt</code> and run StepUp again.   You will see that the step gets ignored:   StepUp does not care much about the state of volatile files.   It only keeps track of them, so they can be removed when needed.</p> </li> <li> <p>Manually recreate the file <code>date.txt</code> with some arbitrary contents,   and run StepUp.   Again, the step gets skipped because the contents of the   volatile <code>date.txt</code> are not considered when deciding if a step is outdated.</p> </li> <li> <p>Comment out the step in <code>plan.py</code> and run StepUp again.   Because the step is removed, the volatile output is also removed.</p> </li> </ul>"},{"location":"getting_started/automatic_cleaning/","title":"Automatic Cleaning","text":"<p>StepUp follows the same cleanup strategy as tup: If a step is removed or modified so that an output file is no longer created, StepUp will remove this output. This is also similar to Ninja\u2019s <code>cleandead</code> command, but it is not optional in StepUp.</p> <p>The main advantage of automatic cleaning is that it eliminates potential bugs and confusion related to old output files that are no longer relevant.</p>"},{"location":"getting_started/automatic_cleaning/#try-the-following","title":"Try the Following","text":"<p>To illustrate the automatic cleanup, take the files from the example Copy and mkdir and start StepUp in interactive mode. Make the following changes and rerun the affected steps after each point by pressing <code>r</code> in the terminal:</p> <ul> <li> <p>Change the directory <code>sub/</code> to <code>foo/</code> in <code>plan.py</code>.   Rerunning StepUp will not only create <code>foo/</code> and <code>foo/hello.txt</code>.   After completing all pending steps, <code>sub/</code> and <code>sub/hello.txt</code> are removed.</p> </li> <li> <p>Change all occurrences of <code>hello.txt</code> in <code>plan.py</code> to <code>hi.txt</code>.   Rerunning StepUp will not only create <code>hi.txt</code> and <code>foo/hi.txt</code>.   After completing all pending steps, <code>hello.txt</code> and <code>foo/hello.txt</code> are removed.</p> </li> <li> <p>Undo all changes and rerun StepUp again.   You should end up with the original outputs without any leftovers from the previous two steps.</p> </li> </ul>"},{"location":"getting_started/copy_mkdir/","title":"Copy and mkdir","text":"<p>Copying a file or making a directory can be planned using the <code>copy()</code> and <code>mkdir()</code> functions, respectively. These functions perform a few sanity checks and then create a step with the corresponding shell command.</p> <p>The example below will also be used in the Automatic Cleaning tutorial.</p>"},{"location":"getting_started/copy_mkdir/#example","title":"Example","text":"<p>Example source files: getting_started/copy_mkdir/</p> <p>Create a file <code>plan.py</code> with the following contents:</p> <pre><code>#!/usr/bin/env python\nfrom stepup.core.api import copy, mkdir, step\n\nstep(\"echo hello &gt; hello.txt\", out=\"hello.txt\")\nmkdir(\"sub/\")\ncopy(\"hello.txt\", \"sub/\")\n</code></pre> <p>Make it executable and run it with StepUp as follows:</p> <p><pre><code>chmod +x plan.py\nstepup -n -w1\n</code></pre> You should get the following output:</p> <pre><code>  DIRECTOR \u2502 Listening on /tmp/stepup-########/director\n  DIRECTOR \u2502 Launched worker 0\n  DIRECTOR \u2502 Launched worker 1\n     PHASE \u2502 run\n     START \u2502 ./plan.py\n     START \u2502 echo hello &gt; hello.txt\n   SUCCESS \u2502 echo hello &gt; hello.txt\n     START \u2502 mkdir -p sub/\n   SUCCESS \u2502 mkdir -p sub/\n   SUCCESS \u2502 ./plan.py\n     START \u2502 cp -aT hello.txt sub/hello.txt\n   SUCCESS \u2502 cp -aT hello.txt sub/hello.txt\n  WORKFLOW \u2502 Dumped to .stepup/workflow.mpk.xz\n  DIRECTOR \u2502 Stopping workers.\n  DIRECTOR \u2502 See you!\n</code></pre>"},{"location":"getting_started/copy_mkdir/#notes","title":"Notes","text":"<ul> <li> <p>StepUp expects all directories to end with a trailing delimiter (<code>/</code>).   In the example above, <code>mkdir</code> and <code>copy</code> have a <code>sub/</code> argument, which is a directory.   This imposes some clarity on the <code>plan.py</code> file and improves readability.</p> </li> <li> <p>The second argument of <code>copy</code> can also be a file.   For example, replace <code>sub/</code> with <code>sub/hello.txt</code>, and you will get exactly the same result.   You can also use a different filename, such as <code>sub/hi.txt</code>.</p> </li> </ul>"},{"location":"getting_started/dependencies/","title":"Dependencies","text":"<p>This tutorial demonstrates how StepUp tracks dependencies.</p>"},{"location":"getting_started/dependencies/#example","title":"Example","text":"<p>Example source files: getting_started/dependencies/</p> <p>The following <code>plan.py</code> defines two steps, with the second making use of the output from the first.</p> <pre><code>#!/usr/bin/env python\nfrom stepup.core.api import step\nfrom stepup.core.interact import graph\n\nstep(\"echo First line. &gt; ${out}; echo Second line. &gt;&gt; ${out}\", out=\"story.txt\")\nstep(\"grep First ${inp}\", inp=\"story.txt\")\ngraph(\"graph\")\n</code></pre> <p>The placeholders <code>${inp}</code> and <code>${out}</code> are replaced by the <code>inp</code> and <code>out</code> keyword arguments. (This happens early, before the steps are sent to the director process.)</p> <p>The <code>graph()</code> function writes the graph in a few formats, which are used for visualization below.</p> <p>Now run StepUp with two workers:</p> <pre><code>stepup -n -w2\n</code></pre> <p>You will see the following output:</p> <pre><code>  DIRECTOR \u2502 Listening on /tmp/stepup-########/director\n  DIRECTOR \u2502 Launched worker 0\n  DIRECTOR \u2502 Launched worker 1\n     PHASE \u2502 run\n     START \u2502 ./plan.py\n     START \u2502 echo First line. &gt; story.txt; echo Second line. &gt;&gt; story.txt\n   SUCCESS \u2502 echo First line. &gt; story.txt; echo Second line. &gt;&gt; story.txt\n     START \u2502 grep First story.txt\n   SUCCESS \u2502 grep First story.txt\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 Standard output \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nFirst line.\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   SUCCESS \u2502 ./plan.py\n  WORKFLOW \u2502 Dumped to .stepup/workflow.mpk.xz\n  DIRECTOR \u2502 Stopping workers.\n  DIRECTOR \u2502 See you!\n</code></pre> <p>Despite the fact that StepUp has launched two workers, it carries out the steps sequentially, because it knows that the output of the first step will be used by the second.</p> <p>Note, however, that the <code>echo</code> commands are already started before <code>./plan.py</code> has finished. This is the expected behavior: even without a complete overview of all the build steps, StepUp will start the steps for which it has sufficient information.</p>"},{"location":"getting_started/dependencies/#graphs","title":"Graphs","text":"<p>The <code>plan.py</code> script writes a few files to analyze and visualize the graphs StepUp uses internally. The file <code>graph.txt</code> is a detailed human-readable version of <code>.stepup/workflow.mpk.xz</code>:</p> <pre><code>root:\n             version = v1\n             creates   file:./\n             creates   file:plan.py\n             creates   step:./plan.py\n\nfile:plan.py\n                path = plan.py\n               state = STATIC\n          created by   root:\n            consumes   file:./\n            supplies   step:./plan.py\n\nfile:./\n                path = ./\n               state = STATIC\n          created by   root:\n            supplies   file:plan.py\n            supplies   file:story.txt\n            supplies   step:./plan.py\n            supplies   step:echo First line. &gt; story.txt; echo Second line. &gt;&gt; story.txt\n            supplies   step:grep First story.txt\n\nstep:./plan.py\n             workdir = ./\n             command = ./plan.py\n               state = RUNNING\n          created by   root:\n            consumes   file:./\n            consumes   file:plan.py\n             creates   step:echo First line. &gt; story.txt; echo Second line. &gt;&gt; story.txt\n             creates   step:grep First story.txt\n\nstep:echo First line. &gt; story.txt; echo Second line. &gt;&gt; story.txt\n             workdir = ./\n             command = echo First line. &gt; story.txt; echo Second line. &gt;&gt; story.txt\n               state = QUEUED\n          created by   step:./plan.py\n            consumes   file:./\n             creates   file:story.txt\n            supplies   file:story.txt\n\nfile:story.txt\n                path = story.txt\n               state = PENDING\n          created by   step:echo First line. &gt; story.txt; echo Second line. &gt;&gt; story.txt\n            consumes   file:./\n            consumes   step:echo First line. &gt; story.txt; echo Second line. &gt;&gt; story.txt\n            supplies   step:grep First story.txt\n\nstep:grep First story.txt\n             workdir = ./\n             command = grep First story.txt\n               state = PENDING\n          created by   step:./plan.py\n            consumes   file:./\n            consumes   file:story.txt\n</code></pre> <p>This text format may not always be the most convenient way to understand how StepUp connects all the steps and files. A more intuitive picture can be created with GraphViz using the <code>.dot</code> files as input. The figures below were created using the following commands:</p> <pre><code>dot -v graph_supplier.dot -Tsvg -o graph_supplier.svg\ndot -v graph_creator.dot -Tsvg -o graph_creator.svg\n</code></pre> <p>The workflow in StepUp consists of two graphs involving (a subset of) the same set of nodes: the supplier graph and the creator graph.</p>"},{"location":"getting_started/dependencies/#supplier-graph","title":"Supplier Graph","text":"<p>This graph shows how information is passed from one node to the next as the steps are executed.</p> <p></p> <p>This is an intuitive graph showing the execution flow. A similar graph is used by most other build tools. Not shown in this diagram are the directories, which StepUp treats in the same way as files.</p>"},{"location":"getting_started/dependencies/#creator-graph","title":"Creator Graph","text":"<p>This one shows who created each node in the graph:</p> <p></p> <p>This diagram is a little less intuitive and requires more explanation. Each node in StepUp\u2019s workflow is created by exactly one other node, except for the Root node, which is its own creator. (Arrow not shown.) In this example, there are three nodes that create other nodes:</p> <ul> <li> <p>The <code>root</code> node is an internal node controlled by StepUp.   Upon startup, StepUp creates <code>root</code> and a few other nodes by default:</p> <ul> <li>The initial <code>plan.py</code> file</li> <li>The initial <code>./plan.py</code> step (with working directory <code>./</code>.)</li> <li>The working directory <code>./</code> is created just like any other directory that is used.</li> <li>The <code>vaccum</code> node is a special node to hold all the nodes to be deleted.   In most visualizations it will not have any children as they are usually removed rather quickly.</li> </ul> </li> <li> <p>The <code>./plan.py</code> step creates two nodes, see the two <code>step()</code> function calls in the <code>plan.py</code> script above.</p> <ul> <li>The <code>grep</code> step.</li> <li>The <code>echo</code> step.</li> </ul> </li> <li> <p>The <code>echo</code> step creates one output file: <code>story.txt</code>.</p> </li> </ul> <p>This creator graph is used by StepUp to decide which steps to vacuum. For example, when <code>plan.py</code> is modified, all nodes created by the <code>./plan.py</code> step will be transferred to the <code>vacuum</code> node. If the new <code>plan.py</code> is recreated in the same way, its products are taken back from the <code>vacuum</code> node (including known file and step hashes). However, if the new <code>plan.py</code> defines different steps, vacuumed nodes that no longer exist in the new <code>plan.py</code> are effectively removed, after all steps have successfully completed. At this stage, any output files owned by vacuum will be removed from disk (if their last recorded hash still matches the hash of the file being deleted).</p>"},{"location":"getting_started/dependencies/#try-the-following","title":"Try the Following","text":"<ul> <li> <p>Run <code>stepup -n -w2</code> again. As expected, the steps are now skipped.</p> </li> <li> <p>Modify the <code>grep</code> command to select the second line and run <code>stepup -n -w2</code> again.   The <code>echo</code> commands are skipped as they have not changed.</p> </li> <li> <p>Change the order of the two steps in <code>plan.py</code> and run <code>stepup -n -w2</code>.   The step <code>./plan.py</code> is executed because the file has changed,   but the <code>echo</code> and <code>grep</code> steps are skipped.   This shows that <code>plan.py</code> is nothing but a plan, not its execution.   When it is executed, it sends the plan to the director process.</p> </li> </ul>"},{"location":"getting_started/distributed_plans/","title":"Distributed Plans","text":"<p>When your project grows, defining the entire workflow in a single <code>plan.py</code> file may become inconvenient. Especially when working with nested directories for different parts of the project, it may be convenient to distribute the workflow over multiple <code>plan.py</code> files.</p>"},{"location":"getting_started/distributed_plans/#example","title":"Example","text":"<p>Example source files: getting_started/distributed_plans/</p> <p>Create a simple example with a top-level <code>plan.py</code> as follows:</p> <pre><code>#!/usr/bin/env python\nfrom stepup.core.api import plan, static\n\nstatic(\"sub/\", \"sub/plan.py\", \"part1.txt\", \"sub/part2.txt\")\nplan(\"sub/\")\n</code></pre> <p>The top-level plan defines a few static files and then calls another plan in <code>sub/</code>. Create a file <code>sub/plan.py</code> as follows:</p> <pre><code>#!/usr/bin/env python\nfrom stepup.core.api import step\n\nstep(\"cat part2.txt\", inp=\"part2.txt\")\nstep(\"cat ../part1.txt\", inp=\"../part1.txt\")\n</code></pre> <p>Also create two files <code>part1.txt</code> and <code>sub/part2.txt</code> with a bit of text. Make both plans executable and run StepUp as follows:</p> <pre><code>chmod +x plan.py sub/plan.py\n</code></pre> <p>You will get the following output:</p> <pre><code>  DIRECTOR \u2502 Listening on /tmp/stepup-########/director\n  DIRECTOR \u2502 Launched worker 0\n     PHASE \u2502 run\n     START \u2502 ./plan.py\n   SUCCESS \u2502 ./plan.py\n     START \u2502 ./plan.py  # wd=sub/\n   SUCCESS \u2502 ./plan.py  # wd=sub/\n     START \u2502 cat part2.txt  # wd=sub/\n   SUCCESS \u2502 cat part2.txt  # wd=sub/\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 Standard output \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nThis is part 2.\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n     START \u2502 cat ../part1.txt  # wd=sub/\n   SUCCESS \u2502 cat ../part1.txt  # wd=sub/\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 Standard output \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nThis is part 1.\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n  WORKFLOW \u2502 Dumped to .stepup/workflow.mpk.xz\n  DIRECTOR \u2502 Stopping workers.\n  DIRECTOR \u2502 See you!\n</code></pre>"},{"location":"getting_started/distributed_plans/#practical-considerations","title":"Practical Considerations","text":"<ul> <li>The main benefit of having multiple <code>plan.py</code> files   is to improve the logical structure of your project.   It may also be helpful when a part of your <code>plan.py</code> is computationally demanding, in which   case it can be factored out so that it does not slow down the rest of the build.   However, ideally, the <code>plan.py</code> scripts execute quickly, leaving the hard work to other steps.</li> <li>When there are multiple <code>plan.py</code> files,   keep in mind that their order of execution cannot be relied upon.   They are executed in parallel, and their relative starting times depend   on factors unknown a priori, such as system load and number of workers.</li> </ul>"},{"location":"getting_started/first_step/","title":"First Step","text":"<p>The goal of the first tutorial is to introduce the basic usage of StepUp. For the sake of simplicity, a minimal workflow will be defined that does not achieve much.</p>"},{"location":"getting_started/first_step/#example","title":"Example","text":"<p>Example source files: getting_started/first_step/</p> <p>Create a file <code>plan.py</code> with the following contents:</p> <pre><code>#!/usr/bin/env python\nfrom stepup.core.api import step\n\nstep(\"echo Hello World\")\n</code></pre> <p>Make this file executable with <code>chmod +x plan.py</code>.</p> <ol> <li>The first line is required to have the plan executed by the Python interpreter.</li> <li>The second line imports the step() function from StepUp Core.    This module contains functions to communicate with the director process    of StepUp to define steps and other parts of the workflow.</li> <li>The last line defines a step that writes <code>Hello World</code> to the standard output.</li> </ol> <p>In the same directory, run:</p> <pre><code>stepup -n -w1\n</code></pre> <ul> <li>The option <code>-n</code> will execute the plan non-interactively, to keep things simple.</li> <li>The option <code>-w1</code> sets the maximum number of workers to 1, i.e. no parallel execution of steps.</li> </ul> <p>You should see the following output, with colors if your virtual terminal supports them:</p> <pre><code>  DIRECTOR \u2502 Listening on /tmp/stepup-########/director\n  DIRECTOR \u2502 Launched worker 0\n     PHASE \u2502 run\n     START \u2502 ./plan.py\n   SUCCESS \u2502 ./plan.py\n     START \u2502 echo Hello World\n   SUCCESS \u2502 echo Hello World\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 Standard output \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nHello World\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n  WORKFLOW \u2502 Dumped to .stepup/workflow.mpk.xz\n  DIRECTOR \u2502 Stopping workers.\n  DIRECTOR \u2502 See you!\n</code></pre> <p>Let\u2019s analyze the output:</p> <ul> <li>The first three lines are part of StepUp startup sequence.   The address <code>/tmp/stepup-########/director</code> is a Unix domain socket through which the director receives instructions from other processes to define the workflow.   (The hash signs represent random characters.)</li> <li>The <code>START</code> and <code>SUCCESS</code> lines are shown for steps executed by StepUp:<ul> <li>The step <code>./plan.py</code> is created by default and runs the script that you just created.</li> <li>Then the step <code>echo Hello World</code> is the step defined in <code>plan.py</code>.</li> </ul> </li> <li>When a step produces output, it is shown after the step has completed.</li> <li>When no more steps can be executed, StepUp wraps up by saving the worklow for future runs.</li> <li>Because of the <code>-n</code> option, StepUp immediately shuts down.</li> </ul> <p>Now repeat the execution of StepUp with:</p> <pre><code>stepup -n -w1\n</code></pre> <p>You will see a slightly different output:</p> <pre><code>  DIRECTOR \u2502 Listening on /tmp/stepup-########/director\n  WORKFLOW \u2502 Loaded from .stepup/workflow.mpk.xz\n  DIRECTOR \u2502 Launched worker 0\n     PHASE \u2502 run\n      SKIP \u2502 ./plan.py\n      SKIP \u2502 echo Hello World\n  WORKFLOW \u2502 Dumped to .stepup/workflow.mpk.xz\n  DIRECTOR \u2502 Stopping workers.\n  DIRECTOR \u2502 See you!\n</code></pre> <p>The steps are skipped (no longer executed) because their inputs have not changed. This is achieved by loading the file <code>.stepup/workflow.mpk.xz</code>, which contains the state of the most recent execution of all steps. StepUp determines if a step can be skipped by comparing a Blake2 hash including inputs, used environment variables and produced outputs. When you manually remove <code>.stepup/workflow.mpk.xz</code>, StepUp will not know anymore that it already executed some steps and runs all of them again.</p>"},{"location":"getting_started/first_step/#try-the-following","title":"Try the Following","text":"<ul> <li> <p>Change the arguments of the <code>echo</code> command in <code>plan.py</code> and run <code>stepup -n -w1</code> again.   As expected, StepUp detects the change and repeats the <code>plan.py</code> and <code>echo</code> steps.</p> </li> <li> <p>Normally, you would never run <code>./plan.py</code> directly as a normal Python script, i.e.,   without running it through <code>stepup</code>.   Try it anyway, just to see what happens.   The terminal output shows the commands that would normally be sent to the StepUp director   process when <code>plan.py</code> is executed by <code>stepup</code>.   You should get the following screen output.</p> <pre><code>\n</code></pre> <p>This output contains internal details of StepUp, which can be useful for debugging purposes.</p> </li> </ul>"},{"location":"getting_started/interactive_usage/","title":"Interactive Usage","text":"<p>All previous tutorials have run StepUp non-interactively, for the sake of simplicity. In practice, this is mainly useful when building projects in batch jobs, e.g., in the cloud. When working on a project, interactive usage is more efficient and convenient, but requires a little more explanation. (For this reason, most of the tutorials use the non-interactive option.)</p> <p>The Static Glob tutorial is a good example to demonstrate the interactive use of StepUp. Running StepUp as follows will not exit the terminal user interface:</p> <pre><code>stepup\n</code></pre> <p>In fact, running the <code>stepup</code> command without any arguments is the recommended way to run StepUp in most cases.</p> <p>After the line <code>PHASE \u2502 watch</code> appears, StepUp just waits for changes to the (static) files.</p>"},{"location":"getting_started/interactive_usage/#change-an-existing-file","title":"Change an Existing File","text":"<p>For example, while StepUp is still running, edit and save the file <code>src/foo.txt</code>. You will see at least the following:</p> <pre><code>    UPDATED \u2502 src/foo.txt\n</code></pre> <p>Now go back to the terminal and press the character <code>?</code> to display the supported keys with interactive commands:</p> <pre><code>\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 Keys \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\n   q = shutdown       d = drain        j = join   g = graph\n   f = from scratch   t = try replay   r = run\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n</code></pre> <p>Now press (lower case) <code>r</code> to run steps whose (indirect) inputs have changed. The new file <code>src/foo.txt</code> is copied again to <code>dst/foo.txt</code>, while other steps are ignored.</p> <p>The interactive commands are described in detail in the Interactive Command Reference.</p>"},{"location":"getting_started/interactive_usage/#add-a-new-file-that-matches-globsrctxt","title":"Add a New File That Matches <code>glob(\"src/*.txt\")</code>","text":"<p>Create a new file <code>src/spam.txt</code> with content of your choice while StepUp is still running. You will see at least the following:</p> <pre><code>    UPDATED \u2502 src/spam.txt\n</code></pre> <p>Now press (lower case) <code>r</code> again. The <code>./plan.py</code> step is executed again because a new file has appeared that matches a glob pattern used in <code>plan.py</code>. Running <code>./plan.py</code> again will, in turn, create a new step to copy <code>src/spam.txt</code> to <code>dst/spam.txt</code>.</p>"},{"location":"getting_started/interactive_usage/#screen-recording","title":"Screen Recording","text":"<p>The following recording shows the terminal output when starting StepUp from scratch with two workers, changing <code>src/foo.txt</code> and re-running, followed by adding <code>src/spam.txt</code> and re-running:</p>"},{"location":"getting_started/introduction/","title":"Introduction","text":"<p>The \u201cGetting Started\u201d section consists of a series of short tutorials. Each tutorial introduces a few concepts at a time to maintain a gentle learning curve. The following initial competencies are assumed:</p> <ul> <li>Basic Python programming.</li> <li>Working with a virtual terminal.</li> <li>Editing text files.</li> </ul> <p>Note that the examples in the tutorials are all small and use StepUp non-interactively. We believe this offers the best learning experience. However, StepUp really shines in more complex use cases and when used interactively. Once you know how StepUp works, you can impress yourself by effortlessly mastering the daunting complexity of your projects. :)</p>"},{"location":"getting_started/introduction/#tutorial-source-files","title":"Tutorial source files","text":"<p>Input files for each tutorial are stored in a corresponding subdirectory under <code>docs/getting_started/</code> within StepUp Core\u2019s source code. Each directory contains a script named <code>main.sh</code>, which simply runs the example in non-interactive mode, generating output that can be included in the documentation.</p>"},{"location":"getting_started/introduction/#stepup-architecture","title":"StepUp architecture","text":"<p>The tutorials use terminology defined in this small architecture overview. This overview summarizes the internals of StepUp, omitting many details for the sake of clarity. It provides just enough to give a basic understanding of its core concepts.</p>"},{"location":"getting_started/introduction/#workflow-graphs","title":"Workflow (graphs)","text":"<p>StepUp keeps track of what it needs to do and what it has already done in a workflow data structure. This workflow is represented by two direct acyclic graphs (DAGs), which comprise the same nodes.</p>"},{"location":"getting_started/introduction/#nodes","title":"Nodes","text":"<p>The nodes of the graph can be instances of the following main classes:</p> <ul> <li> <p>A <code>Step</code> defines a program that can be executed with all the information for a specific execution:   working directory, command, arguments, inputs, outputs, etc.   A step can also be in one of the following states:</p> <ul> <li><code>PENDING</code>: the step cannot yet be scheduled because some inputs have not been declared or built yet.</li> <li><code>QUEUED</code>: all inputs are available and the step is waiting to be executed.</li> <li><code>RUNNING</code>: the step is being executed by one of the workers.</li> <li><code>SUCCEEDED</code>: the step has been successfully completed.</li> <li><code>FAILED</code>: the subprocess exited with a non-zero exit code or some output files were not created.</li> </ul> </li> <li> <p>A <code>File</code> defines a path and a status, which can be any of the following:</p> <ul> <li><code>PENDING</code>: the file is the output of a step that still needs to be executed.</li> <li><code>BUILT</code>: the file is the output of a step that has been successfully executed.</li> <li><code>VOLATILE</code>: the file is (or can be) created by a step, but it is volatile.   It cannot be used as input, no hashes are computed for it.   These files are only registered so that they can be removed when appropriate.</li> <li><code>STATIC</code>: the file is written by you and can only be an input to a step.   (Note that step inputs can also be outputs of previous steps.)</li> <li><code>MISSING</code>: a static file that has gone missing.</li> </ul> </li> </ul> <p>There are also a few special nodes:</p> <ul> <li>The <code>Root</code> node is the top-level node, of which there is only one.</li> <li>The <code>Vacuum</code> node is also unique and collects other nodes that will be deleted soon.</li> <li>A <code>DeferredGlob</code> node contains a glob pattern of files that are made static when they are used as input.</li> </ul>"},{"location":"getting_started/introduction/#edges","title":"Edges","text":"<p>The StepUp workflow has two types of directed edges (arrows) connecting pairs of nodes. Each type of edge forms a graph with its own rules and logic.</p> <ul> <li> <p>A \u201csupplier \u279c consumer\u201d edge points from a node that provides something to a node that uses that something.   A few examples:</p> <ul> <li>If a step uses a file as its input, it is the consumer of that file.</li> <li>Likewise, a step is the supplier of its outputs</li> <li>Every file is the consumer of its parent directory.   (The only exceptions are <code>./</code> and <code>/</code>.)</li> <li>A step is the consumer of its working directory.</li> </ul> <p>The following diagram from the Dependencies tutorial illustrates this type of edge. (Directories are not included, steps are blue ellipses, files are grey rectangles.)</p> <p></p> <p>The build algorithm in StepUp will traverse upwards through this graph as it executes the steps, similarly to tup</p> </li> <li> <p>A \u201ccreator \u279c product\u201d edge is added whenever a new node is added to the workflow:   Each node must have one creator, but nodes can have multiple products.   Examples include:</p> <ul> <li>A step is the creator of its output files.</li> <li>If a <code>plan.py</code> (or other step) defines new steps, then the <code>./plan.py</code> step is the creator of   the new steps.</li> <li>If a step declares a static file, the step is the creator of the static file.</li> <li>The initial <code>plan.py</code> step has the <code>Root</code> node as its creator.</li> <li>Only the <code>Root</code> node is its own creator, making it the top-level node by construction.</li> <li>When nodes are slated for removal, the <code>Vacuum</code> node becomes their creator.</li> </ul> <p>The following graph from the Dependencies tutorial illustrates this type of edge. (Steps are blue ellipses, files are grey rectangles, root and vacuum are orange hexagons.)</p> <p></p> </li> </ul>"},{"location":"getting_started/introduction/#processes","title":"Processes","text":"<p>The following diagram illustrates how the components of StepUp interact. Legend:</p> <ul> <li>White boxes: your fingers and eyes</li> <li>Grey boxes: processes<ul> <li>The terminal user interface is the part of StepUp that you interact with when you run the <code>stepup</code> command.</li> <li>The director holds the workflow data structure and is responsible for running steps and watching for file changes.</li> <li>The worker processes execute steps and compute file and step hashes.</li> </ul> </li> <li>Grey arrows: standard input (interactively usage only) and standard output.</li> <li>Yellow arrows: startup of subprocesses</li> <li>Blue arrows: remote procedure calls to control the director and the workers</li> <li>Purple arrows: remote procedure calls for progress updates</li> <li>Green arrows: remote procedure calls to extend the workflow</li> </ul> <p></p>"},{"location":"getting_started/no_rules/","title":"No Rules","text":"<p>Most other built tools introduce the concept of a build rule, to specify how a common build step can be applied to different inputs. StepUp does not need to introduce the concept of a build rule because Python functions and loops already provide similar facilities.</p> <p>StepUp already comes with a few built-in rules defined int this way: <code>plan()</code>, <code>copy()</code>, <code>mkdir()</code>, <code>getenv()</code> and <code>script()</code>. Some of these were already discussed in the previous tutorials, and their source code offers some inspiration for writing your own.</p>"},{"location":"getting_started/no_rules/#example","title":"Example","text":"<p>Example source files: getting_started/no_rules/</p> <p>Here, we show a simple example of a custom rule to convert a text file to upper case with the <code>tr</code> command.</p> <p>Create the following <code>plan.py</code>:</p> <pre><code>#!/usr/bin/env python\nfrom stepup.core.api import glob, step\n\n\ndef upper(src, dst):\n    step(\"tr '[:lower:]' '[:upper:]' &lt; ${inp} &gt; ${out}\", inp=src, out=dst)\n\n\nfor path in glob(\"lower*.txt\"):\n    upper(path, \"upper\" + path[5:])\n</code></pre> <p>In addition, make two text files <code>lower1.txt</code> and <code>lower2.txt</code> with some random contents. Then make the plan executable and launch StepUp:</p> <pre><code>chmod +x plan.py\nstepup -n -w1\n</code></pre> <p>This will show the following output:</p> <pre><code>  DIRECTOR \u2502 Listening on /tmp/stepup-########/director\n  DIRECTOR \u2502 Launched worker 0\n     PHASE \u2502 run\n     START \u2502 ./plan.py\n   SUCCESS \u2502 ./plan.py\n     START \u2502 tr '[:lower:]' '[:upper:]' &lt; lower1.txt &gt; upper1.txt\n   SUCCESS \u2502 tr '[:lower:]' '[:upper:]' &lt; lower1.txt &gt; upper1.txt\n     START \u2502 tr '[:lower:]' '[:upper:]' &lt; lower2.txt &gt; upper2.txt\n   SUCCESS \u2502 tr '[:lower:]' '[:upper:]' &lt; lower2.txt &gt; upper2.txt\n  WORKFLOW \u2502 Dumped to .stepup/workflow.mpk.xz\n  DIRECTOR \u2502 Stopping workers.\n  DIRECTOR \u2502 See you!\n</code></pre>"},{"location":"getting_started/script_multiple/","title":"Script (Multiple Cases)","text":"<p>In the previous tutorial, the script protocol and driver were illustrated with a single use case of a script. The driver also handles scripts that can be executed with different combinations of inputs.</p>"},{"location":"getting_started/script_multiple/#multiple-cases-script-driver","title":"Multiple Cases Script Driver","text":"<p>A Python script using the driver for multiple cases has the following structure.</p> <pre><code>#!/usr/bin/env python\nfrom stepup.core.script import driver\n\ndef cases():\n    yield 1\n    yield 2\n\nCASE_FMT = \"foo{}\"\n\ndef case_info(case: int):\n    return {\n        \"inp\": ..., # a single input path or a list of input paths\n        \"out\": ..., # a single output path or a list of input paths\n        \"static\": ..., # declare a static file or a list of static files\n        \"stdout\": ..., # redirect the standard output to a file (StepUp 1.3.0)\n        \"stderr\": ..., # redirect the standard error to a file (StepUp 1.3.0)\n        \"just_any\": \"argument that you want to add\",\n    }\n\ndef run(inp, out, just_any):\n    ...\n\nif __name__ == \"__main__\":\n    driver()\n</code></pre> <p>The script has the following elements:</p> <ul> <li> <p>The generator <code>cases()</code> takes no arguments and yields cases that correspond to different ways of running the script.   Here, the cases are simple integers <code>1</code> and <code>2</code>, but richer data are also supported.   The <code>item</code> in <code>yield item</code> is translated into an <code>args</code> list and a <code>kwargs</code> dictionary as follows:</p> <ul> <li>If <code>item</code> is a dictionary: <code>args = []; kwargs = item</code></li> <li>Else if <code>item</code> is a tuple of a list and a dictionary: <code>args, kwargs = item</code></li> <li>Else if <code>item</code> is a list or tuple: <code>args = list(item); kwargs = {}</code></li> <li>Else: <code>args = [item]; kwargs = {}</code></li> </ul> </li> <li> <p>The cases will be represented by a string argument on the command line formatted with   <code>CASE_FMT.format(*args, **kwargs)</code>, where <code>args</code> and <code>kwargs</code> are derived from the iterates   from the <code>cases()</code> generator.   The formatted string must retain all information of <code>args</code> and <code>kwargs</code>,   so that they can be derived again from the formatted string   with the parse library.</p> <ul> <li>Here, the two string representations will be <code>foo1</code> and <code>foo2</code>.</li> <li>The corresponding steps will be <code>./script.py run foo1</code> and <code>./script.py run foo2</code></li> </ul> </li> <li> <p>The function <code>case_info()</code> is used to translate <code>args</code> and <code>kwargs</code> into a more detailed   planning of the run steps.   The returned dictionary is handled in the same way as that of the <code>info()</code> function in   the previous tutorial Script (Single Case).</p> </li> <li> <p>The function <code>run()</code> works in the same way as for the single case script driver.</p> </li> </ul>"},{"location":"getting_started/script_multiple/#example","title":"Example","text":"<p>Example source files: getting_started/script_multiple/</p> <p>To make the example more engaging, it leverages NumPy and Matplotlib. The same plotting function is applied to two datasets of hourly temperatures recorded at the airports of Brussels and Ostend in February 2024, downloaded from the ASOS network hosted by Iowa State University.</p> <p>Create a script <code>plan.py</code> that just calls the plotting script:</p> <pre><code>#!/usr/bin/env python\nfrom stepup.core.api import script, static\n\nstatic(\"plot.py\", \"ebbr.csv\", \"ebos.csv\", \"matplotlibrc\")\nscript(\"plot.py\")\n</code></pre> <p>The script <code>plot.py</code> uses the script driver with multiple cases:</p> <pre><code>#!/usr/bin/env python\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nimport numpy as np\nfrom matplotlib.dates import DateFormatter\n\nfrom stepup.core.script import driver\n\n\ndef cases():\n    yield \"ebbr\"\n    yield \"ebos\"\n\n\nCASE_FMT = \"plot_{}\"\n\n\ndef case_info(airport):\n    return {\n        \"inp\": [\"matplotlibrc\", f\"{airport}.csv\"],\n        \"out\": f\"plot_{airport}.png\",\n        \"airport\": airport,\n    }\n\n\ndef run(inp, out, airport):\n    mpl.rc_file(inp[0])\n    dtype = [(\"dt\", \"datetime64[s]\"), (\"tmpc\", \"f8\")]\n    data = np.loadtxt(inp[1], dtype=dtype, delimiter=\",\", skiprows=1).T\n    fig, ax = plt.subplots()\n    ax.plot(data[\"dt\"], data[\"tmpc\"])\n    ax.xaxis.set_major_formatter(DateFormatter(\"%d\"))\n    ax.set_xlabel(\"Day of the month February 2024\")\n    ax.set_xlim(data[\"dt\"][0], data[\"dt\"][-1])\n    ax.set_ylabel(\"Temperature [\u00b0C]\")\n    ax.set_title(f\"Airport {airport.upper()}\")\n    fig.savefig(out)\n\n\nif __name__ == \"__main__\":\n    driver()\n</code></pre> <p>Make the scripts executable and run StepUp to get the results:</p> <pre><code>chmod +x plan.py plot.py\nstepup -n -w1\n</code></pre> <p>You should see the following terminal output with the plan and run steps of the plotting script:</p> <pre><code>  DIRECTOR \u2502 Listening on /tmp/stepup-########/director\n  DIRECTOR \u2502 Launched worker 0\n     PHASE \u2502 run\n     START \u2502 ./plan.py\n   SUCCESS \u2502 ./plan.py\n     START \u2502 ./plot.py plan\n   SUCCESS \u2502 ./plot.py plan\n     START \u2502 ./plot.py run -- 'plot_ebbr'\n   SUCCESS \u2502 ./plot.py run -- 'plot_ebbr'\n     START \u2502 ./plot.py run -- 'plot_ebos'\n   SUCCESS \u2502 ./plot.py run -- 'plot_ebos'\n  WORKFLOW \u2502 Dumped to .stepup/workflow.mpk.xz\n  DIRECTOR \u2502 Stopping workers.\n  DIRECTOR \u2502 See you!\n</code></pre> <p>This produces the following figures:</p> <p> </p>"},{"location":"getting_started/script_multiple/#try-the-following","title":"Try the Following","text":"<ul> <li> <p>Download temperature data for the same month of an airport close to your home and format it   similarly to the <code>*.csv</code> already present.   Extend the <code>cases()</code> generator to also process your temperature data.</p> </li> <li> <p>It is common for iterates of <code>cases()</code> to be reused by multiple scripts.   One way to centralize this information is by defining a list <code>airports</code> in a <code>settings.py</code> module.   By locally importing this module in the <code>cases()</code> function,   the driver will make <code>settings.py</code> an input only of the planning step of the script:</p> <pre><code>def cases():\n    from settings import airports\n    yield from airports\n</code></pre> </li> <li> <p>For debugging purposes, it is sometimes useful to run just a single case of a script.   To facilitate this type of debugging, the script can be called with the <code>cases</code> argument.   When you run the following command:</p> <pre><code>./plot.py cases\n</code></pre> <p>you will get a list of different ways to execute the script\u2019s <code>run()</code> function:</p> <pre><code>./plot.py run -- 'plot_ebbr'\n./plot.py run -- 'plot_ebos'\n</code></pre> </li> </ul>"},{"location":"getting_started/script_single/","title":"Script (Single Case)","text":"<p>StepUp Core implements a simple script protocol for defining scripts that combine planning and execution in a single source file. This can be more convenient than putting a lot of detail in the <code>plan.py</code> file.</p>"},{"location":"getting_started/script_single/#script-protocol","title":"Script Protocol","text":"<p>The <code>script()</code> protocol itself is rather simple. The following line in <code>plan.py</code>:</p> <pre><code>script(\"executable\", \"sub\")\n</code></pre> <p>is roughly equivalent to:</p> <pre><code>step(\"./executable plan\", inp=\"executable\", workdir=\"sub\")\n</code></pre> <p>Note that the use of a subdirectory is not required. The <code>./executable plan</code> step is expected to define additional steps to actually run something useful with the executable. A common scenario is to plan a single <code>./executable run</code> step with appropriate inputs and outputs.</p> <p>When the <code>optional=True</code> keyword argument is given to the <code>script()</code> function, it executes <code>./executable plan --optional</code>. The script protocol requires that all run steps created by this planning step should then receive the <code>optional=True</code> keyword argument. Note that the plan step itself is never an optional step: It is always executed.</p>"},{"location":"getting_started/script_single/#script-driver","title":"Script driver","text":"<p>StepUp implements a <code>driver</code> function in the module <code>stepup.core.script</code> that greatly facilitates writing Python scripts that adhere to the script protocol.</p> <p>It can be used in two ways:</p> <ol> <li> <p>To run the executable for just one specific case of inputs and outputs (this tutorial).</p> </li> <li> <p>To run the same script with multiple combinations of inputs and outputs (next tutorial).</p> </li> </ol>"},{"location":"getting_started/script_single/#single-case-script-driver","title":"Single Case Script Driver","text":"<p>A Python script using the driver for a single case has the following structure.</p> <pre><code>#!/usr/bin/env python\nfrom stepup.core.script import driver\n\ndef info():\n    return {\n        \"inp\": ..., # a single input path or a list of input paths\n        \"out\": ..., # a single output path or a list of input paths\n        \"static\": ..., # declare a static file or a list of static files\n        \"stdout\": ..., # redirect the standard output to a file (StepUp 1.3.0)\n        \"stderr\": ..., # redirect the standard error to a file (StepUp 1.3.0)\n        \"just_any\": \"argument that you want to add\",\n    }\n\ndef run(inp, out, just_any):\n    ...\n\nif __name__ == \"__main__\":\n    driver()\n</code></pre> <ul> <li> <p>The <code>info</code> function provides the data necessary to plan the execution of the script.   It is executed when calling the script as <code>./script.py plan</code>.</p> <p>Note</p> <p>All dictionary items are optional. The <code>info</code> function can even return an empty dictionary. The keys <code>inp</code>, <code>out</code>, <code>static</code>, <code>stdout</code> and <code>stderr</code> affect the planning the run part, as explained in the comments above.</p> </li> <li> <p>The <code>run</code> function is called to perform the useful work and   is executed when the script is executed as <code>./script.py run</code>.</p> <p>Note</p> <p>The <code>run</code> function can have any argument defined in the dictionary returned by <code>info</code>, but it does not have to specify all of them. The argument list of <code>run</code> can contain fewer arguments (or even none at all).</p> </li> </ul>"},{"location":"getting_started/script_single/#example","title":"Example","text":"<p>Example source files: getting_started/script_single/</p> <p>Consider a script that has parameters defined in a config file <code>config.json</code>, which may be used by multiple script, e.g. for reasons of consistency. For this example, the configuration contains a number of steps and a frequency in arbitrary units, serialized in a JSON file:</p> <pre><code>{\n  \"nstep\": 100,\n  \"freq\": 0.1\n}\n</code></pre> <p>This file is used in a script <code>generate.py</code> as follows:</p> <pre><code>#!/usr/bin/env python\nimport json\n\nimport numpy as np\n\nfrom stepup.core.script import driver\n\n\ndef info():\n    return {\n        \"inp\": \"config.json\",\n        \"out\": [\"cos.npy\", \"sin.npy\"],\n    }\n\n\ndef run(inp, out):\n    with open(\"config.json\") as fh:\n        config = json.load(fh)\n    nstep = config[\"nstep\"]\n    freq = config[\"freq\"]\n    np.save(out[0], np.cos(2 * np.pi * freq * np.arange(nstep)))\n    np.save(out[1], np.sin(2 * np.pi * freq * np.arange(nstep)))\n\n\nif __name__ == \"__main__\":\n    driver()\n</code></pre> <p>Also, add the following <code>plan.py</code> file:</p> <pre><code>#!/usr/bin/env python\nfrom stepup.core.api import script, static\n\nstatic(\"generate.py\", \"config.json\")\nscript(\"generate.py\")\n</code></pre> <p>Finally, make the Python scripts executable and give StepUp a spin:</p> <pre><code>chmod +x generate.py plan.py\nstepup -n -w1\n</code></pre> <p>You should see the following output on screen:</p> <pre><code>  DIRECTOR \u2502 Listening on /tmp/stepup-########/director\n  DIRECTOR \u2502 Launched worker 0\n     PHASE \u2502 run\n     START \u2502 ./plan.py\n   SUCCESS \u2502 ./plan.py\n     START \u2502 ./generate.py plan\n   SUCCESS \u2502 ./generate.py plan\n     START \u2502 ./generate.py run\n   SUCCESS \u2502 ./generate.py run\n  WORKFLOW \u2502 Dumped to .stepup/workflow.mpk.xz\n  DIRECTOR \u2502 Stopping workers.\n  DIRECTOR \u2502 See you!\n</code></pre> <p>As expected, this creates two files: <code>cos.npy</code> and <code>sin.npy</code>.</p>"},{"location":"getting_started/script_single/#try-the-following","title":"Try the Following:","text":"<ul> <li> <p>Modify the file <code>config.json</code> and re-run StepUp.   The planning is skipped because the script itself did not change.   Only the run function is called to work with the updated <code>config.json</code>.</p> </li> <li> <p>Delete one of the outputs and rerun StepUp.   Again, the planning is skipped and the computation is repeated to recreate the missing output.</p> </li> <li> <p>Create a new module <code>utils.py</code> with a <code>compute</code> function to calculate the cosine and sine arrays   with parameters <code>nstep</code> and <code>freq</code>.   Import this module into <code>generate.py</code>, use it in <code>run</code> and re-run StepUp.   This will automatically make <code>utils.py</code> an input for the planning and running of <code>generate.py</code>.   Test this by making a small change to <code>utils.py</code> and re-running it.   (Note that local imports inside the <code>run</code> function will not be identified automatically and   are therefore not recommended.)</p> </li> </ul>"},{"location":"getting_started/static_files/","title":"Static Files","text":"<p>When steps use input files written by you, this must be explicitly stated in <code>plan.py</code> by declaring the human-written files as static files. This informs StepUp that it does not need to wait for other steps whose outputs are the required files.</p>"},{"location":"getting_started/static_files/#example","title":"Example","text":"<p>Example source files: getting_started/static_files/</p> <p>Create a file <code>limerick.txt</code> with the following contents:</p> <pre><code>A physicist named Erwin, quite shrewd,\nPut a feline in a box rather crude.\nWith a vial of doom,\nAnd radioactive gloom,\nThe poor cat's fate, both alive and subdued!\n</code></pre> <p>Also create the following <code>plan.py</code>:</p> <pre><code>#!/usr/bin/env python\nfrom stepup.core.api import static, step\n\nstatic(\"limerick.txt\")\nstep(\"nl ${inp} &gt; ${out}\", inp=\"limerick.txt\", out=\"numbered.txt\")\n</code></pre> <p>The <code>static()</code> function declares a static file, i.e. one that you have created.</p> <p>Make the plan executable and run it with StepUp as follows:</p> <p><pre><code>chmod +x plan.py\nstepup -n -w1\n</code></pre> You should get the following output:</p> <pre><code>  DIRECTOR \u2502 Listening on /tmp/stepup-########/director\n  DIRECTOR \u2502 Launched worker 0\n     PHASE \u2502 run\n     START \u2502 ./plan.py\n   SUCCESS \u2502 ./plan.py\n     START \u2502 nl limerick.txt &gt; numbered.txt\n   SUCCESS \u2502 nl limerick.txt &gt; numbered.txt\n  WORKFLOW \u2502 Dumped to .stepup/workflow.mpk.xz\n  DIRECTOR \u2502 Stopping workers.\n  DIRECTOR \u2502 See you!\n</code></pre> <p>As expected, StepUp does not wait for another step to create <code>limerick.txt</code> because the file is static. The file <code>numbered.txt</code> will contain a copy of the limerick with line numbers.</p>"},{"location":"getting_started/static_files/#try-the-following","title":"Try the Following","text":"<ul> <li> <p>Replace <code>gloom</code> by <code>boom</code> in <code>limerick.txt</code> and run <code>stepup -n -w1</code> again.   The line numbering is repeated, but the step <code>./plan.py</code> is skipped as it did not change.</p> </li> <li> <p>Change the order of <code>static</code> and <code>step</code> in <code>plan.py</code> and run <code>stepup -n -w1</code> again.   This has no apparent effect, but the step is only sent to the worker process after the director   is informed that the file <code>limerick.txt</code> is static.</p> </li> <li> <p>Comment out the <code>static</code> function call and run <code>stepup -n -w1</code> again.   StepUp will refuse to execute the line numbering step and will show a warning explaining why.</p> </li> </ul>"},{"location":"getting_started/static_glob/","title":"Static Glob","text":"<p>Explicitly declaring static files with the <code>static</code> function from the previous tutorial becomes tedious when dealing with many static files. To simplify matters, StepUp supports \u201cglob\u201d patterns, i.e., wildcards such as <code>*</code> and <code>?</code>.</p> <p>The <code>glob()</code> function is similar to <code>static()</code> and supports globbing, including some non-standard glob techniques discussed in the following tutorials.</p> <p>Here, only the basic usage of <code>glob()</code> is covered. In the following tutorial, the use of <code>glob</code> in conditionals is discussed. See Static Named Glob and Static Deferred Glob for more advanced use cases.</p>"},{"location":"getting_started/static_glob/#example","title":"Example","text":"<p>Example source files: getting_started/static_glob/</p> <p>Create a subdirectory <code>src/</code> with two files: <code>sub/foo.txt</code> and <code>sub/bar.txt</code>. Also, create a <code>plan.py</code> file with the following contents:</p> <pre><code>#!/usr/bin/env python\nfrom stepup.core.api import copy, glob, mkdir, static\n\nstatic(\"src/\")\nmkdir(\"dst/\")\nfor path_src in glob(\"src/*.txt\"):\n    copy(path_src, \"dst/\")\n</code></pre> <p>Make the plan executable and run it non-interactively:</p> <pre><code>chmod +x plan.py\nstepup -n -w1\n</code></pre> <p>This should produce the following output:</p> <pre><code>  DIRECTOR \u2502 Listening on /tmp/stepup-########/director\n  DIRECTOR \u2502 Launched worker 0\n     PHASE \u2502 run\n     START \u2502 ./plan.py\n   SUCCESS \u2502 ./plan.py\n     START \u2502 mkdir -p dst/\n   SUCCESS \u2502 mkdir -p dst/\n     START \u2502 cp -aT src/bar.txt dst/bar.txt\n   SUCCESS \u2502 cp -aT src/bar.txt dst/bar.txt\n     START \u2502 cp -aT src/foo.txt dst/foo.txt\n   SUCCESS \u2502 cp -aT src/foo.txt dst/foo.txt\n  WORKFLOW \u2502 Dumped to .stepup/workflow.mpk.xz\n  DIRECTOR \u2502 Stopping workers.\n  DIRECTOR \u2502 See you!\n</code></pre> <p>Note that all files found by the <code>glob</code> function are declared static in the workflow. Hence, they cannot be outputs of other steps. (This is not optional.)</p>"},{"location":"getting_started/static_glob/#try-the-following","title":"Try the Following","text":"<ul> <li> <p>Run StepUp again without making any changes.   You will notice that the <code>./plan.py</code> step is executed again despite not having changed it.   When StepUp starts from scratch, it has to assume that new files could have been added (since the last run) that match the glob pattern.   Hence, a step calling the <code>glob</code> function cannot be skipped.   (This can be avoided when using StepUp interactively. More on that later.)</p> </li> <li> <p>Add a file <code>src/egg.txt</code> and run StepUp again with the same arguments.   You will notice that known steps for <code>sub/foo.txt</code> and <code>sub/bar.txt</code> are skipped.   A new step is added for <code>src/egg.txt</code>.</p> </li> </ul>"},{"location":"getting_started/static_glob_conditional/","title":"Static Glob Conditional","text":"<p>The <code>glob()</code> function introduced in the previous tutorial also works in conditional expressions. This is particularly useful when not using any wildcards at all:</p> <pre><code>from stepup.core.api import glob\n\nif glob(\"dataset/\"):\n    # The dataset exists, is a directory and is now static.\n    # Steps for plan A.\n    ...\nelse:\n    # The directory dataset is not available.\n    # Steps for plan B.\n    ...\n</code></pre> <p>A similar conditional would not work with the <code>static()</code> function because it would raise an exception when the file does not exist.</p>"},{"location":"getting_started/static_glob_conditional/#example","title":"Example","text":"<p>Example source files: getting_started/static_glob_conditional/</p> <p>Let\u2019s simulate a scenario where <code>dataset/</code>, if it exists, is remote storage with a huge dataset. Plan A is to extract useful information from the dataset. However, there may be reasons why this is not always possible or desirable:</p> <ul> <li>Not all your collaborators may have access to this storage at all times.</li> <li>The extraction is slow or expensive otherwise.</li> </ul> <p>Plan B is to use the results of the extraction from a previous run and declare them as static files.</p> <p>Create the following <code>plan.py</code>:</p> <pre><code>#!/usr/bin/env python\nfrom stepup.core.api import glob, static, step\n\nif glob(\"dataset/\"):\n    static(\"dataset/bigfile.txt\", \"expensive.py\")\n    step(\n        \"./expensive.py\",\n        inp=[\"dataset/bigfile.txt\", \"expensive.py\"],\n        out=\"average.txt\",\n    )\nelse:\n    static(\"average.txt\")\n\nstep(\"cat average.txt\", inp=\"average.txt\")\n</code></pre> <p>For this example, the script <code>expensive.py</code> is not expensive at all. It just serves as an illustration of a more realistic scenario where this script may do some non-tritial work. In this example, <code>expensive.py</code> just computes the average of all numbers in <code>dataset/bigfile.txt</code> and writes out the result to <code>average.txt</code>:</p> <pre><code>#!/usr/bin/env python\n\ntotal = 0.0\ncount = 0\nwith open(\"dataset/bigfile.txt\") as fh:\n    for line in fh:\n        total += float(line)\n        count += 1\n\nwith open(\"average.txt\", \"w\") as fh:\n    print(f\"{total / count:f}\", file=fh)\n</code></pre> <p>Now put some values in <code>dataset/bigfile.txt</code>, e.g.:</p> <pre><code>1.2\n2.3\n7.9\n1.8\n-0.3\n</code></pre> <p>To run the example, make the scripts executable and fire up StepUp in non-interactive mode:</p> <pre><code>chmod +x expensive.py plan.py\nstepup -n -w1\n</code></pre> <p>You should get the following output:</p> <pre><code>  DIRECTOR \u2502 Listening on /tmp/stepup-########/director\n  DIRECTOR \u2502 Launched worker 0\n     PHASE \u2502 run\n     START \u2502 ./plan.py\n   SUCCESS \u2502 ./plan.py\n     START \u2502 ./expensive.py\n   SUCCESS \u2502 ./expensive.py\n     START \u2502 cat average.txt\n   SUCCESS \u2502 cat average.txt\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 Standard output \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n2.580000\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n  WORKFLOW \u2502 Dumped to .stepup/workflow.mpk.xz\n  DIRECTOR \u2502 Stopping workers.\n  DIRECTOR \u2502 See you!\n</code></pre> <p>Now, simulate the situation where the dataset is absent by renaming the directory:</p> <pre><code>mv dataset tmp\nstepup -n -w1\n</code></pre> <p>The new output reveals that the dataset is completely ignored while the file <code>average.txt</code> is still used:</p> <pre><code>  DIRECTOR \u2502 Listening on /tmp/stepup-########/director\n  WORKFLOW \u2502 Loaded from .stepup/workflow.mpk.xz\n  DIRECTOR \u2502 Launched worker 0\n     PHASE \u2502 run\n     START \u2502 ./plan.py\n   SUCCESS \u2502 ./plan.py\n      SKIP \u2502 cat average.txt\n  WORKFLOW \u2502 Dumped to .stepup/workflow.mpk.xz\n  DIRECTOR \u2502 Stopping workers.\n  DIRECTOR \u2502 See you!\n</code></pre> <p>Since the file <code>average.txt</code> did not change, the step <code>cat average.txt</code> is skipped.</p>"},{"location":"getting_started/static_glob_conditional/#practical-considerations","title":"Practical Considerations","text":"<ul> <li> <p>For simplity\u2019s sake, the example involves few calculations.   In a more realistic setting, the step <code>cat average.txt</code> is replaced by several scripts that   make graphs of the information extracted from the large dataset.   Tweaking these graphs for clarity usually takes some iterations,   for which access to the large dataset is not necessary.</p> </li> <li> <p>A StepUp project practically always resides in a Git repository.   While the files extracted from the large dataset can be reproduced easily,   it may still be relevant to commit them into the Git repository:</p> <ul> <li> <p>Not all collaborators may have access to the dataset,   but you still want them to be able to reproduce the workflow.</p> </li> <li> <p>In the long run, the large dataset might be removed because it is too big and old to keep around.   The extracted data then become a relevant and compact subset that can be easily stored for longer periods.</p> </li> </ul> </li> </ul>"},{"location":"reference/interactive/","title":"Interactive Command Reference","text":"<p>By default, StepUp runs in interactive mode. When pressing a key on the keyboard, it responds by executing a corresponding command. If the key is not associated with any command, the following help message appears:</p> <pre><code>\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 Keys \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\n   q = shutdown       d = drain        j = join   g = graph\n   f = from scratch   t = try replay   r = run\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n</code></pre> <p>These commands are defined as follows:</p> <ul> <li><code>q = shutdown</code>:   StepUp waits for the workers to complete their current job and will not start new jobs.   As soon as all workers are idle, StepUp exits.</li> <li><code>d = drain</code>:   StepUp waits for the workers to complete their current job and will not start new jobs.   As soon as all workers are idle, StepUp transitions into the watch phase.</li> <li><code>j = join</code>:   StepUp continues running jobs until no new jobs can be found to send to the workers.   As soon as all workers are idle, StepUp terminates.</li> <li><code>g = graph</code>:   Writes out the workflow graph in text format to a file named <code>graph.txt</code>.   (This human-readable file contains most of the information from <code>.stepup/workflow.mp.xz</code>)</li> <li><code>f = from scratch</code>:   Discards all hashes and reruns all steps.   No attempts are made to skip steps, and everything is executed from scratch.</li> <li><code>t = try replay</code>:   Checks the hash of each step and skips it if no changes were detected.   Otherwise, run the step.   (Normally, this command is not needed.)</li> <li><code>r = run</code>:   Runs steps that are affected by file changes registered during the watch phase.</li> </ul>"},{"location":"reference/stepup.core.api/","title":"stepup.core.api","text":"<p>You can expect reasonable stability of the API documented here over the future releases of StepUp. (No hard promises, since StepUp is still very young.) Other parts of StepUp, not documented here, may undergo larger changes and are not intended to be API stable.</p>"},{"location":"reference/stepup.core.api/#basic-api","title":"Basic API","text":""},{"location":"reference/stepup.core.api/#stepup.core.api.static","title":"<code>stepup.core.api.static(*paths)</code>","text":"<p>Declare static paths.</p> <p>Parameters:</p> <ul> <li> <code>*paths</code>               (<code>str | Iterable[str]</code>, default:                   <code>()</code> )           \u2013            <p>One or more static paths (files or directories), relative to the current working directory. Arguments may also be lists of strings.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>When a file does not exist or there is an error with the trailing separator.</p> </li> </ul> Notes <p>Environment variables in the <code>paths</code> will be substituted directly and amend the current step\u2019s env_vars list, if needed. These substitutions will ignore changes to <code>os.environ</code> made in the calling script.</p> Source code in <code>stepup/core/api.py</code> <pre><code>def static(*paths: str | Iterable[str]):\n    \"\"\"Declare static paths.\n\n    Parameters\n    ----------\n    *paths\n        One or more static paths (files or directories),\n        relative to the current working directory.\n        Arguments may also be lists of strings.\n\n    Raises\n    ------\n    ValueError\n        When a file does not exist or there is an error with the trailing separator.\n\n    Notes\n    -----\n    Environment variables in the `paths` will be\n    substituted directly and amend the current step's env_vars list, if needed.\n    These substitutions will ignore changes to `os.environ` made in the calling script.\n    \"\"\"\n    # Turn paths into one big list.\n    _paths = paths\n    paths = []\n    for path in _paths:\n        if isinstance(path, str):\n            paths.append(path)\n        elif isinstance(path, Iterable):\n            paths.extend(path)\n    del _paths\n\n    # Avoid empty RPC calls.\n    if len(paths) &gt; 0:\n        # Perform env var substitutions.\n        with subs_env_vars() as subs:\n            su_paths = [subs(path) for path in paths]\n        # Sanity checks\n        check_inp_paths(su_paths)\n        # Translate paths to directory working dir and make RPC call\n        tr_paths = sorted(translate(path) for path in su_paths)\n        RPC_CLIENT.call.static(_get_step_key(), tr_paths)\n</code></pre>"},{"location":"reference/stepup.core.api/#stepup.core.api.glob","title":"<code>stepup.core.api.glob(*patterns, _required=False, _defer=False, **subs)</code>","text":"<p>Declare static paths through pattern matching.</p> <p>Parameters:</p> <ul> <li> <code>*patterns</code>               (<code>str</code>, default:                   <code>()</code> )           \u2013            <p>One or more patterns for static files or directories, relative to the current working directory. The patterns may contain (named) wildcards and one may specify the pattern for each named wildcard with the keyword arguments.</p> </li> <li> <code>_required</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>When True, an error will be raised when there are no matches.</p> </li> <li> <code>_defer</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>When True, static files are not added yet. Instead, the glob is installed in the workflow as a deferred glob. As soon as any file is needed as input and matches the pattern, it will be made static. This is not compatible with <code>_required=True</code>. Named wildcards are not supported in deferred globs.</p> </li> <li> <code>**subs</code>               (<code>str</code>, default:                   <code>{}</code> )           \u2013            <p>When using named wildcards, they will match the pattern <code>*</code> by default. Through the subs argument each name can be associated with another glob pattern. Names starting with underscores are not allowed.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>FileNotFoundError</code>             \u2013            <p>when no matches were found and _required is True.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ngm</code>           \u2013            <p>An <code>NGlobMulti</code> instance holding all the matched (combinations of) paths. This object acts as an iterator. When named wildcards are used, it iterates over <code>NGlobMatch</code> instances. When using only anonymous wildcards, it iterates over unique paths. It also features <code>ngm.matches()</code> and <code>ngm.files()</code> iterators, with which the type of iterator can be overruled. Finally, one may also use ngm in conditional expressions: It evaluates to True if and only if it contains some matches.</p> <p><code>None</code> is returned when <code>_defer=True</code>.</p> </li> </ul> Notes <p>The combinatorics allow one to construct nested loops easily in one call. For unrelated patterns, it may be more efficient to use separate <code>glob</code> calls.</p> <p>Environment variables in the <code>patterns</code> will be substituted directly and amend the current step\u2019s env_vars list, if needed. These substitutions will ignore changes to <code>os.environ</code> made in the calling script.</p> Source code in <code>stepup/core/api.py</code> <pre><code>def glob(\n    *patterns: str, _required: bool = False, _defer: bool = False, **subs: str\n) -&gt; NGlobMulti | None:\n    \"\"\"Declare static paths through pattern matching.\n\n    Parameters\n    ----------\n    *patterns\n        One or more patterns for static files or directories,\n        relative to the current working directory.\n        The patterns may contain (named) wildcards and one\n        may specify the pattern for each named wildcard with\n        the keyword arguments.\n    _required\n        When True, an error will be raised when there are no matches.\n    _defer\n        When True, static files are not added yet.\n        Instead, the glob is installed in the workflow as a deferred glob.\n        As soon as any file is needed as input and matches the pattern,\n        it will be made static.\n        This is not compatible with `_required=True`.\n        Named wildcards are not supported in deferred globs.\n    **subs\n        When using named wildcards, they will match the pattern `*` by default.\n        Through the subs argument each name can be associated with another glob pattern.\n        Names starting with underscores are not allowed.\n\n    Raises\n    ------\n    FileNotFoundError\n        when no matches were found and _required is True.\n\n    Returns\n    -------\n    ngm\n        An `NGlobMulti` instance holding all the matched (combinations of) paths.\n        This object acts as an iterator.\n        When named wildcards are used, it iterates over `NGlobMatch` instances.\n        When using only anonymous wildcards, it iterates over unique paths.\n        It also features `ngm.matches()` and `ngm.files()` iterators,\n        with which the type of iterator can be overruled.\n        Finally, one may also use ngm in conditional expressions:\n        It evaluates to True if and only if it contains some matches.\n\n        `None` is returned when `_defer=True`.\n\n    Notes\n    -----\n    The combinatorics allow one to construct nested loops easily in one call.\n    For unrelated patterns, it may be more efficient to use separate `glob` calls.\n\n    Environment variables in the `patterns` will be\n    substituted directly and amend the current step's env_vars list, if needed.\n    These substitutions will ignore changes to `os.environ` made in the calling script.\n    \"\"\"\n    if len(patterns) == 0:\n        raise ValueError(\"At least one path is required for glob.\")\n    if any(name.startswith(\"_\") for name in subs):\n        raise ValueError(\"Substitutions cannot have names starting with underscores.\")\n\n    # Substitute environment variables\n    with subs_env_vars() as subs_path:\n        su_patterns = [subs_path(pattern) for pattern in patterns]\n\n    if _defer:\n        if _required:\n            raise ValueError(\"Combination of options not supported: _defer=True, _required=True\")\n        if len(subs) &gt; 0:\n            raise ValueError(\"Named wildcards are not supported in deferred globs.\")\n        tr_patterns = [translate(su_pattern) for su_pattern in su_patterns]\n        tr_inp_check = RPC_CLIENT.call.defer(_get_step_key(), tr_patterns)\n        if tr_inp_check is not None:\n            # Verify that matches of the deferred glob exist.\n            lo_inp_check = [translate_back(inp_path) for inp_path in tr_inp_check]\n            check_inp_paths(lo_inp_check)\n            RPC_CLIENT.call.confirm_deferred(tr_inp_check)\n        return None\n\n    # Collect all matches\n    nglob_multi = NGlobMulti.from_patterns(su_patterns, subs)\n    nglob_multi.glob()\n    if _required and len(nglob_multi.results) == 0:\n        raise FileNotFoundError(\"Could not find any matching paths on the filesystem.\")\n\n    # Send static paths\n    static_paths = nglob_multi.files()\n    if len(static_paths) &gt; 0:\n        check_inp_paths(static_paths)\n        tr_static_paths = [translate(static_path) for static_path in static_paths]\n        RPC_CLIENT.call.static(_get_step_key(), tr_static_paths)\n\n    # Unstructure the nglob_multi and translate all paths before sending it to the director.\n    lookup = lookupdict()\n    ngm_data = nglob_multi.unstructure(lookup)\n    tr_strings = [str(translate(path)) for path in lookup.get_list()]\n    RPC_CLIENT.call.nglob(_get_step_key(), ngm_data, tr_strings)\n    return nglob_multi\n</code></pre>"},{"location":"reference/stepup.core.api/#stepup.core.api.StepInfo","title":"<code>stepup.core.api.StepInfo</code>","text":"<p>The <code>step()</code> function returns an instance of this class to help defining follow-up steps.</p> <p>This object will not contain any information that is amended while the step is executed. It only holds information known at the time the step is defined.</p> Source code in <code>stepup/core/api.py</code> <pre><code>@attrs.define\nclass StepInfo:\n    \"\"\"The `step()` function returns an instance of this class to help defining follow-up steps.\n\n    This object will not contain any information that is amended while the step is executed.\n    It only holds information known at the time the step is defined.\n    \"\"\"\n\n    key: str = attrs.field()\n    \"\"\"The key of the step in StepUp's workflow.\"\"\"\n\n    inp: list[Path] = attrs.field()\n    \"\"\"List of input paths of the step.\"\"\"\n\n    env: list[str] = attrs.field()\n    \"\"\"List of environment values used by the step.\"\"\"\n\n    out: list[Path] = attrs.field()\n    \"\"\"List of output paths of the step.\"\"\"\n\n    vol: list[Path] = attrs.field()\n    \"\"\"List of volatile output paths of the step.\"\"\"\n\n    def filter_inp(self, *patterns: str, **subs: str):\n        \"\"\"Return an `NGlobMulti` object with matching results from `self.inp`.\"\"\"\n        ngm = NGlobMulti.from_patterns(patterns, subs)\n        ngm.extend(self.inp)\n        return ngm\n\n    def filter_out(self, *patterns: str, **subs: str):\n        \"\"\"Return an `NGlobMulti` object with matching results from `self.out`.\"\"\"\n        ngm = NGlobMulti.from_patterns(patterns, subs)\n        ngm.extend(self.out)\n        return ngm\n\n    def filter_vol(self, *patterns: str, **subs: str):\n        \"\"\"Return an `NGlobMulti` object with matching results from `self.val`.\"\"\"\n        ngm = NGlobMulti.from_patterns(patterns, subs)\n        ngm.extend(self.vol)\n        return ngm\n</code></pre>"},{"location":"reference/stepup.core.api/#stepup.core.api.StepInfo.env","title":"<code>env = attrs.field()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>List of environment values used by the step.</p>"},{"location":"reference/stepup.core.api/#stepup.core.api.StepInfo.inp","title":"<code>inp = attrs.field()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>List of input paths of the step.</p>"},{"location":"reference/stepup.core.api/#stepup.core.api.StepInfo.key","title":"<code>key = attrs.field()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The key of the step in StepUp\u2019s workflow.</p>"},{"location":"reference/stepup.core.api/#stepup.core.api.StepInfo.out","title":"<code>out = attrs.field()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>List of output paths of the step.</p>"},{"location":"reference/stepup.core.api/#stepup.core.api.StepInfo.vol","title":"<code>vol = attrs.field()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>List of volatile output paths of the step.</p>"},{"location":"reference/stepup.core.api/#stepup.core.api.StepInfo.filter_inp","title":"<code>filter_inp(*patterns, **subs)</code>","text":"<p>Return an <code>NGlobMulti</code> object with matching results from <code>self.inp</code>.</p> Source code in <code>stepup/core/api.py</code> <pre><code>def filter_inp(self, *patterns: str, **subs: str):\n    \"\"\"Return an `NGlobMulti` object with matching results from `self.inp`.\"\"\"\n    ngm = NGlobMulti.from_patterns(patterns, subs)\n    ngm.extend(self.inp)\n    return ngm\n</code></pre>"},{"location":"reference/stepup.core.api/#stepup.core.api.StepInfo.filter_out","title":"<code>filter_out(*patterns, **subs)</code>","text":"<p>Return an <code>NGlobMulti</code> object with matching results from <code>self.out</code>.</p> Source code in <code>stepup/core/api.py</code> <pre><code>def filter_out(self, *patterns: str, **subs: str):\n    \"\"\"Return an `NGlobMulti` object with matching results from `self.out`.\"\"\"\n    ngm = NGlobMulti.from_patterns(patterns, subs)\n    ngm.extend(self.out)\n    return ngm\n</code></pre>"},{"location":"reference/stepup.core.api/#stepup.core.api.StepInfo.filter_vol","title":"<code>filter_vol(*patterns, **subs)</code>","text":"<p>Return an <code>NGlobMulti</code> object with matching results from <code>self.val</code>.</p> Source code in <code>stepup/core/api.py</code> <pre><code>def filter_vol(self, *patterns: str, **subs: str):\n    \"\"\"Return an `NGlobMulti` object with matching results from `self.val`.\"\"\"\n    ngm = NGlobMulti.from_patterns(patterns, subs)\n    ngm.extend(self.vol)\n    return ngm\n</code></pre>"},{"location":"reference/stepup.core.api/#stepup.core.api.step","title":"<code>stepup.core.api.step(command, *, inp=(), env=(), out=(), vol=(), workdir='./', optional=False, pool=None, block=False)</code>","text":"<p>Add a step to the build graph.</p> <p>Parameters:</p> <ul> <li> <code>command</code>               (<code>str</code>)           \u2013            <p>Command to execute (in the working directory of the director).</p> </li> <li> <code>inp</code>               (<code>Collection[str] | str</code>, default:                   <code>()</code> )           \u2013            <p>File(s) required by the step, relative to <code>workdir</code>. Can be files or directories (trailing slash).</p> </li> <li> <code>env</code>               (<code>Collection[str] | str</code>, default:                   <code>()</code> )           \u2013            <p>Environment variable(s) to which the step is sensitive. If they change, or when they are (un)defined, the step digest will change, such that the step cannot be skipped.</p> </li> <li> <code>out</code>               (<code>Collection[str] | str</code>, default:                   <code>()</code> )           \u2013            <p>File(s) created by the step, relative to <code>workdir</code>. These can be files or directories (trailing slash).</p> </li> <li> <code>vol</code>               (<code>Collection[str] | str</code>, default:                   <code>()</code> )           \u2013            <p>Volatile file(s) created by the step, relative to <code>workdir</code>. These can be files only.</p> </li> <li> <code>workdir</code>               (<code>str</code>, default:                   <code>'./'</code> )           \u2013            <p>The directory where the command must be executed. A trailing slash is added when not present. (The default is the current directory.)</p> </li> <li> <code>optional</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>When set to True, the step is only executed when required by other mandatory steps.</p> </li> <li> <code>pool</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Restricts execution to a pool, optional.</p> </li> <li> <code>block</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>When set to True, the step will always remain pending. This can be used to temporarily prevent part of the workflow from executing.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>step_info</code>           \u2013            <p>Holds relevant information of the step, useful for defining follow-up steps.</p> </li> </ul> Notes <p>Environment variables in the <code>workdir</code>, <code>inp</code>, <code>out</code> and <code>vol</code> paths and workdir will be substituted directly and amend the current step\u2019s env_vars list, if needed. These substitutions will ignore changes to <code>os.environ</code> made in the calling script.</p> <p>Before sending the step to the director the variables <code>${inp}</code>, <code>${out}</code> and <code>${vol}</code> in the command are substituted by white-space concatenated list of <code>inp</code>, <code>out</code> and <code>vol</code>, respectively. Relative paths in <code>inp</code>, <code>out</code> and <code>env</code> are interpreted in the current working directory. Before substitution, they are rewritten as paths relative to the workdir. (Amended inputs and outputs are never substituted this way because they are yet unknown.)</p> Source code in <code>stepup/core/api.py</code> <pre><code>def step(\n    command: str,\n    *,\n    inp: Collection[str] | str = (),\n    env: Collection[str] | str = (),\n    out: Collection[str] | str = (),\n    vol: Collection[str] | str = (),\n    workdir: str = \"./\",\n    optional: bool = False,\n    pool: str | None = None,\n    block: bool = False,\n) -&gt; StepInfo:\n    \"\"\"Add a step to the build graph.\n\n    Parameters\n    ----------\n    command\n        Command to execute (in the working directory of the director).\n    inp\n        File(s) required by the step, relative to `workdir`.\n        Can be files or directories (trailing slash).\n    env\n        Environment variable(s) to which the step is sensitive.\n        If they change, or when they are (un)defined, the step digest will change,\n        such that the step cannot be skipped.\n    out\n        File(s) created by the step, relative to `workdir`.\n        These can be files or directories (trailing slash).\n    vol\n        Volatile file(s) created by the step, relative to `workdir`.\n        These can be files only.\n    workdir\n        The directory where the command must be executed.\n        A trailing slash is added when not present.\n        (The default is the current directory.)\n    optional\n        When set to True, the step is only executed when required by other mandatory steps.\n    pool\n        Restricts execution to a pool, optional.\n    block\n        When set to True, the step will always remain pending.\n        This can be used to temporarily prevent part of the workflow from executing.\n\n    Returns\n    -------\n    step_info\n        Holds relevant information of the step, useful for defining follow-up steps.\n\n    Notes\n    -----\n    Environment variables in the `workdir`, `inp`, `out` and `vol` paths and workdir will be\n    substituted directly and amend the current step's env_vars list, if needed.\n    These substitutions will ignore changes to `os.environ` made in the calling script.\n\n    Before sending the step to the director the variables `${inp}`, `${out}` and `${vol}`\n    in the command are substituted by white-space concatenated list of `inp`, `out` and\n    `vol`, respectively.\n    Relative paths in `inp`, `out` and `env` are interpreted in the current working directory.\n    Before substitution, they are rewritten as paths relative to the workdir.\n    (Amended inputs and outputs are never substituted this way because they are yet unknown.)\n    \"\"\"\n    # Pre-process the arguments for the Director process.\n    inp_paths = _str_to_list(inp)\n    env_vars = _str_to_list(env)\n    out_paths = _str_to_list(out)\n    vol_paths = _str_to_list(vol)\n    if not workdir.endswith(\"/\"):\n        workdir = f\"{workdir}/\"\n    amended_env_vars = set()\n    with subs_env_vars() as subs:\n        su_inp_paths = [subs(inp_path) for inp_path in inp_paths]\n        su_out_paths = [subs(out_path) for out_path in out_paths]\n        su_vol_paths = [subs(vol_path) for vol_path in vol_paths]\n        su_workdir = subs(workdir)\n    amend(env=sorted(amended_env_vars))\n    tr_inp_paths = [translate(inp_path, su_workdir) for inp_path in su_inp_paths]\n    tr_out_paths = [translate(out_path, su_workdir) for out_path in su_out_paths]\n    tr_vol_paths = [translate(vol_path, su_workdir) for vol_path in su_vol_paths]\n    tr_workdir = translate(su_workdir)\n    # Substitute paths that are translated back to the current directory.\n    command = CaseSensitiveTemplate(command).safe_substitute(\n        inp=\" \".join(su_inp_paths),\n        out=\" \".join(su_out_paths),\n        vol=\" \".join(su_vol_paths),\n    )\n\n    # Look for inputs that match deferred globs and check their existence\n    # before making them static.\n    tr_inp_check = RPC_CLIENT.call.filter_deferred(tr_inp_paths)\n    if tr_inp_check is not None:\n        lo_inp_check = [translate_back(inp_path, su_workdir) for inp_path in tr_inp_check]\n        check_inp_paths(lo_inp_check)\n        RPC_CLIENT.call.confirm_deferred(tr_inp_check)\n\n    # Finally create the step.\n    step_key = RPC_CLIENT.call.step(\n        _get_step_key(),\n        command,\n        tr_inp_paths,\n        env_vars,\n        tr_out_paths,\n        tr_vol_paths,\n        tr_workdir,\n        optional,\n        pool,\n        block,\n    )\n\n    # Return a StepInfo instance to facilitate the definition of follow-up steps\n    return StepInfo(step_key, su_inp_paths, env_vars, su_out_paths, su_vol_paths)\n</code></pre>"},{"location":"reference/stepup.core.api/#stepup.core.api.pool","title":"<code>stepup.core.api.pool(name, size)</code>","text":"<p>Define a pool with given size or change an existing pool size.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The name of the pool.</p> </li> <li> <code>size</code>               (<code>int</code>)           \u2013            <p>The pool size.</p> </li> </ul> Source code in <code>stepup/core/api.py</code> <pre><code>def pool(name: str, size: int):\n    \"\"\"Define a pool with given size or change an existing pool size.\n\n    Parameters\n    ----------\n    name\n        The name of the pool.\n    size\n        The pool size.\n    \"\"\"\n    RPC_CLIENT.call.pool(_get_step_key(), name, size)\n</code></pre>"},{"location":"reference/stepup.core.api/#stepup.core.api.amend","title":"<code>stepup.core.api.amend(*, inp=(), env=(), out=(), vol=())</code>","text":"<p>Specify additional inputs and outputs from within a running step.</p> <p>Parameters:</p> <ul> <li> <code>inp</code>               (<code>Collection[str] | str</code>, default:                   <code>()</code> )           \u2013            <p>Files required by the step. Can be files or directories (trailing slash).</p> </li> <li> <code>env</code>               (<code>Collection[str] | str</code>, default:                   <code>()</code> )           \u2013            <p>Environment variables to which the step is sensitive. If the change, or when they are (un)defined, the step digest will change, such that the step is not skipped when these variables change.</p> </li> <li> <code>out</code>               (<code>Collection[str] | str</code>, default:                   <code>()</code> )           \u2013            <p>Files created by the step. Can be files or directories (trailing slash).</p> </li> <li> <code>vol</code>               (<code>Collection[str] | str</code>, default:                   <code>()</code> )           \u2013            <p>Volatile files created by the step. Can be files or directories (trailing slash).</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>keep_going</code>           \u2013            <p>True when the additional inputs are available and the step can safely use them. False otherwise, meaning the step can exit early and will be rescheduled later.</p> </li> </ul> Notes <p>Environment variables in the <code>inp</code>, <code>out</code> and <code>vol</code> paths are substituted in the same way as in the <code>step()</code> function. The used variables are added to the env_vars argument.</p> Source code in <code>stepup/core/api.py</code> <pre><code>def amend(\n    *,\n    inp: Collection[str] | str = (),\n    env: Collection[str] | str = (),\n    out: Collection[str] | str = (),\n    vol: Collection[str] | str = (),\n) -&gt; bool:\n    \"\"\"Specify additional inputs and outputs from within a running step.\n\n    Parameters\n    ----------\n    inp\n        Files required by the step.\n        Can be files or directories (trailing slash).\n    env\n        Environment variables to which the step is sensitive.\n        If the change, or when they are (un)defined, the step digest will change,\n        such that the step is not skipped when these variables change.\n    out\n        Files created by the step.\n        Can be files or directories (trailing slash).\n    vol\n        Volatile files created by the step.\n        Can be files or directories (trailing slash).\n\n    Returns\n    -------\n    keep_going\n        True when the additional inputs are available and the step can safely use them.\n        False otherwise, meaning the step can exit early and will be rescheduled later.\n\n    Notes\n    -----\n    Environment variables in the `inp`, `out` and `vol` paths are substituted in the same way\n    as in the `step()` function. The used variables are added to the env_vars argument.\n\n    \"\"\"\n    # Pre-process the arguments for the Director process.\n    inp_paths = _str_to_list(inp)\n    env_vars = _str_to_list(env)\n    out_paths = _str_to_list(out)\n    vol_paths = _str_to_list(vol)\n    if all(len(collection) == 0 for collection in [inp_paths, env_vars, out_paths, vol_paths]):\n        return True\n    env_vars = set(env_vars)\n    with subs_env_vars() as subs:\n        su_inp_paths = [subs(inp_path) for inp_path in inp_paths]\n        tr_inp_paths = [translate(inp_path) for inp_path in su_inp_paths]\n        tr_out_paths = [translate(subs(out_path)) for out_path in out_paths]\n        tr_vol_paths = [translate(subs(vol_path)) for vol_path in vol_paths]\n\n    # Look for inputs that match deferred globs and check their existence\n    # before making them static.\n    tr_inp_check = RPC_CLIENT.call.filter_deferred(tr_inp_paths)\n    if tr_inp_check is not None:\n        lo_inp_check = [translate_back(inp_path) for inp_path in tr_inp_check]\n        check_inp_paths(lo_inp_check)\n        RPC_CLIENT.call.confirm_deferred(tr_inp_check)\n\n    # Finally, amend for real.\n    keep_going = RPC_CLIENT.call.amend(\n        _get_step_key(),\n        tr_inp_paths,\n        sorted(env_vars),\n        tr_out_paths,\n        tr_vol_paths,\n    )\n    if keep_going is None:\n        # When the RPC_CLIENT is a dummy, it always returns None.\n        # In this case, we're assuming the users calls the script\n        # manually and made sure all the required files are present.\n        keep_going = True\n    if keep_going:\n        # Double check that all inputs are indeed present.\n        check_inp_paths(su_inp_paths)\n    return keep_going\n</code></pre>"},{"location":"reference/stepup.core.api/#composite-api","title":"Composite API","text":""},{"location":"reference/stepup.core.api/#stepup.core.api.plan","title":"<code>stepup.core.api.plan(subdir, block=False)</code>","text":"<p>Run a <code>plan.py</code> script in a subdirectory.</p> <p>Parameters:</p> <ul> <li> <code>subdir</code>               (<code>str</code>)           \u2013            <p>The subdirectory in which another <code>plan.py</code> script can be found. The file must be executable and have <code>#!/usr/bin/env python</code> as its first line. A trailing slash is added when not present.</p> </li> <li> <code>block</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>When True, the step will always remain pending.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>step_info</code>           \u2013            <p>Holds relevant information of the step, useful for defining follow-up steps.</p> </li> </ul> Source code in <code>stepup/core/api.py</code> <pre><code>def plan(subdir: str, block: bool = False) -&gt; StepInfo:\n    \"\"\"Run a `plan.py` script in a subdirectory.\n\n    Parameters\n    ----------\n    subdir\n        The subdirectory in which another `plan.py` script can be found.\n        The file must be executable and have `#!/usr/bin/env python` as its first line.\n        A trailing slash is added when not present.\n    block\n        When True, the step will always remain pending.\n\n    Returns\n    -------\n    step_info\n        Holds relevant information of the step, useful for defining follow-up steps.\n    \"\"\"\n    with subs_env_vars() as subs:\n        subdir = subs(subdir)\n    return step(\"./plan.py\", inp=\"plan.py\", workdir=subdir, block=block)\n</code></pre>"},{"location":"reference/stepup.core.api/#stepup.core.api.copy","title":"<code>stepup.core.api.copy(src, dst, optional=False, block=False)</code>","text":"<p>Add a step that copies a file.</p> <p>Parameters:</p> <ul> <li> <code>src</code>               (<code>str</code>)           \u2013            <p>This must be a file. Environment variables are substituted.</p> </li> <li> <code>dst</code>               (<code>str</code>)           \u2013            <p>This can be a file or a directory. Environment variables are substituted. If it is a directory, it must have a trailing slash.</p> </li> <li> <code>optional</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>When True, the file is only copied when needed as input for another step.</p> </li> <li> <code>block</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>When True, the step will always remain pending.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>step_info</code>           \u2013            <p>Holds relevant information of the step, useful for defining follow-up steps.</p> </li> </ul> Source code in <code>stepup/core/api.py</code> <pre><code>def copy(src: str, dst: str, optional: bool = False, block: bool = False) -&gt; StepInfo:\n    \"\"\"Add a step that copies a file.\n\n    Parameters\n    ----------\n    src\n        This must be a file. Environment variables are substituted.\n    dst\n        This can be a file or a directory. Environment variables are substituted.\n        If it is a directory, it must have a trailing slash.\n    optional\n        When True, the file is only copied when needed as input for another step.\n    block\n        When True, the step will always remain pending.\n\n    Returns\n    -------\n    step_info\n        Holds relevant information of the step, useful for defining follow-up steps.\n    \"\"\"\n    amended_env_vars = set()\n    with subs_env_vars() as subs:\n        src = subs(src)\n        dst = subs(dst)\n    path_src = mynormpath(src)\n    path_dst = make_path_out(src, dst, None)\n    amend(env=amended_env_vars)\n    return step(\"cp -aT ${inp} ${out}\", inp=path_src, out=path_dst, optional=optional, block=block)\n</code></pre>"},{"location":"reference/stepup.core.api/#stepup.core.api.mkdir","title":"<code>stepup.core.api.mkdir(dirname, optional=False, block=False)</code>","text":"<p>Make a directory.</p> <p>Parameters:</p> <ul> <li> <code>dirname</code>               (<code>str</code>)           \u2013            <p>The director to create. A trailing slash is added when not present. Environment variables are substituted.</p> </li> <li> <code>optional</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>When True, the directory is only created when needed by other steps.</p> </li> <li> <code>block</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>When True, the step will always remain pending.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>step_info</code>           \u2013            <p>Holds relevant information of the step, useful for defining follow-up steps.</p> </li> </ul> Source code in <code>stepup/core/api.py</code> <pre><code>def mkdir(dirname: str, optional: bool = False, block: bool = False) -&gt; StepInfo:\n    \"\"\"Make a directory.\n\n    Parameters\n    ----------\n    dirname\n        The director to create.\n        A trailing slash is added when not present.\n        Environment variables are substituted.\n    optional\n        When True, the directory is only created when needed by other steps.\n    block\n        When True, the step will always remain pending.\n\n    Returns\n    -------\n    step_info\n        Holds relevant information of the step, useful for defining follow-up steps.\n    \"\"\"\n    amended_env_vars = set()\n    with subs_env_vars() as subs:\n        dirname = subs(dirname)\n    if not dirname.endswith(\"/\"):\n        dirname += \"/\"\n    dirname = mynormpath(dirname)\n    amend(env=amended_env_vars)\n    return step(f\"mkdir -p {dirname}\", out=dirname, optional=optional, block=block)\n</code></pre>"},{"location":"reference/stepup.core.api/#stepup.core.api.getenv","title":"<code>stepup.core.api.getenv(name, default=None, is_path=False)</code>","text":"<p>Get an environment variable and amend the current step with the variable name.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The name of the environment variable, which is retrieved with <code>os.getenv</code>.</p> </li> <li> <code>default</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The value to return when the environment variable is unset.</p> </li> <li> <code>is_path</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Set to True if the variable taken from the environment is assumed to be a path. Shell variables are substituted (once) in such paths. If the path is relative, it is assumed to be relative to the StepUp\u2019s working directory. In this case, translated to become usable from the working directory of the caller.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>value</code>           \u2013            <p>The value of the environment variable. If <code>is_path</code> is set to <code>True</code>, this is a <code>Path</code> instance. Otherwise, the result is a string.</p> </li> </ul> Source code in <code>stepup/core/api.py</code> <pre><code>def getenv(name: str, default: str | None = None, is_path: bool = False) -&gt; str | Path:\n    \"\"\"Get an environment variable and amend the current step with the variable name.\n\n    Parameters\n    ----------\n    name\n        The name of the environment variable, which is retrieved with `os.getenv`.\n    default\n        The value to return when the environment variable is unset.\n    is_path\n        Set to True if the variable taken from the environment is assumed to be a path.\n        Shell variables are substituted (once) in such paths.\n        If the path is relative, it is assumed to be relative to the StepUp's working directory.\n        In this case, translated to become usable from the working directory of the caller.\n\n    Returns\n    -------\n    value\n        The value of the environment variable.\n        If `is_path` is set to `True`, this is a `Path` instance.\n        Otherwise, the result is a string.\n    \"\"\"\n    value = os.getenv(name, default)\n    names = [name]\n    if is_path:\n        value = Path(value)\n        if not value.isabs():\n            value = mynormpath(os.getenv(\"ROOT\", \".\") / Path(value))\n            names.append(\"ROOT\")\n        with subs_env_vars() as subs:\n            value = subs(value)\n    amend(env=names)\n    return value\n</code></pre>"},{"location":"reference/stepup.core.api/#stepup.core.api.script","title":"<code>stepup.core.api.script(executable, workdir='./', optional=False, block=False)</code>","text":"<p>Run the executable with a single argument <code>plan</code> in a working directory.</p> <p>Parameters:</p> <ul> <li> <code>executable</code>               (<code>str</code>)           \u2013            <p>The path of a local executable that will be called with the argument <code>plan</code>. The file must be executable.</p> </li> <li> <code>workdir</code>               (<code>str</code>, default:                   <code>'./'</code> )           \u2013            <p>The subdirectory in which the script is to be executed. A trailing slash is added when not present. The path of the executable is assumed to be relative to this directory.</p> </li> <li> <code>optional</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>When True, the steps planned by the executable are made optional. The planning itself is never optional.</p> </li> <li> <code>block</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>When True, the planning will always remain pending.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>step_info</code>           \u2013            <p>Holds relevant information of the step, useful for defining follow-up steps.</p> </li> </ul> Source code in <code>stepup/core/api.py</code> <pre><code>def script(\n    executable: str, workdir: str = \"./\", optional: bool = False, block: bool = False\n) -&gt; StepInfo:\n    \"\"\"Run the executable with a single argument `plan` in a working directory.\n\n    Parameters\n    ----------\n    executable\n        The path of a local executable that will be called with the argument `plan`.\n        The file must be executable.\n    workdir\n        The subdirectory in which the script is to be executed.\n        A trailing slash is added when not present.\n        The path of the executable is assumed to be relative to this directory.\n    optional\n        When True, the steps planned by the executable are made optional.\n        The planning itself is never optional.\n    block\n        When True, the planning will always remain pending.\n\n    Returns\n    -------\n    step_info\n        Holds relevant information of the step, useful for defining follow-up steps.\n    \"\"\"\n    with subs_env_vars() as subs:\n        executable = subs(executable)\n        workdir = subs(workdir)\n    command = f\"./{executable} plan\"\n    if optional:\n        command += \" --optional\"\n    return step(command, inp=[executable], workdir=workdir, block=block)\n</code></pre>"},{"location":"reference/stepup.core.api/#utilities-for-api-extensions","title":"Utilities for API extensions","text":""},{"location":"reference/stepup.core.api/#stepup.core.api.subs_env_vars","title":"<code>stepup.core.api.subs_env_vars()</code>","text":"<p>A context manager for substituting environment variables and tracking the used variables.</p> <p>The context manager yields a function, <code>subs</code>, which takes a string with variables and returns the substituted form. All used variables are recorded and sent to the director with <code>amend(env=...)</code>. For example:</p> <pre><code>with subs_env_vars() as subs:\n    path_inp = subs(path_inp)\n    path_out = subs(path_out)\n</code></pre> <p>This function may be used in other API functions to substitute environment variables in all relevant paths.</p> Source code in <code>stepup/core/api.py</code> <pre><code>@contextlib.contextmanager\ndef subs_env_vars() -&gt; Iterator[Callable[[str | None], str | None]]:\n    \"\"\"A context manager for substituting environment variables and tracking the used variables.\n\n    The context manager yields a function, `subs`, which takes a string with variables and\n    returns the substituted form.\n    All used variables are recorded and sent to the director with `amend(env=...)`.\n    For example:\n\n    ```python\n    with subs_env_vars() as subs:\n        path_inp = subs(path_inp)\n        path_out = subs(path_out)\n    ```\n\n    This function may be used in other API functions to substitute environment variables in\n    all relevant paths.\n    \"\"\"\n    env_vars = set()\n\n    def subs(path: str | None) -&gt; Path | None:\n        if path is None:\n            return None\n        template = CaseSensitiveTemplate(path)\n        if not template.is_valid():\n            raise ValueError(\"The path contains invalid shell variable identifiers.\")\n        mapping = {}\n        for name in template.get_identifiers():\n            if name.startswith(\"*\"):\n                mapping[name] = f\"${{{name}}}\"\n            else:\n                value = os.getenv(name)\n                if value is None:\n                    raise ValueError(f\"Undefined shell variable: {name}\")\n                mapping[name] = value\n                env_vars.add(name)\n        result = path if len(mapping) == 0 else template.substitute(mapping)\n        return mynormpath(result)\n\n    yield subs\n    amend(env=env_vars)\n</code></pre>"},{"location":"reference/stepup.core.api/#stepup.core.api.translate","title":"<code>stepup.core.api.translate(path, workdir='.')</code>","text":"<p>Normalize the path and, if relative, make it relative to <code>ROOT</code>.</p> <p>If the environment variable <code>HERE</code> is not set, it is derived from <code>STEPUP_ROOT</code> if set.</p> <p>Parameters:</p> <ul> <li> <code>path</code>               (<code>str</code>)           \u2013            <p>The path to translate. If relative, it assumed to be relative to the working directory.</p> </li> <li> <code>workdir</code>               (<code>str</code>, default:                   <code>'.'</code> )           \u2013            <p>The work directory. If relative, it is assumed to be relative to <code>HERE</code></p> </li> </ul> <p>Returns:</p> <ul> <li> <code>translated_path</code>           \u2013            <p>A path that can be interpreted in the working directory of the StepUp director.</p> </li> </ul> Source code in <code>stepup/core/api.py</code> <pre><code>def translate(path: str, workdir: str = \".\") -&gt; Path:\n    \"\"\"Normalize the path and, if relative, make it relative to `ROOT`.\n\n    If the environment variable `HERE` is not set, it is derived from `STEPUP_ROOT` if set.\n\n    Parameters\n    ----------\n    path\n        The path to translate. If relative, it assumed to be relative to the working directory.\n    workdir\n        The work directory. If relative, it is assumed to be relative to `HERE`\n\n    Returns\n    -------\n    translated_path\n        A path that can be interpreted in the working directory of the StepUp director.\n    \"\"\"\n    path = mynormpath(path)\n    if not path.isabs():\n        workdir = mynormpath(workdir)\n        if workdir.isabs():\n            path = workdir / path\n        else:\n            stepup_root = Path(os.getenv(\"STEPUP_ROOT\", \"./\"))\n            here = os.getenv(\"HERE\")\n            if here is None:\n                here = myrelpath(\"./\", stepup_root)\n            path = myrelpath(mynormpath(stepup_root / here / workdir / path), stepup_root)\n    return path\n</code></pre>"},{"location":"reference/stepup.core.interact/","title":"stepup.core.interact","text":"<p>Application Programming Interface (API) for interactive use of the director process.</p> <p>Most of these functions are used for writing tests. They can also be employed to create keyboard shortcuts within your IDE.</p> <p>For example, one may bind the following command to an IDE\u2019s keyboard shortcut:</p> <pre><code>STEPUP_DIRECTOR_SOCKET=$(python -c \"import stepup.core.director; print(stepup.core.director.get_socket())\") python -c 'from stepup.core.interact import run; run()'\n</code></pre> <p>This command must be executed in the top-level directory where a <code>stepup</code> command is running in interactive mode.</p> <p>You can better understand how the above example works by breaking it down into two parts:</p> <ul> <li>The command <code>python -c \"import stepup.core.director; print(stepup.core.director.get_socket())\"</code>   prints the path to the socket where the director listens for instructions.   This is a randomized temporary path that is created when <code>stepup</code> is started.   (For technical reasons, this path cannot be deterministic   and must be read from <code>.stepup/log/director</code>.)   By wrapping this command in <code>STEPUP_DIRECTOR_SOCKET=$(...)</code>, the path will be   assigned to an environment variable <code>STEPUP_DIRECTOR_SOCKET</code>,   which will be available for the second Python call.</li> <li>The part <code>python -c 'from stepup.core.interact import run; run()'</code>   has the same effect as pressing <code>r</code> in the terminal where StepUp is running.   The variable <code>STEPUP_DIRECTOR_SOCKET</code> tells which instance of StepUp to interact with.   When StepUp runs <code>plan.py</code> scripts, they also use this environment variable   to interact with the director process.   As these are subprocesses of the director process, the variable is set automatically,   so you don\u2019t need to set it.   This is only needed if processes other than subprocesses need to interact with the director,   as in this example.</li> </ul>"},{"location":"reference/stepup.core.interact/#stepup.core.interact--configuration-of-a-task-in-vscode","title":"Configuration of a Task in VSCode","text":"<p>You can define a Custom Task in VSCode to rerun StepUp with the following <code>tasks.json</code> file:</p> <pre><code>{\n  \"version\": \"2.0.0\",\n  \"tasks\": [\n    {\n      \"label\": \"StepUp run\",\n      \"type\": \"shell\",\n      \"command\": \"STEPUP_DIRECTOR_SOCKET=$(python -c 'import stepup.core.director; print(stepup.core.director.get_socket())') python -c 'from stepup.core.interact import run; run()'\",\n      \"options\": {\"cwd\": \"./path/from/project/root/to/stepup/root/\"},\n      \"presentation\": {\n        \"echo\": true,\n        \"reveal\": \"silent\",\n        \"focus\": false,\n        \"panel\": \"shared\",\n        \"showReuseMessage\": false,\n        \"clear\": true\n      }\n    }\n  ]\n}\n</code></pre> <p>The following <code>keybindings.json</code> file will bind <code>ctrl+d</code> to run the task:</p> <pre><code>[\n  {\n    \"key\": \"ctrl+d\",\n    \"command\": \"workbench.action.tasks.runTask\",\n    \"args\": \"StepUp run\"\n  }\n]\n</code></pre>"},{"location":"reference/stepup.core.interact/#stepup.core.interact.cleanup","title":"<code>cleanup(*paths)</code>","text":"<p>Remove paths (if they are outputs), recursively removing all consumer files and directories.</p> <p>Parameters:</p> <ul> <li> <code>paths</code>               (<code>str</code>, default:                   <code>()</code> )           \u2013            <p>A list of paths to consider for removal. Variable substitutions are not supported.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>numf</code>           \u2013            <p>The number of files effectively removed.</p> </li> <li> <code>numd</code>           \u2013            <p>The number of directories effectively removed.</p> </li> </ul> Source code in <code>stepup/core/interact.py</code> <pre><code>def cleanup(*paths: str) -&gt; tuple[int, int]:\n    \"\"\"Remove paths (if they are outputs), recursively removing all consumer files and directories.\n\n    Parameters\n    ----------\n    paths\n        A list of paths to consider for removal.\n        Variable substitutions are not supported.\n\n    Returns\n    -------\n    numf\n        The number of files effectively removed.\n    numd\n        The number of directories effectively removed.\n    \"\"\"\n    # Translate paths to directory working dir and make RPC call\n    tr_paths = sorted(translate(path) for path in paths)\n    return RPC_CLIENT.call.cleanup(tr_paths)\n</code></pre>"},{"location":"reference/stepup.core.interact/#stepup.core.interact.graph","title":"<code>graph(prefix)</code>","text":"<p>Write the workflow graph files in text and dot formats.</p> Source code in <code>stepup/core/interact.py</code> <pre><code>def graph(prefix: str):\n    \"\"\"Write the workflow graph files in text and dot formats.\"\"\"\n    return RPC_CLIENT.call.graph(prefix)\n</code></pre>"},{"location":"reference/stepup.core.interact/#stepup.core.interact.join","title":"<code>join()</code>","text":"<p>Wait for the runner to become idle and stop the director.</p> <p>This is the same as <code>wait()</code> followed by <code>shutdown()</code>.</p> Source code in <code>stepup/core/interact.py</code> <pre><code>def join():\n    \"\"\"Wait for the runner to become idle and stop the director.\n\n    This is the same as `wait()` followed by `shutdown()`.\"\"\"\n    RPC_CLIENT.call.join(_rpc_timeout=None)\n</code></pre>"},{"location":"reference/stepup.core.interact/#stepup.core.interact.run","title":"<code>run()</code>","text":"<p>Exit the watch phase and start running steps whose inputs have changed.</p> Source code in <code>stepup/core/interact.py</code> <pre><code>def run():\n    \"\"\"Exit the watch phase and start running steps whose inputs have changed.\"\"\"\n    RPC_CLIENT.call.run()\n</code></pre>"},{"location":"reference/stepup.core.interact/#stepup.core.interact.wait","title":"<code>wait()</code>","text":"<p>Block until the runner has become idle.</p> Source code in <code>stepup/core/interact.py</code> <pre><code>def wait():\n    \"\"\"Block until the runner has become idle.\"\"\"\n    RPC_CLIENT.call.wait(_rpc_timeout=None)\n</code></pre>"},{"location":"reference/stepup.core.interact/#stepup.core.interact.watch_delete","title":"<code>watch_delete(path)</code>","text":"<p>Block until the watcher has observed the deletion of the file.</p> Source code in <code>stepup/core/interact.py</code> <pre><code>def watch_delete(path: str):\n    \"\"\"Block until the watcher has observed the deletion of the file.\"\"\"\n    RPC_CLIENT.call.watch_delete(path, _rpc_timeout=None)\n</code></pre>"},{"location":"reference/stepup.core.interact/#stepup.core.interact.watch_update","title":"<code>watch_update(path)</code>","text":"<p>Block until the watcher has observed an update of the file.</p> Source code in <code>stepup/core/interact.py</code> <pre><code>def watch_update(path: str):\n    \"\"\"Block until the watcher has observed an update of the file.\"\"\"\n    RPC_CLIENT.call.watch_update(path, _rpc_timeout=None)\n</code></pre>"},{"location":"reference/stepup.core.nglob/","title":"stepup.core.nglob","text":"<p>Glob with named back-reference support.</p> <p>Named glob (NGlob) patterns are an advanced form of pattern matching that supports back referencing of previously matched substrings.</p> <p>It has the following use cases:</p> <ul> <li> <p>Single named wildcard:     By default, the wildcard <code>${*name}</code> is a placeholder for any string.     One may also specify a pattern for <code>${*name}</code> through optional arguments.     For example:</p> <pre><code>ngs = NGlobSingle(\"feedback_${*idx}.md\", idx=\"[0-9][0-9][0-9]\")\nngs.glob()\nprint(ngs.results)\n</code></pre> <p>Unlike ordinary wildcards, named wildcards never match an empty string.</p> </li> <li> <p>Consistency within one pattern:     If a pattern uses the same named globs multiple times,     the matching substring must also be consistent.     For example:</p> <pre><code>ngs = NGlobSingle(\"archive_${*idx}/feedback_${*idx}.md\", idx=\"[0-9][0-9][0-9]\")\nngs.glob()\nprint(ngs.results)\n</code></pre> <p>These would match:</p> <ul> <li><code>archive_042/feedback_042.md</code></li> <li><code>archive_777/feedback_777.md</code></li> </ul> <p>This won\u2019t match:</p> <ul> <li><code>archive_042/feedback_777.md</code></li> </ul> </li> <li> <p>Consistency across multiple patterns:     One can define multiple patterns and enforce consistency between their matches.     For example:</p> <pre><code>ngm = NGlobMulti(\"feedback_${*idx}.md\", \"report_${*idx}.pdf\", idx=\"[0-9][0-9][0-9]\")\nngm.glob()\nprint(ngm.results)\n</code></pre> <p>This will produce pairs of matches (provided the files are present). For example, the following would match:</p> <ul> <li><code>feedback_001.md</code> with <code>report_001.pdf</code></li> <li><code>feedback_123.md</code> with <code>report_123.pdf</code></li> </ul> <p>The following won\u2019t be in the results, despite the fact that the files exist:</p> <ul> <li><code>feedback_001.md</code> with <code>report_123.pdf</code></li> </ul> </li> <li> <p>Conventional (recursive) glob wildcards are also allowed and are called \u201canonymous wildcards\u201d   to clarify the distinction from named wildcards.</p> </li> </ul>"},{"location":"reference/stepup.core.nglob/#stepup.core.nglob.NGlobMatch","title":"<code>NGlobMatch</code>","text":"<p>A set of matches corresponding sharing consistent values for named wildcards.</p> <p>The matching files can be accessed by integer indexing or through the <code>files</code> attribute:</p> <pre><code>assert match[0] == match.files[0]\n</code></pre> <p>The substring matching the named wildcards can be accessed as attributes. For example, the substring matching a named wildcard <code>foo</code> is accessed as follows:</p> <pre><code>print(match.foo)\n</code></pre> <p>When you expect only a single matching file, then the <code>single</code> attribute can be used. It will raise an exception when there are zero or multiple matches:</p> <pre><code>print(match.single)\n</code></pre> <p>In the unfortunate case that your named wildcards are named <code>single</code>, <code>files</code> or <code>mapping</code>, you can access their values through the <code>mapping</code> attribute:</p> <pre><code>print(match.mapping[\"single\"])\n</code></pre> Source code in <code>stepup/core/nglob.py</code> <pre><code>@attrs.define\nclass NGlobMatch:\n    \"\"\"A set of matches corresponding sharing consistent values for named wildcards.\n\n    The matching files can be accessed by integer indexing or through the `files` attribute:\n\n    ```python\n    assert match[0] == match.files[0]\n    ```\n\n    The substring matching the named wildcards can be accessed as attributes.\n    For example, the substring matching a named wildcard `foo` is accessed as follows:\n\n    ```python\n    print(match.foo)\n    ```\n\n    When you expect only a single matching file, then the `single` attribute can be used.\n    It will raise an exception when there are zero or multiple matches:\n\n    ```python\n    print(match.single)\n    ```\n\n    In the unfortunate case that your named wildcards are named `single`, `files` or `mapping`,\n    you can access their values through the `mapping` attribute:\n\n    ```python\n    print(match.mapping[\"single\"])\n    ```\n    \"\"\"\n\n    _mapping: dict[str, str]\n    _files: list[Path | list[Path]]\n\n    def __getitem__(self, idx) -&gt; Path | list[Path]:\n        return self._files[idx]\n\n    def __getattr__(self, name) -&gt; str:\n        try:\n            return self._mapping[name]\n        except KeyError as exc:\n            raise AttributeError(f\"'NGlobMatch' object has no attribute '{name}'\") from exc\n\n    @property\n    def mapping(self) -&gt; dict[str, str]:\n        \"\"\"Dictionary with `(wildcard_name, substring)` items.\"\"\"\n        return self._mapping\n\n    @property\n    def files(self) -&gt; list[Path | list[Path]]:\n        \"\"\"Matching files, all having consistent substrings matching the named wildcards.\n\n        Each item corresponds to a pattern in `NGlobMulti.patterns`.\n        If a pattern has anonymous wildcards,\n        the item itself is a list of all files matching the pattern,\n        If the pattern contains no anonymous wildcards,\n        the corresponding item in the returned list is a single path.\n        \"\"\"\n        return self._files\n\n    @property\n    def single(self) -&gt; Path:\n        \"\"\"A single path if there is exactly one match, raises an error otherwise.\"\"\"\n        if len(self._files) == 0:\n            raise ValueError(\"No files matched.\")\n        if len(self._files) &gt; 1:\n            raise ValueError(\"Multiple files matched.\")\n        result = self._files[0]\n        if isinstance(result, list):\n            if len(result) == 0:\n                raise ValueError(\"No files matched.\")\n            if len(result) &gt; 1:\n                raise ValueError(\"Multiple files matched.\")\n            result = result[0]\n        return result\n</code></pre>"},{"location":"reference/stepup.core.nglob/#stepup.core.nglob.NGlobMatch.files","title":"<code>files</code>  <code>property</code>","text":"<p>Matching files, all having consistent substrings matching the named wildcards.</p> <p>Each item corresponds to a pattern in <code>NGlobMulti.patterns</code>. If a pattern has anonymous wildcards, the item itself is a list of all files matching the pattern, If the pattern contains no anonymous wildcards, the corresponding item in the returned list is a single path.</p>"},{"location":"reference/stepup.core.nglob/#stepup.core.nglob.NGlobMatch.mapping","title":"<code>mapping</code>  <code>property</code>","text":"<p>Dictionary with <code>(wildcard_name, substring)</code> items.</p>"},{"location":"reference/stepup.core.nglob/#stepup.core.nglob.NGlobMatch.single","title":"<code>single</code>  <code>property</code>","text":"<p>A single path if there is exactly one match, raises an error otherwise.</p>"},{"location":"reference/stepup.core.nglob/#stepup.core.nglob.NGlobMulti","title":"<code>NGlobMulti</code>","text":"<p>A sequence of Named Glob patterns for which consistent matches are collected.</p> Source code in <code>stepup/core/nglob.py</code> <pre><code>@attrs.define\nclass NGlobMulti:\n    \"\"\"A sequence of Named Glob patterns for which consistent matches are collected.\"\"\"\n\n    _nglob_singles: tuple[NGlobSingle, ...] = attrs.field()\n    _subs: dict[str, str] = attrs.field(init=False)\n    _used_names: tuple[str, ...] = attrs.field(init=False)\n    _has_wildcards: bool = attrs.field(init=False)\n    _results: dict[tuple[str, ...], list[set[Path]]] = attrs.field(init=False, factory=dict)\n\n    @_subs.default\n    def _default_subs(self):\n        if len(self._nglob_singles) == 0:\n            return {}\n        subs = self._nglob_singles[0].subs\n        for other in self._nglob_singles[1:]:\n            if other.subs != subs:\n                raise ValueError(\"Searches in one NGlobMulti must use the same substitutions\")\n            other._subs = subs\n        return subs\n\n    @_used_names.default\n    def _default_used_names(self) -&gt; tuple[str, ...]:\n        result = set()\n        for ngs in self._nglob_singles:\n            result.update(ngs.used_names)\n        return tuple(sorted(result))\n\n    @_has_wildcards.default\n    def _default_has_wildcards(self) -&gt; bool:\n        for ngs in self._nglob_singles:\n            if has_anonymous_wildcards(ngs.pattern):\n                return True\n        for name in self._used_names:\n            pattern = self._subs.get(name)\n            if pattern is None:\n                return True\n            if has_anonymous_wildcards(pattern):\n                return True\n        return False\n\n    @classmethod\n    def structure(cls, state: list, strings: list[str]) -&gt; Self:\n        \"\"\"Create an instance from the result of the `unstructure` method.\"\"\"\n        subs = state[1].copy()\n        for ngs_data in state[0]:\n            ngs_data[\"s\"] = subs\n        ngss = tuple(NGlobSingle.structure(ngs_data, strings) for ngs_data in state[0])\n        result = cls(ngss)\n        for i, ngs in enumerate(ngss):\n            for values in ngs.results:\n                result._extend_consistent(i, values)\n        return result\n\n    def unstructure(self, lookup: dict[str, int]) -&gt; list:\n        \"\"\"Return a serializable representation of the instance.\"\"\"\n        data = [\n            [ngs.unstructure(lookup) for ngs in self._nglob_singles],\n            self._subs.copy(),\n        ]\n        # A little hacky way to make the result more compact.\n        for ngs_data in data[0]:\n            del ngs_data[\"s\"]\n        return data\n\n    @classmethod\n    def from_patterns(cls, patterns: Iterable[str], subs: dict[str, str] | None = None) -&gt; Self:\n        \"\"\"Create a new instance for given patterns without any results.\n\n        Parameters\n        ----------\n        patterns\n            Named Glob patterns.\n            Results will be constrained to have consistently matching substrings\n            for the named wildcards appearing in all the patterns.\n        subs\n            Optional anonymous glob patterns for the named patterns.\n            When a name is not present, the wildcard `*` is used for this name.\n        \"\"\"\n        if isinstance(patterns, str):\n            raise TypeError(\"The patterns argument cannot be a string\")\n        if not all(isinstance(pattern, str) for pattern in patterns):\n            raise TypeError(f\"The patterns must be a list of strings, got {patterns}\")\n        if subs is None:\n            subs = {}\n        else:\n            if not all(isinstance(name, str) for name in subs):\n                raise TypeError(f\"The subs keys must be a list of strings, got {patterns}\")\n            if not all(isinstance(value, str) for value in subs.values()):\n                raise TypeError(f\"The subs values must be a list of strings, got {patterns}\")\n        return cls(tuple(NGlobSingle(str(pattern), subs) for pattern in patterns))\n\n    @property\n    def nglob_singles(self) -&gt; tuple[NGlobSingle, ...]:\n        \"\"\"The list of NGlobSingle instances, one for each pattern.\n\n        These instances collect (partial) matches before any consistency is imposed between\n        the substrings matching the same name in different patterns.\n        \"\"\"\n        return self._nglob_singles\n\n    @property\n    def patterns(self):\n        \"\"\"The list of Named Glob patterns.\"\"\"\n        return [ngs.pattern for ngs in self._nglob_singles]\n\n    @property\n    def subs(self) -&gt; dict[str, str]:\n        \"\"\"User-defined glob patterns for the named wildcards.\n\n        When a name is not present, `*` is used.\n        \"\"\"\n        return self._subs\n\n    @property\n    def used_names(self) -&gt; tuple[str, ...]:\n        \"\"\"The names used across all the named glob patterns.\"\"\"\n        return self._used_names\n\n    @property\n    def has_wildcards(self) -&gt; bool:\n        \"\"\"True if any named or anonymous wildcards are present in the patterns.\"\"\"\n        return self._has_wildcards\n\n    @property\n    def results(self) -&gt; dict[tuple[str, ...], list[set[Path]]]:\n        \"\"\"A dictionary with all matches collected so far.\n\n        A key in this dictionary is a tuple of substrings named wildcards,\n        using the same order as the `used_names` attribute.\n\n        A value is a list of sets of paths.\n        Each item in the list is a set of matching filenames for the corresponding\n        pattern from the `patterns` attribute, whose named wildcards match the substrings\n        of the key.\n\n        The results can be extended with the `extend` and `glob` methods.\n        Conversely, results can be removed with the `reduce` method.\n        \"\"\"\n        return self._results\n\n    def _iter_consistent(\n        self, criteria: dict[str, str], full_paths: list | int\n    ) -&gt; Iterator[tuple[str, ...], list[list[Path]]]:\n        \"\"\"Iterate over (partial) matching substrings and corresponding paths.\n\n        Parameters\n        ----------\n        criteria\n            A dictionary mapping named wildcards to matching substrings.\n        full_paths\n            If this is a list, it contains lists of paths matching the patterns\n            in of the `patterns` attribute with substrings consistent with those in\n            the criteria argument.\n            Note that this is a recursive iterator, so full_paths may contain fewer\n            items than there are patterns when the recursion has not reached it full\n            depth yet.\n            If this is an integer, it is in index referring to the item in the `patterns`\n            to identify the current pattern being processed.\n        \"\"\"\n        start = full_paths if isinstance(full_paths, int) else len(full_paths)\n        if start == len(self._nglob_singles):\n            # We're in the deepest recursion: yield a result.\n            yield tuple(criteria[name] for name in self._used_names), full_paths\n        else:\n            # Recursion in progress...\n            ngs = self._nglob_singles[start]\n            for new_values, paths in ngs.results.items():\n                next_criteria = criteria.copy()\n                # Check if named wildcards are consistent with the matching paths so far.\n                for name, new_value in zip(ngs.used_names, new_values, strict=False):\n                    value = next_criteria.get(name)\n                    if value is None:\n                        next_criteria[name] = new_value\n                    elif value != new_value:\n                        # Inconsistent matches for named wildcards in different patterns.\n                        # This cannot produce a useful result.\n                        next_criteria = None\n                        break\n                if next_criteria is not None:\n                    # Consistency can still be imposed, so enter the next recursion...\n                    next_full_paths = (\n                        start + 1 if isinstance(full_paths, int) else [*full_paths, paths]\n                    )\n                    yield from self._iter_consistent(next_criteria, next_full_paths)\n\n    def _extend_consistent(self, i: int, values: tuple[str, ...]):\n        \"\"\"Extend the results of this instance, given an added combination of matching substrings.\n\n        Parameters\n        ----------\n        i\n            The integer index of the pattern in the `patterns` attribute being processed.\n        values\n            A new set of substrings matching the named wildcards.\n        \"\"\"\n        criteria = dict(zip(self._nglob_singles[i].used_names, values, strict=False))\n        new_items = list(self._iter_consistent(criteria, []))\n        for full_values, full_paths in new_items:\n            self._results[full_values] = full_paths\n\n    def _reduce_consistent(self, i: int, values: tuple[str, ...]):\n        \"\"\"Return the results of this instance, given a removed combination of matching substrings.\n        Parameters\n        ----------\n        i\n            The integer index of the pattern in the `patterns` attribute being processed.\n        values\n            A new set of substrings matching the named wildcards.\n        \"\"\"\n        criteria = dict(zip(self._nglob_singles[i].used_names, values, strict=False))\n        old_items = list(self._iter_consistent(criteria, 0))\n        for full_values, _ in old_items:\n            del self._results[full_values]\n\n    def extend(self, paths: Iterable[str]):\n        \"\"\"Try to extend the results by searching for matches in the given list of paths.\"\"\"\n        if isinstance(paths, str):\n            raise TypeError(\"The paths argument cannot be a string.\")\n        for i, ngs in enumerate(self._nglob_singles):\n            for values in ngs.extend(paths):\n                self._extend_consistent(i, values)\n\n    def reduce(self, paths: Iterable[str]):\n        \"\"\"Drop results by eliminating the provided paths.\"\"\"\n        if isinstance(paths, str):\n            raise TypeError(\"The paths argument cannot be a string.\")\n        for i, ngs in enumerate(self._nglob_singles):\n            for values in ngs.reduce(paths):\n                self._reduce_consistent(i, values)\n\n    def glob(self):\n        \"\"\"Extend the results with paths found by the built-in glob function.\"\"\"\n        for i, ngs in enumerate(self._nglob_singles):\n            for values in ngs.glob():\n                self._extend_consistent(i, values)\n\n    def deepcopy(self):\n        \"\"\"Return an independent copy.\"\"\"\n        return copy.deepcopy(self)\n\n    def equals(self, other: \"NGlobMulti\") -&gt; bool:\n        \"\"\"Compare the results.\"\"\"\n        return self._results == other._results\n\n    # Convenience methods\n\n    def matches(self) -&gt; Iterator[NGlobMatch]:\n        \"\"\"Iterate over combinations of files that consistently match all patterns.\n\n        This offers a more convenient interface of the `results` attribute.\n\n        Yields\n        ------\n        nglob_match\n            An instance of NGlobMatch, which contains the substrings matching the named wildcards\n            and the corresponding lists of paths.\n        \"\"\"\n        for values, path_sets in sorted(self._results.items()):\n            mapping = dict(zip(self._used_names, values, strict=False))\n            files = [\n                (sorted(paths) if has_anonymous_wildcards(ngs.pattern) else next(iter(paths)))\n                for ngs, paths in zip(self._nglob_singles, path_sets, strict=False)\n            ]\n            yield NGlobMatch(mapping, files)\n\n    def files(self) -&gt; tuple[Path, ...]:\n        \"\"\"Return a tuple of sorted files that match the individual patterns.\n\n        No constraints between multiple patterns are imposed and files may belong to partial\n        and inconsistent full matches.\n        \"\"\"\n        result = set()\n        for ngs in self._nglob_singles:\n            for path_set in ngs.results.values():\n                result.update(path_set)\n        return tuple(sorted(result))\n\n    def single(self) -&gt; Path:\n        \"\"\"Return the single matching path.\n\n        Raises\n        ------\n        ValueError\n            If there is not exactly one match.\n        \"\"\"\n        files = self.files()\n        if len(files) != 1:\n            raise ValueError(f\"There are {len(files)} matches, not just one.\")\n        return files[0]\n\n    def __bool__(self):\n        \"\"\"True when there are some items in the `results` attribute.\"\"\"\n        return len(self.results) &gt; 0\n\n    def __iter__(self) -&gt; Iterator[str | NGlobMatch]:\n        \"\"\"Iterates over `self.matches` if there are named wildcards, else over `self.files`.\"\"\"\n        if len(self._used_names) &gt; 0:\n            return self.matches()\n        return iter(self.files())\n\n    def may_match(self, path):\n        \"\"\"Return True if the path matches one of the NGlobSingle instances.\n\n        This means that it may be path contributing to a consistent match of NGlobMulti.\n        When added, it will show up in the result of the `files` method,\n        and it may affect the outcome of the `matches` method.\n        \"\"\"\n        return any(ngs.regex.fullmatch(path) for ngs in self._nglob_singles)\n\n    def may_change(self, deleted: set[str], updated: set[str]) -&gt; bool:\n        \"\"\"Determine whether the results may change (later) after deleting or adding files.\n\n        Parameters\n        ----------\n        deleted\n            Set of files to be deleted.\n        updated\n            Set of files to be updated.\n\n        Returns\n        -------\n        may_change\n            True if the NGlobMulti results may change.\n            (It may require additional additions and deletions to get any effect,\n            but cannot be excluded that the provided deletions and updates play a role in it.)\n        \"\"\"\n        updated_new = updated.copy()\n        for ngs in self._nglob_singles:\n            for paths in ngs.results.values():\n                if not deleted.isdisjoint(paths):\n                    return True\n                updated_new.difference_update(paths)\n        for ngs in self._nglob_singles:\n            for path in updated_new:\n                if ngs.regex.fullmatch(path):\n                    return True\n        return False\n\n    def will_change(self, deleted: Collection[str], updated: Collection[str]) -&gt; bool:\n        \"\"\"Determine whether the results will change after deleting or adding files.\n\n        Parameters\n        ----------\n        deleted\n            Set of files to be deleted.\n        updated\n            Set of files to be added or changed.\n\n        Returns\n        -------\n        will_change\n            True if the NGlobMulti results will change.\n        \"\"\"\n        evolved = self.deepcopy()\n        evolved.extend(updated)\n        evolved.reduce(deleted)\n        return not evolved.equals(self)\n</code></pre>"},{"location":"reference/stepup.core.nglob/#stepup.core.nglob.NGlobMulti.has_wildcards","title":"<code>has_wildcards</code>  <code>property</code>","text":"<p>True if any named or anonymous wildcards are present in the patterns.</p>"},{"location":"reference/stepup.core.nglob/#stepup.core.nglob.NGlobMulti.nglob_singles","title":"<code>nglob_singles</code>  <code>property</code>","text":"<p>The list of NGlobSingle instances, one for each pattern.</p> <p>These instances collect (partial) matches before any consistency is imposed between the substrings matching the same name in different patterns.</p>"},{"location":"reference/stepup.core.nglob/#stepup.core.nglob.NGlobMulti.patterns","title":"<code>patterns</code>  <code>property</code>","text":"<p>The list of Named Glob patterns.</p>"},{"location":"reference/stepup.core.nglob/#stepup.core.nglob.NGlobMulti.results","title":"<code>results</code>  <code>property</code>","text":"<p>A dictionary with all matches collected so far.</p> <p>A key in this dictionary is a tuple of substrings named wildcards, using the same order as the <code>used_names</code> attribute.</p> <p>A value is a list of sets of paths. Each item in the list is a set of matching filenames for the corresponding pattern from the <code>patterns</code> attribute, whose named wildcards match the substrings of the key.</p> <p>The results can be extended with the <code>extend</code> and <code>glob</code> methods. Conversely, results can be removed with the <code>reduce</code> method.</p>"},{"location":"reference/stepup.core.nglob/#stepup.core.nglob.NGlobMulti.subs","title":"<code>subs</code>  <code>property</code>","text":"<p>User-defined glob patterns for the named wildcards.</p> <p>When a name is not present, <code>*</code> is used.</p>"},{"location":"reference/stepup.core.nglob/#stepup.core.nglob.NGlobMulti.used_names","title":"<code>used_names</code>  <code>property</code>","text":"<p>The names used across all the named glob patterns.</p>"},{"location":"reference/stepup.core.nglob/#stepup.core.nglob.NGlobMulti.__bool__","title":"<code>__bool__()</code>","text":"<p>True when there are some items in the <code>results</code> attribute.</p> Source code in <code>stepup/core/nglob.py</code> <pre><code>def __bool__(self):\n    \"\"\"True when there are some items in the `results` attribute.\"\"\"\n    return len(self.results) &gt; 0\n</code></pre>"},{"location":"reference/stepup.core.nglob/#stepup.core.nglob.NGlobMulti.__iter__","title":"<code>__iter__()</code>","text":"<p>Iterates over <code>self.matches</code> if there are named wildcards, else over <code>self.files</code>.</p> Source code in <code>stepup/core/nglob.py</code> <pre><code>def __iter__(self) -&gt; Iterator[str | NGlobMatch]:\n    \"\"\"Iterates over `self.matches` if there are named wildcards, else over `self.files`.\"\"\"\n    if len(self._used_names) &gt; 0:\n        return self.matches()\n    return iter(self.files())\n</code></pre>"},{"location":"reference/stepup.core.nglob/#stepup.core.nglob.NGlobMulti.deepcopy","title":"<code>deepcopy()</code>","text":"<p>Return an independent copy.</p> Source code in <code>stepup/core/nglob.py</code> <pre><code>def deepcopy(self):\n    \"\"\"Return an independent copy.\"\"\"\n    return copy.deepcopy(self)\n</code></pre>"},{"location":"reference/stepup.core.nglob/#stepup.core.nglob.NGlobMulti.equals","title":"<code>equals(other)</code>","text":"<p>Compare the results.</p> Source code in <code>stepup/core/nglob.py</code> <pre><code>def equals(self, other: \"NGlobMulti\") -&gt; bool:\n    \"\"\"Compare the results.\"\"\"\n    return self._results == other._results\n</code></pre>"},{"location":"reference/stepup.core.nglob/#stepup.core.nglob.NGlobMulti.extend","title":"<code>extend(paths)</code>","text":"<p>Try to extend the results by searching for matches in the given list of paths.</p> Source code in <code>stepup/core/nglob.py</code> <pre><code>def extend(self, paths: Iterable[str]):\n    \"\"\"Try to extend the results by searching for matches in the given list of paths.\"\"\"\n    if isinstance(paths, str):\n        raise TypeError(\"The paths argument cannot be a string.\")\n    for i, ngs in enumerate(self._nglob_singles):\n        for values in ngs.extend(paths):\n            self._extend_consistent(i, values)\n</code></pre>"},{"location":"reference/stepup.core.nglob/#stepup.core.nglob.NGlobMulti.files","title":"<code>files()</code>","text":"<p>Return a tuple of sorted files that match the individual patterns.</p> <p>No constraints between multiple patterns are imposed and files may belong to partial and inconsistent full matches.</p> Source code in <code>stepup/core/nglob.py</code> <pre><code>def files(self) -&gt; tuple[Path, ...]:\n    \"\"\"Return a tuple of sorted files that match the individual patterns.\n\n    No constraints between multiple patterns are imposed and files may belong to partial\n    and inconsistent full matches.\n    \"\"\"\n    result = set()\n    for ngs in self._nglob_singles:\n        for path_set in ngs.results.values():\n            result.update(path_set)\n    return tuple(sorted(result))\n</code></pre>"},{"location":"reference/stepup.core.nglob/#stepup.core.nglob.NGlobMulti.from_patterns","title":"<code>from_patterns(patterns, subs=None)</code>  <code>classmethod</code>","text":"<p>Create a new instance for given patterns without any results.</p> <p>Parameters:</p> <ul> <li> <code>patterns</code>               (<code>Iterable[str]</code>)           \u2013            <p>Named Glob patterns. Results will be constrained to have consistently matching substrings for the named wildcards appearing in all the patterns.</p> </li> <li> <code>subs</code>               (<code>dict[str, str] | None</code>, default:                   <code>None</code> )           \u2013            <p>Optional anonymous glob patterns for the named patterns. When a name is not present, the wildcard <code>*</code> is used for this name.</p> </li> </ul> Source code in <code>stepup/core/nglob.py</code> <pre><code>@classmethod\ndef from_patterns(cls, patterns: Iterable[str], subs: dict[str, str] | None = None) -&gt; Self:\n    \"\"\"Create a new instance for given patterns without any results.\n\n    Parameters\n    ----------\n    patterns\n        Named Glob patterns.\n        Results will be constrained to have consistently matching substrings\n        for the named wildcards appearing in all the patterns.\n    subs\n        Optional anonymous glob patterns for the named patterns.\n        When a name is not present, the wildcard `*` is used for this name.\n    \"\"\"\n    if isinstance(patterns, str):\n        raise TypeError(\"The patterns argument cannot be a string\")\n    if not all(isinstance(pattern, str) for pattern in patterns):\n        raise TypeError(f\"The patterns must be a list of strings, got {patterns}\")\n    if subs is None:\n        subs = {}\n    else:\n        if not all(isinstance(name, str) for name in subs):\n            raise TypeError(f\"The subs keys must be a list of strings, got {patterns}\")\n        if not all(isinstance(value, str) for value in subs.values()):\n            raise TypeError(f\"The subs values must be a list of strings, got {patterns}\")\n    return cls(tuple(NGlobSingle(str(pattern), subs) for pattern in patterns))\n</code></pre>"},{"location":"reference/stepup.core.nglob/#stepup.core.nglob.NGlobMulti.glob","title":"<code>glob()</code>","text":"<p>Extend the results with paths found by the built-in glob function.</p> Source code in <code>stepup/core/nglob.py</code> <pre><code>def glob(self):\n    \"\"\"Extend the results with paths found by the built-in glob function.\"\"\"\n    for i, ngs in enumerate(self._nglob_singles):\n        for values in ngs.glob():\n            self._extend_consistent(i, values)\n</code></pre>"},{"location":"reference/stepup.core.nglob/#stepup.core.nglob.NGlobMulti.matches","title":"<code>matches()</code>","text":"<p>Iterate over combinations of files that consistently match all patterns.</p> <p>This offers a more convenient interface of the <code>results</code> attribute.</p> <p>Yields:</p> <ul> <li> <code>nglob_match</code>           \u2013            <p>An instance of NGlobMatch, which contains the substrings matching the named wildcards and the corresponding lists of paths.</p> </li> </ul> Source code in <code>stepup/core/nglob.py</code> <pre><code>def matches(self) -&gt; Iterator[NGlobMatch]:\n    \"\"\"Iterate over combinations of files that consistently match all patterns.\n\n    This offers a more convenient interface of the `results` attribute.\n\n    Yields\n    ------\n    nglob_match\n        An instance of NGlobMatch, which contains the substrings matching the named wildcards\n        and the corresponding lists of paths.\n    \"\"\"\n    for values, path_sets in sorted(self._results.items()):\n        mapping = dict(zip(self._used_names, values, strict=False))\n        files = [\n            (sorted(paths) if has_anonymous_wildcards(ngs.pattern) else next(iter(paths)))\n            for ngs, paths in zip(self._nglob_singles, path_sets, strict=False)\n        ]\n        yield NGlobMatch(mapping, files)\n</code></pre>"},{"location":"reference/stepup.core.nglob/#stepup.core.nglob.NGlobMulti.may_change","title":"<code>may_change(deleted, updated)</code>","text":"<p>Determine whether the results may change (later) after deleting or adding files.</p> <p>Parameters:</p> <ul> <li> <code>deleted</code>               (<code>set[str]</code>)           \u2013            <p>Set of files to be deleted.</p> </li> <li> <code>updated</code>               (<code>set[str]</code>)           \u2013            <p>Set of files to be updated.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>may_change</code>           \u2013            <p>True if the NGlobMulti results may change. (It may require additional additions and deletions to get any effect, but cannot be excluded that the provided deletions and updates play a role in it.)</p> </li> </ul> Source code in <code>stepup/core/nglob.py</code> <pre><code>def may_change(self, deleted: set[str], updated: set[str]) -&gt; bool:\n    \"\"\"Determine whether the results may change (later) after deleting or adding files.\n\n    Parameters\n    ----------\n    deleted\n        Set of files to be deleted.\n    updated\n        Set of files to be updated.\n\n    Returns\n    -------\n    may_change\n        True if the NGlobMulti results may change.\n        (It may require additional additions and deletions to get any effect,\n        but cannot be excluded that the provided deletions and updates play a role in it.)\n    \"\"\"\n    updated_new = updated.copy()\n    for ngs in self._nglob_singles:\n        for paths in ngs.results.values():\n            if not deleted.isdisjoint(paths):\n                return True\n            updated_new.difference_update(paths)\n    for ngs in self._nglob_singles:\n        for path in updated_new:\n            if ngs.regex.fullmatch(path):\n                return True\n    return False\n</code></pre>"},{"location":"reference/stepup.core.nglob/#stepup.core.nglob.NGlobMulti.may_match","title":"<code>may_match(path)</code>","text":"<p>Return True if the path matches one of the NGlobSingle instances.</p> <p>This means that it may be path contributing to a consistent match of NGlobMulti. When added, it will show up in the result of the <code>files</code> method, and it may affect the outcome of the <code>matches</code> method.</p> Source code in <code>stepup/core/nglob.py</code> <pre><code>def may_match(self, path):\n    \"\"\"Return True if the path matches one of the NGlobSingle instances.\n\n    This means that it may be path contributing to a consistent match of NGlobMulti.\n    When added, it will show up in the result of the `files` method,\n    and it may affect the outcome of the `matches` method.\n    \"\"\"\n    return any(ngs.regex.fullmatch(path) for ngs in self._nglob_singles)\n</code></pre>"},{"location":"reference/stepup.core.nglob/#stepup.core.nglob.NGlobMulti.reduce","title":"<code>reduce(paths)</code>","text":"<p>Drop results by eliminating the provided paths.</p> Source code in <code>stepup/core/nglob.py</code> <pre><code>def reduce(self, paths: Iterable[str]):\n    \"\"\"Drop results by eliminating the provided paths.\"\"\"\n    if isinstance(paths, str):\n        raise TypeError(\"The paths argument cannot be a string.\")\n    for i, ngs in enumerate(self._nglob_singles):\n        for values in ngs.reduce(paths):\n            self._reduce_consistent(i, values)\n</code></pre>"},{"location":"reference/stepup.core.nglob/#stepup.core.nglob.NGlobMulti.single","title":"<code>single()</code>","text":"<p>Return the single matching path.</p> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If there is not exactly one match.</p> </li> </ul> Source code in <code>stepup/core/nglob.py</code> <pre><code>def single(self) -&gt; Path:\n    \"\"\"Return the single matching path.\n\n    Raises\n    ------\n    ValueError\n        If there is not exactly one match.\n    \"\"\"\n    files = self.files()\n    if len(files) != 1:\n        raise ValueError(f\"There are {len(files)} matches, not just one.\")\n    return files[0]\n</code></pre>"},{"location":"reference/stepup.core.nglob/#stepup.core.nglob.NGlobMulti.structure","title":"<code>structure(state, strings)</code>  <code>classmethod</code>","text":"<p>Create an instance from the result of the <code>unstructure</code> method.</p> Source code in <code>stepup/core/nglob.py</code> <pre><code>@classmethod\ndef structure(cls, state: list, strings: list[str]) -&gt; Self:\n    \"\"\"Create an instance from the result of the `unstructure` method.\"\"\"\n    subs = state[1].copy()\n    for ngs_data in state[0]:\n        ngs_data[\"s\"] = subs\n    ngss = tuple(NGlobSingle.structure(ngs_data, strings) for ngs_data in state[0])\n    result = cls(ngss)\n    for i, ngs in enumerate(ngss):\n        for values in ngs.results:\n            result._extend_consistent(i, values)\n    return result\n</code></pre>"},{"location":"reference/stepup.core.nglob/#stepup.core.nglob.NGlobMulti.unstructure","title":"<code>unstructure(lookup)</code>","text":"<p>Return a serializable representation of the instance.</p> Source code in <code>stepup/core/nglob.py</code> <pre><code>def unstructure(self, lookup: dict[str, int]) -&gt; list:\n    \"\"\"Return a serializable representation of the instance.\"\"\"\n    data = [\n        [ngs.unstructure(lookup) for ngs in self._nglob_singles],\n        self._subs.copy(),\n    ]\n    # A little hacky way to make the result more compact.\n    for ngs_data in data[0]:\n        del ngs_data[\"s\"]\n    return data\n</code></pre>"},{"location":"reference/stepup.core.nglob/#stepup.core.nglob.NGlobMulti.will_change","title":"<code>will_change(deleted, updated)</code>","text":"<p>Determine whether the results will change after deleting or adding files.</p> <p>Parameters:</p> <ul> <li> <code>deleted</code>               (<code>Collection[str]</code>)           \u2013            <p>Set of files to be deleted.</p> </li> <li> <code>updated</code>               (<code>Collection[str]</code>)           \u2013            <p>Set of files to be added or changed.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>will_change</code>           \u2013            <p>True if the NGlobMulti results will change.</p> </li> </ul> Source code in <code>stepup/core/nglob.py</code> <pre><code>def will_change(self, deleted: Collection[str], updated: Collection[str]) -&gt; bool:\n    \"\"\"Determine whether the results will change after deleting or adding files.\n\n    Parameters\n    ----------\n    deleted\n        Set of files to be deleted.\n    updated\n        Set of files to be added or changed.\n\n    Returns\n    -------\n    will_change\n        True if the NGlobMulti results will change.\n    \"\"\"\n    evolved = self.deepcopy()\n    evolved.extend(updated)\n    evolved.reduce(deleted)\n    return not evolved.equals(self)\n</code></pre>"},{"location":"reference/stepup.core.nglob/#stepup.core.nglob.NGlobSingle","title":"<code>NGlobSingle</code>","text":"<p>Named glob with a single pattern.</p> Source code in <code>stepup/core/nglob.py</code> <pre><code>@attrs.define\nclass NGlobSingle:\n    \"\"\"Named glob with a single pattern.\"\"\"\n\n    _pattern: str = attrs.field()\n    _subs: dict[str, str] = attrs.field(factory=dict)\n    _results: dict[tuple[str, ...], set[Path]] = attrs.field(factory=dict)\n    _used_names: tuple[str, ...] = attrs.field(init=False)\n    _glob_pattern: str = attrs.field(init=False)\n    _regex: re.Pattern = attrs.field(init=False)\n\n    @classmethod\n    def structure(cls, state, strings: list[str]):\n        \"\"\"Create an instance from the result of the `unstructure` method.\"\"\"\n        results = {\n            tuple(values): {Path(strings[path]) for path in paths} for values, paths in state[\"r\"]\n        }\n        return cls(strings[state[\"p\"]], state[\"s\"], results)\n\n    def unstructure(self, lookup: dict[str, int]) -&gt; dict[str, Any]:\n        \"\"\"Return a serializable representation of the instance.\"\"\"\n        results = [\n            (key, [lookup[path] for path in sorted(paths)]) for key, paths in self._results.items()\n        ]\n        return {\"p\": lookup[self.pattern], \"s\": self.subs, \"r\": results}\n\n    @_used_names.default\n    def _default_used_names(self) -&gt; tuple[str, ...]:\n        return tuple(sorted(set(iter_wildcard_names(self._pattern))))\n\n    @_glob_pattern.default\n    def _default_glob(self) -&gt; str:\n        return convert_nglob_to_glob(self._pattern, self._subs)\n\n    @_regex.default\n    def _default_regex(self) -&gt; re.Pattern:\n        return re.compile(convert_nglob_to_regex(self._pattern, self._subs))\n\n    @property\n    def pattern(self) -&gt; str:\n        \"\"\"The Named Glob pattern used to match filenames.\"\"\"\n        return self._pattern\n\n    @property\n    def subs(self) -&gt; dict[str, str]:\n        \"\"\"User-defined glob patterns for the named wildcards.\n\n        When a name is not present, `*` is used.\n        \"\"\"\n        return self._subs\n\n    @property\n    def results(self) -&gt; dict[tuple[str, ...], set[Path]]:\n        \"\"\"All matching files, grouped by substrings matching the named wildcards.\n\n        The keys of the `results` dictionary are tuples with the substrings,\n        matching the respective named wildcards in the `used_names` tuple.\n        The values are sets with matching paths.\n        \"\"\"\n        return self._results\n\n    @property\n    def used_names(self) -&gt; tuple[str, ...]:\n        \"\"\"A tuple of named wildcards present in the pattern.\"\"\"\n        return self._used_names\n\n    @property\n    def glob_pattern(self) -&gt; str:\n        \"\"\"The conversion of the named glob to a (more general) conventional glob pattern.\"\"\"\n        return self._glob_pattern\n\n    @property\n    def regex(self) -&gt; re.Pattern:\n        \"\"\"The conversion of the named glob to a regular expression.\"\"\"\n        return self._regex\n\n    def _loop_matches(\n        self, paths: Iterable[str]\n    ) -&gt; Iterator[tuple[tuple[str, ...], set[Path], Path]]:\n        \"\"\"Low-level iterator used by the `extend` and `reduce` methods.\n\n        The paths are tested one by one against the regular expression.\n        In case of a hit, it yields a tuple with the following three items:\n\n        - `values`: the substrings matching the named wildcards.\n        - `path_set`: the current set of paths associated with the combination of substrings.\n        - `path`: a `Path` instance of the matching path.\n        \"\"\"\n        for path in paths:\n            match_ = self._regex.fullmatch(path)\n            if match_ is not None:\n                mapping = match_.groupdict()\n                values = tuple(mapping[name] for name in self._used_names)\n                paths = self._results.get(values)\n                if paths is None:\n                    paths = set()\n                    self._results[values] = paths\n                yield values, paths, Path(path)\n                if len(paths) == 0:\n                    del self._results[values]\n\n    def extend(self, paths: Iterable[str]) -&gt; Iterator[tuple[str, ...]]:\n        \"\"\"Add matching paths from the given list paths.\n\n        Yields\n        ------\n        values\n            A tuple with substring matching the named wildcards,\n            only this combination of names was not present yet.\n        \"\"\"\n        for values, path_set, path in self._loop_matches(paths):\n            if len(path_set) == 0:\n                yield values\n            path_set.add(path)\n\n    def reduce(self, paths: Iterable[str]) -&gt; Iterator[tuple[str, ...]]:\n        \"\"\"Remove matching paths from given list paths.\n\n        Yields\n        ------\n        values\n            A tuple with deleted substring matching the named wildcards,\n            only if the last matching paths were removed.\n        \"\"\"\n        for values, path_set, path in self._loop_matches(paths):\n            if len(path_set) &gt; 0:\n                path_set.discard(path)\n                if len(path_set) == 0:\n                    yield values\n\n    def glob(self) -&gt; Iterator[tuple[str, ...]]:\n        \"\"\"Extend the results with paths obtained through the built-in glob module.\n\n        Yields\n        ------\n        values\n            A tuple with substring matching the named wildcards,\n            only this combination of names was not present yet.\n        \"\"\"\n        paths = []\n        for path in glob.iglob(self._glob_pattern, recursive=True, include_hidden=True):\n            path = Path(path)\n            if path.is_dir():\n                path = path / \"\"\n            paths.append(path)\n        yield from self.extend(paths)\n</code></pre>"},{"location":"reference/stepup.core.nglob/#stepup.core.nglob.NGlobSingle.glob_pattern","title":"<code>glob_pattern</code>  <code>property</code>","text":"<p>The conversion of the named glob to a (more general) conventional glob pattern.</p>"},{"location":"reference/stepup.core.nglob/#stepup.core.nglob.NGlobSingle.pattern","title":"<code>pattern</code>  <code>property</code>","text":"<p>The Named Glob pattern used to match filenames.</p>"},{"location":"reference/stepup.core.nglob/#stepup.core.nglob.NGlobSingle.regex","title":"<code>regex</code>  <code>property</code>","text":"<p>The conversion of the named glob to a regular expression.</p>"},{"location":"reference/stepup.core.nglob/#stepup.core.nglob.NGlobSingle.results","title":"<code>results</code>  <code>property</code>","text":"<p>All matching files, grouped by substrings matching the named wildcards.</p> <p>The keys of the <code>results</code> dictionary are tuples with the substrings, matching the respective named wildcards in the <code>used_names</code> tuple. The values are sets with matching paths.</p>"},{"location":"reference/stepup.core.nglob/#stepup.core.nglob.NGlobSingle.subs","title":"<code>subs</code>  <code>property</code>","text":"<p>User-defined glob patterns for the named wildcards.</p> <p>When a name is not present, <code>*</code> is used.</p>"},{"location":"reference/stepup.core.nglob/#stepup.core.nglob.NGlobSingle.used_names","title":"<code>used_names</code>  <code>property</code>","text":"<p>A tuple of named wildcards present in the pattern.</p>"},{"location":"reference/stepup.core.nglob/#stepup.core.nglob.NGlobSingle.extend","title":"<code>extend(paths)</code>","text":"<p>Add matching paths from the given list paths.</p> <p>Yields:</p> <ul> <li> <code>values</code>           \u2013            <p>A tuple with substring matching the named wildcards, only this combination of names was not present yet.</p> </li> </ul> Source code in <code>stepup/core/nglob.py</code> <pre><code>def extend(self, paths: Iterable[str]) -&gt; Iterator[tuple[str, ...]]:\n    \"\"\"Add matching paths from the given list paths.\n\n    Yields\n    ------\n    values\n        A tuple with substring matching the named wildcards,\n        only this combination of names was not present yet.\n    \"\"\"\n    for values, path_set, path in self._loop_matches(paths):\n        if len(path_set) == 0:\n            yield values\n        path_set.add(path)\n</code></pre>"},{"location":"reference/stepup.core.nglob/#stepup.core.nglob.NGlobSingle.glob","title":"<code>glob()</code>","text":"<p>Extend the results with paths obtained through the built-in glob module.</p> <p>Yields:</p> <ul> <li> <code>values</code>           \u2013            <p>A tuple with substring matching the named wildcards, only this combination of names was not present yet.</p> </li> </ul> Source code in <code>stepup/core/nglob.py</code> <pre><code>def glob(self) -&gt; Iterator[tuple[str, ...]]:\n    \"\"\"Extend the results with paths obtained through the built-in glob module.\n\n    Yields\n    ------\n    values\n        A tuple with substring matching the named wildcards,\n        only this combination of names was not present yet.\n    \"\"\"\n    paths = []\n    for path in glob.iglob(self._glob_pattern, recursive=True, include_hidden=True):\n        path = Path(path)\n        if path.is_dir():\n            path = path / \"\"\n        paths.append(path)\n    yield from self.extend(paths)\n</code></pre>"},{"location":"reference/stepup.core.nglob/#stepup.core.nglob.NGlobSingle.reduce","title":"<code>reduce(paths)</code>","text":"<p>Remove matching paths from given list paths.</p> <p>Yields:</p> <ul> <li> <code>values</code>           \u2013            <p>A tuple with deleted substring matching the named wildcards, only if the last matching paths were removed.</p> </li> </ul> Source code in <code>stepup/core/nglob.py</code> <pre><code>def reduce(self, paths: Iterable[str]) -&gt; Iterator[tuple[str, ...]]:\n    \"\"\"Remove matching paths from given list paths.\n\n    Yields\n    ------\n    values\n        A tuple with deleted substring matching the named wildcards,\n        only if the last matching paths were removed.\n    \"\"\"\n    for values, path_set, path in self._loop_matches(paths):\n        if len(path_set) &gt; 0:\n            path_set.discard(path)\n            if len(path_set) == 0:\n                yield values\n</code></pre>"},{"location":"reference/stepup.core.nglob/#stepup.core.nglob.NGlobSingle.structure","title":"<code>structure(state, strings)</code>  <code>classmethod</code>","text":"<p>Create an instance from the result of the <code>unstructure</code> method.</p> Source code in <code>stepup/core/nglob.py</code> <pre><code>@classmethod\ndef structure(cls, state, strings: list[str]):\n    \"\"\"Create an instance from the result of the `unstructure` method.\"\"\"\n    results = {\n        tuple(values): {Path(strings[path]) for path in paths} for values, paths in state[\"r\"]\n    }\n    return cls(strings[state[\"p\"]], state[\"s\"], results)\n</code></pre>"},{"location":"reference/stepup.core.nglob/#stepup.core.nglob.NGlobSingle.unstructure","title":"<code>unstructure(lookup)</code>","text":"<p>Return a serializable representation of the instance.</p> Source code in <code>stepup/core/nglob.py</code> <pre><code>def unstructure(self, lookup: dict[str, int]) -&gt; dict[str, Any]:\n    \"\"\"Return a serializable representation of the instance.\"\"\"\n    results = [\n        (key, [lookup[path] for path in sorted(paths)]) for key, paths in self._results.items()\n    ]\n    return {\"p\": lookup[self.pattern], \"s\": self.subs, \"r\": results}\n</code></pre>"},{"location":"reference/stepup.core.nglob/#stepup.core.nglob.convert_nglob_to_glob","title":"<code>convert_nglob_to_glob(pattern, subs=None)</code>","text":"<p>Convert nglob wildcards to ordinary ones, compatible with builtin glob and fnmatch modules.</p> <p>Parameters:</p> <ul> <li> <code>pattern</code>               (<code>str</code>)           \u2013            <p>A string with named wildcards.</p> </li> <li> <code>subs</code>               (<code>dict[str, str] | None</code>, default:                   <code>None</code> )           \u2013            <p>A dictionary mapping names to glob patterns. If a name is not present, <code>*</code> is used as default.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>pattern</code>           \u2013            <p>A conventional wildcard string, without the constraint that named wildcards must correspond. Where possible, neighboring wildcards are merged into one.</p> </li> </ul> Source code in <code>stepup/core/nglob.py</code> <pre><code>def convert_nglob_to_glob(pattern: str, subs: dict[str, str] | None = None) -&gt; str:\n    \"\"\"Convert nglob wildcards to ordinary ones, compatible with builtin glob and fnmatch modules.\n\n    Parameters\n    ----------\n    pattern\n        A string with named wildcards.\n    subs\n        A dictionary mapping names to glob patterns.\n        If a name is not present, `*` is used as default.\n\n    Returns\n    -------\n    pattern\n        A conventional wildcard string, without the constraint that named wildcards must correspond.\n        Where possible, neighboring wildcards are merged into one.\n    \"\"\"\n    if subs is None:\n        subs = {}\n    # Split in text, wildcard and named wildcard fragments.\n    parts = []\n    # The odd-numbered indices match a (named) wildcard.\n    for i, part in enumerate(RE_NAMED_WILD.split(pattern)):\n        if i % 2 == 1 and part.startswith(\"${*\"):\n            # Split the substituted named wildcards once more.\n            parts.extend(RE_NAMED_WILD.split(subs.get(part[3:-1], \"*\")))\n        else:\n            # No substitution, so no additional splitting required.\n            parts.append(part)\n    # Remove empty strings due to neighboring wildcards with no normal text in between.\n    parts = [part for part in parts if part != \"\"]\n    # Make sure no asterisks are glued together and a few other simplifications.\n    texts = []\n    for part in parts:\n        if len(texts) == 0 or part == \"?\":\n            texts.append(part)\n        elif part == \"*\":\n            if texts[-1] not in [\"*\", \"**\"]:\n                texts.append(\"*\")\n        elif part == \"**\":\n            if texts[-1] in [\"*\"]:\n                texts[-1] = \"**\"\n            elif texts[-1] != \"**\":\n                texts.append(\"**\")\n        else:\n            texts.append(part)\n    return \"\".join(texts)\n</code></pre>"},{"location":"reference/stepup.core.nglob/#stepup.core.nglob.convert_nglob_to_regex","title":"<code>convert_nglob_to_regex(pattern, subs=None, allow_names=True)</code>","text":"<p>Convert a named glob pattern to a regular expressions.</p> <p>Parameters:</p> <ul> <li> <code>pattern</code>               (<code>str</code>)           \u2013            <p>A string with named wildcards.</p> </li> <li> <code>subs</code>               (<code>dict[str, str] | None</code>, default:                   <code>None</code> )           \u2013            <p>A dictionary mapping names to glob patterns. If a name is not present, <code>*</code> is used as default.</p> </li> <li> <code>allow_names</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>When set to <code>False</code>, named wildcards are not allowed.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>regex</code>           \u2013            <p>A regular expression string to test if a string matches the pattern. It also contains symbolic groups to extract values corresponding to named wildcards and to impose consistency when the same name appears multiple times.</p> </li> </ul> Source code in <code>stepup/core/nglob.py</code> <pre><code>def convert_nglob_to_regex(\n    pattern: str, subs: dict[str, str] | None = None, allow_names: bool = True\n) -&gt; str:\n    \"\"\"Convert a named glob pattern to a regular expressions.\n\n    Parameters\n    ----------\n    pattern\n        A string with named wildcards.\n    subs\n        A dictionary mapping names to glob patterns.\n        If a name is not present, `*` is used as default.\n    allow_names\n        When set to `False`, named wildcards are not allowed.\n\n    Returns\n    -------\n    regex\n        A regular expression string to test if a string matches the pattern.\n        It also contains symbolic groups to extract values\n        corresponding to named wildcards\n        and to impose consistency when the same name appears multiple times.\n    \"\"\"\n    if subs is None:\n        subs = {}\n    parts = []\n    # Last non-empty part matched by re.split\n    last = None\n    # Names encountered so far\n    encountered = set()\n    for i, part in enumerate(RE_NAMED_WILD.split(pattern)):\n        if i % 2 == 0:\n            if len(part) &gt; 0:\n                # Not a wildcard: escape regex characters.\n                parts.append(re.escape(part))\n        else:\n            # A (named) wildcard: replace with corresponding regex.\n            replace = False\n            regex = None\n            if part == \"?\":\n                regex = r\"[^/]\"\n            elif part == \"*\":\n                if last not in [\"*\", \"**\"]:\n                    regex = r\"[^/]*\"\n            elif part == \"**\":\n                if last != \"**\":\n                    regex = r\".*\"\n                    if last in [\"*\"]:\n                        replace = True\n            elif part.startswith(\"[\") and part.endswith(\"]\"):\n                regex = rf\"[^{part[2:-1]}]\" if part[1] == \"!\" else rf\"[{part[1:-1]}]\"\n            elif part.startswith(\"${*\") and part.endswith(\"}\"):\n                if not allow_names:\n                    raise ValueError(f\"Named wildcards not allowed in {pattern}\")\n                name = part[3:-1]\n                if name in encountered:\n                    regex = rf\"(?P={name})\"\n                else:\n                    part_regex = convert_nglob_to_regex(subs.get(name, \"*\"), {}, False)\n                    regex = rf\"(?P&lt;{name}&gt;{part_regex})\"\n                    encountered.add(name)\n            else:\n                raise ValueError(f\"Cannot convert wildcard to regex: {part}\")\n            if regex is not None and len(regex) &gt; 0:\n                if replace:\n                    parts[-1] = regex\n                else:\n                    parts.append(regex)\n        if len(part) &gt; 0:\n            last = part\n\n    if allow_names:\n        # Post-process anonymous wildcards:\n        # - when enclosed by separators, '*' and '**; do not match empty strings.\n        for ipart, part in enumerate(parts):\n            if (\n                ipart &gt; 0\n                and ipart &lt; len(parts) - 1\n                and part.endswith(\"*\")\n                and parts[ipart - 1].endswith(\"/\")\n                and parts[ipart + 1].startswith(\"/\")\n            ):\n                parts[ipart] = f\"{part[:-1]}+\"\n        # - when the pattern ends with '*', it must also match paths with a trailing separator.\n        if parts[-1] == r\"[^/]*\":\n            if len(parts) &gt;= 2 and parts[-2].endswith(\"/\"):\n                parts[-1] = r\"[^/]+\"\n            parts.append(\"/?\")\n\n    return \"\".join(parts)\n</code></pre>"},{"location":"reference/stepup.core.nglob/#stepup.core.nglob.has_anonymous_wildcards","title":"<code>has_anonymous_wildcards(pattern)</code>","text":"<p>Test if a glob pattern has anonymous wildcards.</p> Source code in <code>stepup/core/nglob.py</code> <pre><code>def has_anonymous_wildcards(pattern: str) -&gt; bool:\n    \"\"\"Test if a glob pattern has anonymous wildcards.\"\"\"\n    for ipart, part in enumerate(RE_NAMED_WILD.split(pattern)):\n        if ipart % 2 == 1 and not part.startswith(\"${*\"):\n            return True\n    return False\n</code></pre>"},{"location":"reference/stepup.core.nglob/#stepup.core.nglob.has_wildcards","title":"<code>has_wildcards(pattern)</code>","text":"<p>Test if a glob pattern has anonymous or named wildcards.</p> Source code in <code>stepup/core/nglob.py</code> <pre><code>def has_wildcards(pattern: str) -&gt; bool:\n    \"\"\"Test if a glob pattern has anonymous or named wildcards.\"\"\"\n    return RE_NAMED_WILD.search(pattern) is not None\n</code></pre>"},{"location":"reference/stepup.core.nglob/#stepup.core.nglob.iter_wildcard_names","title":"<code>iter_wildcard_names(pattern)</code>","text":"<p>Iterate over the names of the named wildcards in a Named Glob pattern.</p> Source code in <code>stepup/core/nglob.py</code> <pre><code>def iter_wildcard_names(pattern: str) -&gt; Iterator[str]:\n    \"\"\"Iterate over the names of the named wildcards in a Named Glob pattern.\"\"\"\n    for ipart, part in enumerate(RE_NAMED_WILD.split(pattern)):\n        if ipart % 2 == 1 and part.startswith(\"${*\"):\n            yield part[3:-1]\n</code></pre>"}]}