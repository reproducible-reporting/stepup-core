{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to StepUp Core","text":"<p>StepUp is a simple, powerful and universal build tool, a modern alternative to Make.</p> <p>StepUp, like most build tools, schedules and executes commands in parallel. The scheduling takes into account that input files for a command must be available. Build tools also keep track of which other commands can create these files.</p> <p>This is the documentation for StepUp Core, the basic framework for StepUp, without any domain-specific functionality. Domain-specific features are implemented in extension packages. Currently, there is only the StepUp RepRep extension for creating reproducible reports: papers, presentations, theses, etc.</p>"},{"location":"#what-does-stepup-look-like","title":"What Does StepUp Look Like?","text":"<p>The following screen recording provides a quick visual impression of StepUp\u2019s terminal user interface.</p>"},{"location":"#why-was-stepup-created","title":"Why Was StepUp Created?","text":"<p>StepUp is a greenfield project inspired by similar tools, such as Ninja, pydoit and tup.</p> <p>The defining feature of StepUp is that it treats the generation and execution of the build workflow as one and the same thing. This may sound abstract, so let\u2019s clarify this by reviewing how build tools work and have evolved over time.</p> <p>Traditional build tools run programs in parallel using a fixed workflow as input: you must define in advance this workflow by writing all steps and their dependencies in a text file, such as a <code>Makefile</code>. In practice, such files are rarely written manually. Instead, they are often generated by other tools, such as CMake or Automake, which handle the configuration and discovery of build steps. This separation into generation and execution simplifies the build tool, but it also prevents steps from being defined using the output of previous steps.</p> <p>More modern build tools, such as Bazel, Meson and Buck2 have abandoned the traditional separation between build generator and executor. They introduce a domain-specific language (DSL), such as Starlark, to specify the build steps. These DSLs are designed to be powerful for build tasks, but are limited in what they can do for security reasons.</p> <p>For software compilation, established build tools usually make acceptable assumptions, and workarounds exist for certain exceptions, see for example <code>depfile</code>, <code>deps</code>, <code>dyndep</code> and <code>generator rule</code> in Ninja. In build scenarios other than software compilation, e.g., building a scientific publication from LaTeX sources and raw data, these workarounds are too limited. For example, if a LaTeX source contains <code>\\input</code> commands with TeX files generated by a script, it cannot be decided in advance whether these generated files reference additional input files, e.g., figures. In such cases, it is natural to determine all inputs of a LaTeX document on the fly instead of doing so in advance. (StepUp RepRep\u2019s predecessor, RepRepBuild, generated build instructions for Ninja and addressed this problem with an elaborate generator rule.)</p> <p>StepUp overcomes such difficulties by taking a different approach. The <code>stepup</code> command starts a background process that can receive build steps from any step in the build process, via Remote Procedure Calls (RPCs). It uses this information to extend its workflow, which are internally represented by partial directed acyclic graphs. This process is bootstrapped by an initial <code>plan.py</code> script containing the first RPC calls. Each build step can use intermediate results to add new information to the workflow. Steps can even be added rather late in the build, if this is necessary to correctly define them.</p> <p>The program tup deserves a special mention in this brief review. StepUp\u2019s algorithm for rebuilding steps (in response to changed inputs) resembles that of tup. The build algorithm in both programs traverse upwards through the dependency graph. The \u201cUp\u201d part of StepUp\u2019s name acknowledges this source of inspiration, with \u201cStep\u201d reflecting how StepUp defines operations as individual steps.</p>"},{"location":"#other-noteworthy-features","title":"Other noteworthy features","text":"<ul> <li> <p>StepUp build scripts are written in Python, in so-called <code>plan.py</code> files,   instead of introducing a new domain-specific language (DSL).</p> </li> <li> <p>StepUp supports partial directed acyclic graph (PDAG) execution,   similar to tup.   StepUp is radical in the sense that it always assumes partial knowledge of the DAG.   For example, at startup it will start steps before it has complete knowledge of the workflow.</p> </li> <li> <p>StepUp always runs background processes (a director and several workers) to execute steps,   and a terminal frontend to control or interrupt the build.   The director starts with a run phase to execute steps in parallel until the build is complete.   When StepUp completes the build, it can switch to a watch phase to register file changes.   When the user requests a rerun, it knows exactly which part of the DAG needs to be rebuilt.   This allows efficient edit-build iterations to incrementally build and refine a project.</p> </li> <li> <p>A file must either be declared static (written by the user) or built (created by a step)   before it can be used as input for steps.   StepUp will never use a file without knowing if it is static or built.   Static file declarations are uncommon in other build tools and   allow StepUp to correctly execute steps with partial knowledge of the workflow.</p> </li> <li> <p>Old outputs are automatically removed   when the steps creating those files are removed from the workflow.   This cleanup is only performed after a completely successful build.</p> </li> <li> <p>Rich pattern-matching rules make it easy to multiplex a step over multiple similar inputs.</p> </li> <li> <p>Steps do not need to have output files.   They will be rerun if inputs have changed since the last run.</p> </li> <li> <p>Environment variables can be defined as dependencies,   so that steps will rerun if they depend on variables that have changed.</p> </li> <li> <p>If a step\u2019s input files have changed, a file hash is used to determine whether the file   is different from a previous run before the step is re-run.   This prevents unnecessary step executions in two common scenarios:</p> <ul> <li>A file is changed and then reverted to its original state.</li> <li>Switching between branches in Git.</li> </ul> </li> <li> <p>The StepUp terminal user interface provides easy-to-follow progress information.</p> </li> <li> <p>A keyboard shortcut can be defined in most IDEs to start   a new run phase of an active StepUp director.   The command <code>python -c 'from stepup.core.interact import run; run()'</code>   will instruct the director to run pending steps due to file changes.</p> </li> <li> <p>While a step is running, it can inform StepUp that it needs additional inputs,   in which case the step will be rescheduled for later execution   (after the additional inputs have become available).   Similarly, a step can define additional outputs during its execution.</p> </li> </ul>"},{"location":"#when-to-use-stepup","title":"When to use StepUp?","text":"<ul> <li>The software compilation assumptions of other build tools get in the way.</li> <li>You want to define the workflow in a language you already know: Python.</li> <li>Writing out all dependencies upfront is difficult or impossible.</li> <li>You enjoy living on the edge.</li> </ul>"},{"location":"changelog/","title":"Changelog","text":""},{"location":"changelog/#changelog","title":"Changelog","text":"<p>All notable changes to this project will be documented in this file.</p> <p>The format is based on Keep a Changelog, and this project adheres to Effort-based Versioning. (Changes to features documented as \u201cexperimental\u201d will not increment macro and meso version numbers.)</p>"},{"location":"changelog/#unreleased","title":"Unreleased","text":"<p>(no summary yet)</p>"},{"location":"changelog/#v2.1.7","title":"2.1.7 - 2025-04-24","text":"<p>Minor enhancements and bugfixes.</p>"},{"location":"changelog/#added","title":"Added","text":"<ul> <li>Print progress information on every line when stdout is not a terminal.</li> <li>The <code>stepup</code> command now accepts the <code>--no-clean</code> option   to disable removal of outdated outputs at the end of a successful run.</li> </ul>"},{"location":"changelog/#changed","title":"Changed","text":"<ul> <li>Simplified the output of the <code>cases</code> command of the script <code>driver()</code>.</li> <li>The arguments <code>inp</code>, <code>out</code> and <code>vol</code> are converted to <code>Path</code> instances   before calling the <code>run()</code> function.</li> </ul>"},{"location":"changelog/#fixed","title":"Fixed","text":"<ul> <li>Never amend <code>HERE</code> and <code>ROOT</code> environment variables.</li> </ul>"},{"location":"changelog/#v2.1.6","title":"2.1.6 - 2025-04-24","text":"<p>This is a minor bugfix release.</p>"},{"location":"changelog/#fixed_1","title":"Fixed","text":"<ul> <li>Do not abort StepUp when wal or shm files are present.</li> <li>Upon restart, handle removed files correctly that previously matched a deferred glob.</li> </ul>"},{"location":"changelog/#v2.1.5","title":"2.1.5 - 2025-03-25","text":"<p>This is a minor bugfix release.</p>"},{"location":"changelog/#fixed_2","title":"Fixed","text":"<ul> <li>Fixed bug in format string in <code>stepup.core.api</code>.</li> <li>Small cleanups</li> <li>Tweak absolute path tests for non-FHS systems.</li> </ul>"},{"location":"changelog/#v2.1.4","title":"2.1.4 - 2025-02-12","text":"<p>This is a minor bugfix release.</p>"},{"location":"changelog/#fixed_3","title":"Fixed","text":"<ul> <li>Fix a bug when using <code>getenv(..., multi=True)</code> with a non-existing environment variable.</li> </ul>"},{"location":"changelog/#v2.1.3","title":"2.1.3 - 2025-02-12","text":"<p>This is a minor bugfix release.</p>"},{"location":"changelog/#fixed_4","title":"Fixed","text":"<ul> <li>Fix a bug related to input validation of steps with amended inputs.</li> </ul>"},{"location":"changelog/#v2.1.2","title":"2.1.2 - 2025-02-12","text":"<p>This is a minor bugfix release.</p>"},{"location":"changelog/#fixed_5","title":"Fixed","text":"<ul> <li>Fix an RPC timeout bug.</li> </ul>"},{"location":"changelog/#v2.1.1","title":"2.1.1 - 2025-02-12","text":"<p>This is a minor bugfix release.</p>"},{"location":"changelog/#fixed_6","title":"Fixed","text":"<ul> <li>Disable input checking when running a <code>ValidateAmendJob</code>.   (It is expected that inputs may not be consistent yet at this stage.)   This eliminates some false positive input errors.</li> </ul>"},{"location":"changelog/#v2.1.0","title":"2.1.0 - 2025-02-12","text":"<p>This release improves the overall robustness of StepUp. Most importantly, table constraints are introduced on the <code>file</code> table in <code>.stepup/graph.db</code>, eliminating potential bugs by design (or making them easier to fix). The constraints change the database schema, so <code>graph.db</code> files created with version 2.0 will be discarded. The workflow will be completely rebuilt after an upgrade to StepUp Core 2.1.</p> <p>This release also refactors the implementation of file and step hashes, and worker processes. Finally, error messages and exception handling have been improved.</p>"},{"location":"changelog/#added_1","title":"Added","text":"<ul> <li>The log level can be controlled with the <code>STEPUP_LOG_LEVEL</code> environment variable.   Alternatively, set <code>STEPUP_DEBUG=1</code>, which will also activate additional debugging output.   (This replaces the former <code>STEPUP_STRICT</code> environment variable.)</li> <li>Improve handling of unexpected file changes.   Before a step is executed or skipped, and after it has completed,   changes to inputs (since they were declared static or built by previous steps),   will cause the step to fail and the scheduler to drain.   (This feature requires a database schema version increase.)</li> </ul>"},{"location":"changelog/#changed_1","title":"Changed","text":"<ul> <li>Because of other database schema changes in this release,   also the <code>FileState</code> enumeration was relabeled in a more chronological order.</li> <li>The <code>cleanup</code> command always runs in the most verbose mode (<code>-v</code> no longer supported).   It now also supports the <code>-d</code> or <code>--dry-run</code> option to show which files would be cleaned.</li> <li>The variable <code>${STEPUP_EXTERNAL_SOURCES}</code> can now also contain relative paths,   which are assumed to be relative to <code>${STEPUP_ROOT}</code>.</li> <li>The default timeout for RPC calls has been increased from 5 to 300 seconds.   It can be controlled with the <code>STEPUP_SYNC_RPC_TIMEOUT</code> environment variable.   Setting it to a negative value will disable the timeout   and make RPC calls wait indefinitely for a response.</li> </ul>"},{"location":"changelog/#fixed_7","title":"Fixed","text":"<ul> <li>Table constraints are introduced to ensure file states and hashes are consistent.   This eliminates some difficult to reproduce bugs or makes them easier to fix.   (This change requires a database schema version increase.)</li> <li>Code documentation updates and internal cleanups.</li> <li>Renaming and moving directories in watch phase is now handled correctly.</li> <li>Fixed routine to wipe database in case of a schema version change.</li> <li>Add safety check to prevent two StepUp instances from running in the same directory.</li> <li>Add a warning when errors are reported in <code>.stepup/director.log</code>.</li> <li>When running StepUp with the <code>-w</code> option and the scheduler is drained,   queued steps are now made pending again, ensuring they are only executed when appropriate.</li> </ul>"},{"location":"changelog/#v2.0.7","title":"2.0.7 - 2025-02-06","text":"<p>This release fixes two recursive glob issues.</p>"},{"location":"changelog/#fixed_8","title":"Fixed","text":"<ul> <li>Fixed issues with directories matching <code>glob(\"...\", _defer=True)</code>,   which are later used as parent directories in various scenarios.</li> <li>Fix bug in recursive glob to match <code>data/inp.txt</code> with the pattern <code>data/**/inp.txt</code></li> </ul>"},{"location":"changelog/#v2.0.6","title":"2.0.6 - 2025-02-05","text":"<p>This release introduces the <code>STEPUP_EXTERNAL_SOURCES</code> environment variable for more fine-grained control over automatic dependency tracking.</p>"},{"location":"changelog/#added_2","title":"Added","text":"<ul> <li>The <code>STEPUP_EXTERNAL_SOURCES</code> environment variable can be set to   a colon-separated list of directories with source files outside <code>STEPUP_ROOT</code>.   The <code>script</code> and <code>call</code> drivers use this to decide which imported Python modules   to consider as inputs to a step.</li> </ul>"},{"location":"changelog/#changed_2","title":"Changed","text":"<ul> <li>Switch from SemVer to   EffVer.</li> </ul>"},{"location":"changelog/#v2.0.5","title":"2.0.5 - 2025-01-28","text":"<p>This is a minor release, just adding a utility function.</p>"},{"location":"changelog/#changed_3","title":"Changed","text":"<ul> <li>Use <code>string_to_bool</code> to interpret the environment variable <code>STEPUP_STRICT</code>.   E.g., setting it to <code>\"0\"</code> will disable strict mode.</li> </ul>"},{"location":"changelog/#v2.0.4","title":"2.0.4 - 2025-01-28","text":"<p>This release fixes very minor issues. It is mainly for testing release automation.</p>"},{"location":"changelog/#fixed_9","title":"Fixed","text":"<ul> <li>Use <code>importlib.metadata</code> instead of <code>_version.py</code> to get the version number.</li> <li>Add <code>--version</code> option to <code>stepup</code> command.</li> <li>Improve screen output consistency.</li> </ul>"},{"location":"changelog/#v2.0.3","title":"2.0.3 - 2025-01-27","text":"<p>This release fixes one pesky bug.</p>"},{"location":"changelog/#fixed_10","title":"Fixed","text":"<ul> <li>It was previously not possible to reattach an orphaned step to a different creator   when this step was not a top-level orphan.   This limitation has been lifted, because it is a fully legitimate use case.</li> </ul>"},{"location":"changelog/#v2.0.2","title":"2.0.2 - 2025-01-25","text":"<p>This release fixes several bugs.</p>"},{"location":"changelog/#added_3","title":"Added","text":"<ul> <li>Environment variable <code>STEPUP_STRICT</code> to enforce strict mode.   This disables automatic fixes in the database that can only be caused by bugs.</li> </ul>"},{"location":"changelog/#fixed_11","title":"Fixed","text":"<ul> <li>A bug is fixed in the logic to determine the type of job to run for a given step.   Some steps were executed while not all required inputs were present.</li> <li>A bug is fixed that caused optional steps not to be executed again, when their inputs   had changed or their outputs were removed.</li> <li>A bug is fixed that caused outputs of steps to be removed when they were changed   from <code>optional=False</code> to <code>optional=True</code>.</li> <li>Occasionally, <code>.stepup/</code> was not created yet   when the reporter tried writing to <code>.stepup/success.log</code>.</li> <li>When multiple steps were changed and StepUp is restarted,   steps created by a by another modified step were executed before the creating step.   This is fixed.</li> <li>Fix a few issues found by deepsource.io.</li> </ul>"},{"location":"changelog/#v2.0.1","title":"2.0.1 - 2025-01-22","text":"<p>(Version 2.0.0 was yanked due to a packaging issue.)</p>"},{"location":"changelog/#added_4","title":"Added","text":"<ul> <li>New option <code>-W</code> or <code>--watch-first</code> to automatically rerun steps after a file has changed.</li> <li>Press <code>q</code> a second time to kill running steps with SIGINT, similar to ctrl-c.</li> <li>Press <code>q</code> a third time to kill running steps with SIGKILL, nuclear option.</li> <li><code>stepup</code> has a meaningful returncode:<ul> <li><code>0</code> = all mandatory steps succeeded</li> <li><code>1</code> = internal error (Python exception)</li> <li><code>2</code> = at least one step failed</li> <li><code>3</code> = no steps failed, but some remained pending</li> </ul> </li> <li>Failed steps (if any) are also logged to <code>.stepup/fail.log</code>,   which is more convenient to inspect than scrolling back in the terminal.   Similarly, all warnings (if any) are written to <code>.stepup/warning.log</code>.</li> <li><code>--perf</code> option to analyze performance bottlenecks in the director process.</li> <li>The \u201ccall\u201d protocol is added as a light alternative to the \u201cscript\u201d protocol.   It can be used through the new <code>call()</code> function.</li> <li><code>getinfo()</code> function to retrieve the   <code>StepInfo</code> object of the current step.</li> <li>Cleanly exit the director process upon several types of exceptions (instead of hanging).</li> <li>Gracefully handle <code>SIGINT</code> and <code>SIGTERM</code>, e.g. pressing <code>ctrl-c</code> in the terminal.</li> </ul>"},{"location":"changelog/#changed_4","title":"Changed","text":"<ul> <li> <p>Breaking changes to <code>stepup.core.api</code>:</p> <ul> <li>The <code>getenv()</code> function has been extended and now has three options   (<code>path</code>, <code>rebase</code> and <code>multi</code>) to control how the environment variable gets processed.</li> <li>The optional <code>workdir</code> argument of the <code>script()</code> function   must always be specified as a keyword argument.</li> <li>The <code>block</code> argument of the <code>plan()</code> function must be given as a keyword argument.</li> <li>All optional arguments of <code>copy()</code>   and <code>mkdir()</code> must be given as keyword arguments.</li> <li><code>plan.py</code> scripts must start with <code>#!/usr/bin/env python3</code> instead of <code>#!/usr/bin/env python</code>.</li> <li>The <code>amend()</code> function now raises an exception when the   amended inputs are not available yet, instead of returning <code>False</code>.</li> </ul> </li> <li> <p>Backward compatible changes to <code>stepup.core.api</code>:</p> <ul> <li>The <code>script()</code> function has an extra <code>step_info</code> option   to specify a file to which the <code>step_info</code> objects of the run part(s) is/are written.   This comes with an extension of the script protocol: <code>./script.py plan</code> must   accept an optional argument <code>--step-info=...</code></li> <li>The <code>script()</code> function now accepts all arguments   that can be passed on to the underlying <code>step()</code> call.   There are only relevant for the plan stage of the script protocol.</li> <li>The script <code>driver()</code> now detects local imports in the   <code>run()</code> function of the script and amends them as inputs.</li> <li>The <code>plan()</code> function now accepts all arguments   that can be passed on to the underlying <code>step()</code> call.</li> </ul> </li> <li> <p>Command-line and terminal interface changes:</p> <ul> <li>By default, StepUp will exit after having executed all runnable steps.   Use the option <code>-w</code> or <code>--watch</code> to keep <code>stepup</code> running and watching for file changes.</li> <li>Keyboard interaction works with and without the (new) <code>--watch</code> option.</li> <li>The <code>cleanup</code> script now also works when <code>stepup</code> is not running.   It also features an improved verbosity option.</li> </ul> </li> <li> <p>Terminology changes:</p> <ul> <li>The \u201csupplier \u279c consumer\u201d graph is now called the dependency graph.</li> <li>The \u201ccreator \u279c product\u201d graph is now called the provenance graph.</li> </ul> </li> <li> <p>Internal changes:</p> <ul> <li>Complete refactoring of the internal workflow data structure, file format and the core algorithms.   For example, if some files change, StepUp can better narrow down which steps are worth rerunning.</li> <li>The workflow is now entirely stored in an SQLite database, in <code>.stepup/graph.db</code>,   which has major benefits:<ul> <li>When an RPC call modifies the workflow and causes an exception,   the workflow rolls back to its last known valid state (before the RPC call),   thanks to SQLite\u2019s ACID properties.   This eliminates many potential bugs by construction.</li> <li>Upon restart, StepUp can continue without noticeable delay where it last stopped,   because its entire last-known state of the workflow is readily available.   StepUp only needs to check for changed files and environment variables   to decide if (additional) steps need to be made pending.</li> <li>If something goes wrong unexpectedly in a complex production workflow,   the <code>graph.db</code> file can be inspected with <code>sqlitebrowser</code> to debug the issue   and potentially derive a small test case to be added to the unit tests.   The use of SQLite adds a (small) computational overhead   compared to storing the same information in native Python data structures.   This release has not been extensively optimized for performance.</li> </ul> </li> <li>Improved tracking of file changes.   Unexpected changes to input files of steps in the run phase will cause an exception.</li> </ul> </li> </ul>"},{"location":"changelog/#removed","title":"Removed","text":"<ul> <li>StepUp no longer uses <code>msgpack</code> and uses pickling for serialization instead.   The <code>msgpack</code> dependency has been removed.   Related <code>structure()</code> and <code>unstructure()</code> methods have been removed.</li> <li>The <code>-f</code> or <code>--workflow</code> argument of the director server has been removed.</li> <li>The <code>f</code> (from scratch) and <code>t</code> (try replay) keys have been removed   from the terminal user interface.</li> </ul>"},{"location":"changelog/#fixed_12","title":"Fixed","text":"<ul> <li>When static file has been deleted (missing) and later restored,   the restored file was not noticed when restarting StepUp. This is fixed.</li> <li>Tests have been made compatible with Python 3.13.</li> <li>Files with whitespace are handled correctly.   (That being said, we don\u2019t recommend using files with whitespace.)</li> </ul>"},{"location":"changelog/#v1.3.1","title":"1.3.1 - 2024-09-17","text":""},{"location":"changelog/#fixed_13","title":"Fixed","text":"<ul> <li>Fix incorrect parsing of <code>?*</code> and <code>*?</code> wildcards in the <code>nglob</code> module.</li> </ul>"},{"location":"changelog/#v1.3.0","title":"1.3.0 - 2024-08-27","text":""},{"location":"changelog/#added_5","title":"Added","text":"<ul> <li>Add support for standard output and error redirection in the script driver.   The dictionary returned by the <code>info()</code> or <code>case_info()</code> functions   can include <code>\"stdout\"</code> and/or <code>\"stderr\"</code> items.   The values of these two fields are paths to which the standard output and/or error   of the run part of the script are redirected.</li> <li>All API functions that define a step now return a <code>StepInfo</code> instance,   which may contain useful information (e.g. output paths) to define follow-up steps.   This is mainly useful for API extensions that define higher-level functions to create steps,   e.g. as in StepUp RepRep.</li> <li>The classes <code>NGlobMulti</code> has a new method <code>single()</code>   and <code>NGlobMatch</code> has a new property <code>single</code>.   These are only valid when there is a unique match,   i.e. when the <code>files()</code> method or property has exactly one path.</li> </ul>"},{"location":"changelog/#changed_5","title":"Changed","text":"<ul> <li>Migrate <code>load_module_file</code> to stepup-reprep.</li> <li>Replace watchdog   by asyncinotify   to avoid a long-standing issue in watchdog.</li> <li>:warning: API-breaking :warning:   When a step is defined with a working directory different from <code>'./'</code>,   relative paths provided in other arguments to the <code>step()</code> function   are interpreted relative to the given working directory,   not the current working directory of the running process.</li> <li>The directory <code>.stepup</code> is no longer created when running <code>stepup</code>   without a <code>plan.py</code>.</li> <li>The files in <code>.stepup/logs</code> have been renamed to <code>*.log</code> files under <code>.stepup</code>.</li> </ul>"},{"location":"changelog/#fixed_14","title":"Fixed","text":"<ul> <li>Fix bug in the translation of relative paths before they are sent to the director process.</li> <li>Add trailing slash to <code>workdir</code> argument of <code>stepup.core.api.step()</code> if it is missing.</li> <li>Fix mistake in worker log filenames.</li> <li>Fix bug in back translation of paths when substituted in a step command.</li> <li>Improve compatibility of nglob with Python\u2019s built-in glob.</li> </ul>"},{"location":"changelog/#v1.2.8","title":"1.2.8 - 2024-06-28","text":""},{"location":"changelog/#fixed_15","title":"Fixed","text":"<ul> <li>Modify the script driver so that <code>info()</code> and <code>case_info()</code> may return empty dictionaries.</li> </ul>"},{"location":"changelog/#v1.2.7","title":"1.2.7 - 2024-06-24","text":""},{"location":"changelog/#fixed_16","title":"Fixed","text":"<ul> <li>Add workaround for Python==3.11 bug with RPC over sockets.   The RPC server (created with <code>asyncio.start_unix_server</code>) closes before all requests are handled.   A stop event is now included for all RPC handlers   to wait with stopping the server until every request is handled.   This is a known issue fixed in Python 3.12.1.</li> </ul>"},{"location":"changelog/#v1.2.6","title":"1.2.6 - 2024-06-13","text":""},{"location":"changelog/#fixed_17","title":"Fixed","text":"<ul> <li>Do not watch files when running StepUp non-interactively.   This makes non-interactive mode a workaround for   a nasty watchdog bug.</li> </ul>"},{"location":"changelog/#v1.2.5","title":"1.2.5 - 2024-06-13","text":""},{"location":"changelog/#fixed_18","title":"Fixed","text":"<ul> <li>Effectively make watching recursive when a directory is added that is known in the workflow.</li> <li>The function <code>amend()</code> now always returns <code>True</code> when the RPC client is a dummy.   This fixes early exits from scripts that used <code>amend()</code> when they are called manually.</li> <li>Prevent the <code>Cannot watch non-existing directory</code> error by ensuring that deferred glob matches   exist before they are included as static files in the graph.</li> <li>Check that local scripts have a shebang line before trying to execute them.</li> <li>Improved continuous integration setup</li> <li>Minor documentation improvements</li> <li>Minor code cleanups</li> </ul>"},{"location":"changelog/#v1.2.4","title":"1.2.4 - 2024-05-27","text":""},{"location":"changelog/#changed_6","title":"Changed","text":"<ul> <li>Include \u201chidden\u201d files when globbing.</li> </ul>"},{"location":"changelog/#fixed_19","title":"Fixed","text":"<ul> <li>Do not refuse to replay unchanged step that declares its own static inputs.</li> <li>Make recursive glob consistent with Python\u2019s built-in glob in <code>step.core.nglob</code>.</li> <li>Pool definitions are stored in workflow and replayed correctly when a step is skipped.</li> </ul>"},{"location":"changelog/#v1.2.3","title":"1.2.3 - 2024-05-19","text":""},{"location":"changelog/#changed_7","title":"Changed","text":"<ul> <li>Completed and revised docstrings in <code>stepup.core.nglob</code>,   and added this module to the reference documentation.</li> </ul>"},{"location":"changelog/#fixed_20","title":"Fixed","text":"<ul> <li>Improve hash computation of a symbolic links in <code>stepup.core.hash</code>.</li> </ul>"},{"location":"changelog/#v1.2.2","title":"1.2.2 - 2024-05-16","text":""},{"location":"changelog/#changed_8","title":"Changed","text":"<ul> <li>Documentation updates.</li> </ul>"},{"location":"changelog/#fixed_21","title":"Fixed","text":"<ul> <li>Make <code>cleanup</code> command work in project subdirectories when <code>STEPUP_ROOT</code> is set.</li> <li>Avoid useless wait when running a <code>plan.py</code> script outside of <code>stepup</code>.</li> </ul>"},{"location":"changelog/#v1.2.1","title":"1.2.1 - 2024-05-07","text":""},{"location":"changelog/#fixed_22","title":"Fixed","text":"<ul> <li>Fixed packaging mistake that confused PyCharm and Pytest.</li> </ul>"},{"location":"changelog/#v1.2.0","title":"1.2.0 - 2024-05-02","text":""},{"location":"changelog/#added_6","title":"Added","text":"<ul> <li>Export of graphs to Graphviz DOT files.</li> <li>The <code>cleanup</code> script for manually cleaning up outputs.</li> </ul>"},{"location":"changelog/#changed_9","title":"Changed","text":"<ul> <li>Documentation updates.</li> <li>Limit acyclic constraint to the supplier-consumer graph.   This means a step can declare a static file and then amend it as input.</li> <li>Refactoring of the file <code>stepup.core.watcher</code> module:<ul> <li>Replace dependency <code>watchfiles</code> by <code>watchdog</code>.</li> <li>Rename functions in <code>stepup.core.interact</code>:<ul> <li><code>watch_add()</code> -&gt; <code>watch_update()</code></li> <li><code>watch_del()</code> -&gt; <code>watch_delete()</code></li> </ul> </li> <li>Separate watcher and runner coroutines with reduced risk for race conditions related to   <code>watch_delete()</code> and <code>watch_update()</code> to address <code>TimeoutError</code>.</li> <li>Place custom asyncio utilities in <code>stepup.core.asyncio</code>.</li> <li>The watcher also tracks changes to static files while steps are being executed.</li> <li>Directories are watched as soon as they are created.</li> </ul> </li> <li>The function <code>stepup.core.interact.graph</code> takes a prefix argument instead of a full filename,   e.g. <code>graph</code> instead of <code>graph.txt</code>.</li> </ul>"},{"location":"changelog/#fixed_23","title":"Fixed","text":"<ul> <li>More graceful error message when the director process crashes early.</li> <li>Fix compatibility with asciinema terminal recording.</li> <li>Raise <code>ConnectionResetError</code> in <code>SocketSyncRPCClient</code> instead of blocking forever when   the director process crashes.</li> </ul>"},{"location":"changelog/#v1.0.0","title":"1.0.0 - 2024-04-25","text":"<p>Initial release</p>"},{"location":"development/","title":"Developer Notes","text":"<p>If you would like to contribute, please read CONTRIBUTING.md.</p>"},{"location":"development/#development-environment","title":"Development environment","text":"<p>If you break your development environment, you can discard it by running <code>git clean -dfX</code> and repeating the instructions below.</p> <p>A local installation for testing and development can be installed using the following commands:</p> <pre><code>git clone git@github.com:reproducible-reporting/stepup-core.git\ncd stepup-core\npre-commit install\npython -m venv venv\n</code></pre> <p>Put the following lines in <code>.envrc</code>:</p> <pre><code>source venv/bin/activate\nexport XDG_CACHE_HOME=\"${VIRTUAL_ENV}/cache\"\nexport STEPUP_DEBUG=\"1\"\nexport STEPUP_SYNC_RPC_TIMEOUT=\"30\"\n</code></pre> <p>Finally, run the following commands:</p> <pre><code>direnv allow\npip install -U pip\npip install -e .[dev]\n</code></pre>"},{"location":"development/#tests","title":"Tests","text":"<p>We use pytest, so you can run the tests as follows:</p> <pre><code>pytest -vv\n</code></pre>"},{"location":"development/#documentation","title":"Documentation","text":"<p>The documentation is created using MkDocs. mike is used to manage documentation of different versions</p> <p>Edit the documentation Markdown files with a live preview by running:</p> <pre><code>mkdocs serve\n</code></pre> <p>(Keep this running.) Then open the live preview in your browser at http://127.0.0.1:8000/ and edit Markdown files in your IDE.</p> <p>Please, use Semantic Line Breaks because it facilitates reviewing documentation changes.</p>"},{"location":"development/#tutorial-example-outputs","title":"Tutorial Example Outputs","text":"<p>If you wish to regenerate the output of the examples, run <code>stepup</code> in the <code>docs</code> directory:</p> <pre><code>cd docs\nstepup\n</code></pre> <p>Note that some scripts use Graphviz to generate diagrams, so you must have it installed on your system.</p>"},{"location":"development/#how-to-make-a-release","title":"How to Make a Release","text":"<ul> <li>Mark the release in <code>docs/changelog.md</code>.   Do not forget to extend the links at the bottom of the file.</li> <li>Make a new commit and tag it with <code>vX.Y.Z</code>.</li> <li>Trigger the PyPI GitHub Action: <code>git push origin main --tags</code>.</li> </ul>"},{"location":"installation/","title":"Installation","text":"<p>Requirements:</p> <ul> <li>POSIX operating system: Linux, macOS or WSL.   StepUp cannot run natively on Windows.</li> <li>Python \u2265 3.11</li> <li>Pip</li> </ul> <p>It is assumed that you know how to use Pip. We recommend performing the installation in a Python virtual environment and activating such environments with direnv.</p> <p>The core package can be installed with:</p> <pre><code>pip install stepup\n</code></pre> <p>The StepUp RepRep extension (for reproducible reporting) is installed with:</p> <pre><code>pip install stepup-reprep\n</code></pre>"},{"location":"license/","title":"License","text":""},{"location":"license/#source-code-license","title":"Source code license","text":"<p>StepUp Core is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.</p> <p>StepUp Core is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.</p> <p>You should have received a copy of the GNU General Public License along with this program. If not, see https://www.gnu.org/licenses/.</p>"},{"location":"license/#documentation-license","title":"Documentation license","text":"<p>StepUp Core\u2019s documentation is distributed under the Creative Commons CC BY-SA 4.0 license.</p>"},{"location":"advanced_topics/amending_static_inputs/","title":"Amending Static Inputs","text":"<p>Occasionally, it may be convenient to declare a static file and then use it as input in the same script. As of StepUp 1.2.0, this is allowed and no longer treated as a cyclic dependency.</p>"},{"location":"advanced_topics/amending_static_inputs/#example","title":"Example","text":"<p>Create the following <code>plan.py</code>, which declares a static file, amends it as input, and then opens it to print it to the standard output.</p> <pre><code>#!/usr/bin/env python3\nfrom stepup.core.api import amend, static\n\nstatic(\"config.txt\")\namend(inp=\"config.txt\")\nwith open(\"config.txt\") as fh:\n    print(fh.read().strip())\n</code></pre> <p>Also create a <code>config.txt</code> file with some contents.</p> <p>In more realistic scenarios, <code>config.txt</code> may be used to decide which steps to add etc. For a more elaborate example, take a look at the <code>plan.py</code> that is used to run all tutorial examples.</p> <p>Make <code>plan.py</code> executable and run it as follows:</p> <pre><code>chmod +x plan.py\nstepup -n 1\n</code></pre> <p>You should get the following terminal output:</p> <pre><code>  DIRECTOR \u2502 Listening on /tmp/stepup-########/director (StepUp 2.0.4)\n   STARTUP \u2502 (Re)initialized boot script\n  DIRECTOR \u2502 Launched worker 0\n     PHASE \u2502 run\n     START \u2502 ./plan.py\n   SUCCESS \u2502 ./plan.py\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 Standard output \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nThis is a config file.\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n  DIRECTOR \u2502 Trying to delete 0 outdated output(s).\n  DIRECTOR \u2502 Stopping workers.\n  DIRECTOR \u2502 See you!\n</code></pre>"},{"location":"advanced_topics/amending_steps/","title":"Amending steps","text":"<p>Every step in StepUp can inform the director process of additional inputs or environment variables it uses, or of additional (volatile) outputs it creates. However, defining an amended input will fail when that file is not yet built nor known as a static file. In this case, the step wil exit early and will be rescheduled by the director process when the amended input becomes available.</p> <p>The <code>amend()</code> function implements this feature and is convenient in various scenarios:</p> <ul> <li> <p>This is particularly useful when a step uses input files that refer to other input files.   It may happen that some of these other input files still need to be generated by other steps.   Once built, the other inputs may again refer to more input files, etc.   Such dependencies cannot be discovered in advance,   simply because not all inputs are available before running the steps that generate them.   (This is a common scenario when writing LaTeX documents of which parts are generated by scripts.)</p> </li> <li> <p>Another use case is that some steps may take their default configuration   from environment variables if some command-line options are missing.   In this case, <code>amend()</code> can be used to specify the environment variables used.</p> </li> <li> <p>Some steps may produce a list of volatile outputs, some of which are difficult to know upfront.   One may specify such volatile outputs with <code>amend()</code> after they have been created.</p> </li> </ul> <p>To use <code>amend()</code> effectively, use it as early as possible, before accessing additional input files or creating unforeseen output files. Also, try to amend as many possible step arguments in a single call. This will avoid the following problems:</p> <ul> <li> <p>Trying to read from a file that hasn\u2019t been created yet.</p> </li> <li> <p>Unintentionally overwriting a file, e.g. a STATIC file that you have written by hand.</p> </li> <li> <p>Performing unnecessary work   (because a call to amend may mean that the step is interrupted and restarted later).   This is particularly important when the step is time-consuming   or when it uses <code>stepup.core.api</code> functions to extend the workflow.</p> </li> <li> <p>Rescheduling a step multiple times.</p> </li> </ul> <p>To the best of our knowledge, there is no equivalent of <code>amend()</code> in other build tools. Some features in Ninja cover what can be achieved with <code>amend()</code>.</p>"},{"location":"advanced_topics/amending_steps/#example","title":"Example","text":"<p>Example source files: <code>docs/advanced_topics/amending_steps/</code></p> <p>This example intentionally creates a simple scenario with an amended input. This is a somewhat silly example to illustrate the concept. You may achieve the same result without amending, because you have full control over all scripts in the example.</p> <p>Create the following <code>plan.py</code>, where the first step is a script that will discover it needs an additional input.</p> <pre><code>#!/usr/bin/env python3\nfrom stepup.core.api import static, step\n\nstatic(\"step.py\")\nstep(\"./step.py\", inp=[\"step.py\", \"sources.txt\"])\nstep(\"echo input.txt &gt; ${out}\", out=\"sources.txt\")\nstep(\"echo You better read this. &gt; input.txt\", out=\"input.txt\", optional=True)\n</code></pre> <p>In addition, create a file <code>input.txt</code> with some arbitrary contents and the following <code>step.py</code> script:</p> <pre><code>#!/usr/bin/env python3\nfrom stepup.core.api import amend\n\n# Parse the sources.txt file\nwith open(\"sources.txt\") as fh:\n    paths_inp = fh.read().split()\n\n# Request the additional input.\namend(inp=paths_inp)\n\n# Write all files from source.txt to the standard output.\n# This part is reachable only if the amended input is present.\nfor path_inp in paths_inp:\n    print(f\"Contents of {path_inp}:\")\n    with open(path_inp) as fh:\n        print(fh.read())\n</code></pre> <p>Make the scripts executable and fire up StepUp to see how it deals with the amended input:</p> <pre><code>chmod +x step.py plan.py\nstepup -n 1\n</code></pre> <p>You should get the following terminal output:</p> <pre><code>  DIRECTOR \u2502 Listening on /tmp/stepup-########/director (StepUp 2.0.4)\n   STARTUP \u2502 (Re)initialized boot script\n  DIRECTOR \u2502 Launched worker 0\n     PHASE \u2502 run\n     START \u2502 ./plan.py\n   SUCCESS \u2502 ./plan.py\n     START \u2502 echo input.txt &gt; sources.txt\n   SUCCESS \u2502 echo input.txt &gt; sources.txt\n     START \u2502 ./step.py\nRESCHEDULE \u2502 ./step.py\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 Rescheduling due to unavailable amended inputs \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\ninput.txt\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n     START \u2502 echo You better read this. &gt; input.txt\n   SUCCESS \u2502 echo You better read this. &gt; input.txt\n     START \u2502 ./step.py\n   SUCCESS \u2502 ./step.py\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 Standard output \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nContents of input.txt:\nYou better read this.\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n  DIRECTOR \u2502 Trying to delete 0 outdated output(s).\n  DIRECTOR \u2502 Stopping workers.\n  DIRECTOR \u2502 See you!\n</code></pre> <p>The output shows that <code>./step.py</code> first stops early due to the missing file <code>input.txt</code>. Once this required input becomes clear, StepUp schedules the optional step to generate the requested input. Later, StepUp runs <code>./step.py</code> again.</p>"},{"location":"advanced_topics/amending_steps/#try-the-following","title":"Try the Following","text":"<ul> <li> <p>Run StepUp again without making any changes.   As expected, all steps are skipped.   The <code>.stepup/graph.db</code> file also stores the amended information,   so these don\u2019t need to be rediscovered later.</p> </li> <li> <p>Modify the <code>plan.py</code> file to include a second amended input, for example, <code>other.txt</code>.   Run StepUp with these changes.   Because <code>sources.txt</code> contains a new file, StepUp will try re-running   <code>./step.py</code>, which will amend new inputs that require the step to be rescheduled again.</p> </li> </ul>"},{"location":"advanced_topics/blocked_steps/","title":"Blocked Steps","text":"<p>As discussed in the previous tutorial, StepUp has several mechanisms to ignore certain steps. As a rule, StepUp will always try to execute all steps, and not doing so is the exception.</p> <p>A valid reason for ignoring some steps is illustrated in the following schematic:</p> <pre><code>     File           In development            File                 Costly\n|-------------|      |----------|      |-----------------|      |----------|\n|  input.txt  |  =&gt;  |  Step 1  |  =&gt;  |  converted.txt  |  =&gt;  |  Step 2  |\n|-------------|      |----------|      |-----------------|      |----------|\n</code></pre> <p>Imagine that <code>Step 2</code> is very expensive and you are developing a script for <code>Step 1</code>. In practice, it takes several iterations to get <code>Step 1</code> working properly. This can be verified by analyzing the file <code>converted.txt</code> or with unit tests.</p> <p>To avoid executing <code>Step 2</code> at every iteration in the development of <code>Step 1</code>, you can block this step. All step-creating functions accept an optional <code>block=True</code> keyword argument to prevent them from being executed. Blocking steps is a temporary measure, meant to be reverted once you\u2019re done with <code>Step 1</code>.</p> <p>Blocking steps has some consequences:</p> <ul> <li>Blocked steps remain in the <code>PENDING</code> state,   meaning that outdated output files are not cleaned up automatically.</li> <li>At the end of the run phase, a list of blocked steps is shown,   to remind the user that some steps are blocked.</li> <li>Subsequent steps, which use outputs of blocked or pending steps, also remain pending.</li> </ul>"},{"location":"advanced_topics/blocked_steps/#example","title":"Example","text":"<p>Example source files: <code>docs/advanced_topics/blocked_steps/</code></p> <p>The following <code>plan.py</code> illustrates the blocking mechanism. The copy commands are too simple and cheap to justify blocking, so this is just an example to illustrate the mechanism only.</p> <pre><code>#!/usr/bin/env python3\nfrom stepup.core.api import copy, step\n\nstep(\"echo hello &gt; ${out}\", out=\"a.txt\")\ncopy(\"a.txt\", \"b.txt\", block=True)\ncopy(\"b.txt\", \"c.txt\")\n</code></pre> <p>Make this plan executable and run it with StepUp:</p> <pre><code>chmod +x plan.py\nstepup -n 1\n</code></pre> <p>You should get the following terminal output:</p> <pre><code>  DIRECTOR \u2502 Listening on /tmp/stepup-########/director (StepUp 2.0.4)\n   STARTUP \u2502 (Re)initialized boot script\n  DIRECTOR \u2502 Launched worker 0\n     PHASE \u2502 run\n     START \u2502 ./plan.py\n   SUCCESS \u2502 ./plan.py\n     START \u2502 echo hello &gt; a.txt\n   SUCCESS \u2502 echo hello &gt; a.txt\n   WARNING \u2502 2 step(s) remained pending due to blocked steps\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 Blocked steps \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nstep:cp -aT a.txt b.txt\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   WARNING \u2502 Skipping cleanup due to incomplete build.\n   WARNING \u2502 Check logs: .stepup/warning.log\n  DIRECTOR \u2502 Stopping workers.\n  DIRECTOR \u2502 See you!\n</code></pre>"},{"location":"advanced_topics/blocked_steps/#try-the-following","title":"Try the Following","text":"<ul> <li> <p>Unblock the copy step, run StepUp, block it again, and run StepUp again.   Although the copy commands are no longer executed, their outputs (<code>b.txt</code> and <code>c.txt</code>)   are not cleaned up.   This is the expected behavior because automatic cleaning is only performed when all   (non-optional) steps have been executed successfully.</p> </li> <li> <p>Unblock the copy step, run StepUp, and then make the last copy command optional.   In this case, the output of the optional step (<code>c.txt</code>) will be removed.</p> </li> </ul>"},{"location":"advanced_topics/cyclic_dependencies/","title":"Cyclic dependencies","text":"<p>Cyclic dependencies are defined in StepUp as closed loops in the dependency graph. Formally, such a loop is defined as a set of edges that can be followed from supplier to consumer, such that one arrives back at the starting point. If you construct cyclic dependencies in a <code>plan.py</code>, an error message is generated.</p> <p>In theory, one could also have cycles in the provenance graph, but it is not possible to create such loops with the functions in stepup.core.api.</p>"},{"location":"advanced_topics/cyclic_dependencies/#example","title":"Example","text":"<p>Create the following <code>plan.py</code>, which is StepUp\u2019s equivalent of a snake biting its own tail:</p> <pre><code>#!/usr/bin/env python3\nfrom stepup.core.api import copy\n\ncopy(\"a.txt\", \"b.txt\")\ncopy(\"b.txt\", \"a.txt\")\n</code></pre> <p>Make the plan executable and give it a try as follows:</p> <pre><code>chmod +x plan.py\nstepup -n 1\n</code></pre> <p>You will get the following terminal output showing that this plan won\u2019t work.</p> <pre><code>  DIRECTOR \u2502 Listening on /tmp/stepup-########/director (StepUp 2.0.4)\n   STARTUP \u2502 (Re)initialized boot script\n  DIRECTOR \u2502 Launched worker 0\n     PHASE \u2502 run\n     START \u2502 ./plan.py\n      FAIL \u2502 ./plan.py\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 Step info \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nCommand               ./plan.py\nReturn code           1\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 Standard error \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nTraceback (most recent call last):\n  File \"docs/advanced_topics/cyclic_dependencies/./plan.py\", line 5, in &lt;module&gt;\n    copy(\"b.txt\", \"a.txt\")\n    ~~~~^^^^^^^^^^^^^^^^^^\n  File \"stepup/core/api.py\", line 548, in copy\n    return step(\"cp -aT ${inp} ${out}\", inp=path_src, out=path_dst, optional=optional, block=block)\n  File \"stepup/core/api.py\", line 330, in step\n    RPC_CLIENT.call.step(\n    ~~~~~~~~~~~~~~~~~~~~^\n        _get_step_key(),\n        ^^^^^^^^^^^^^^^^\n    ...&lt;8 lines&gt;...\n        block,\n        ^^^^^^\n    )\n    ^\n  File \"stepup/core/rpc.py\", line 444, in __call__\n    _handle_error(body, name, args, kwargs)\n    ~~~~~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"stepup/core/rpc.py\", line 69, in _handle_error\n    raise RPCError(f\"An exception was raised in the server during the call {fmt_call}: \\n\\n{body}\")\nstepup.core.exceptions.RPCError: An exception was raised in the server during the call step('step:./plan.py', 'cp -aT b.txt a.txt', [Path('b.txt')], [], [Path('a.txt')], [], Path('./'), False, None, False):\nTraceback (most recent call last):\n  File \"stepup/core/rpc.py\", line 192, in _handle_request\n    result = await result\n             ^^^^^^^^^^^^\n  File \"stepup/core/director.py\", line 399, in step\n    self.workflow.define_step(\n    ~~~~~~~~~~~~~~~~~~~~~~~~~^\n        creator,\n        ^^^^^^^^\n    ...&lt;8 lines&gt;...\n        block=block,\n        ^^^^^^^^^^^^\n    )\n    ^\n  File \"stepup/core/workflow.py\", line 699, in define_step\n    file.add_supplier(step)\n    ~~~~~~~~~~~~~~~~~^^^^^^\n  File \"stepup/core/file.py\", line 135, in add_supplier\n    idep = super().add_supplier(supplier)\n  File \"stepup/core/cascade.py\", line 374, in add_supplier\n    raise CyclicError(\"New relation introduces a cyclic dependency\")\nstepup.core.exceptions.CyclicError: New relation introduces a cyclic dependency\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   WARNING \u2502 1 step(s) failed.\n   WARNING \u2502 1 step(s) remained pending due to incomplete requirements\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 Orphaned inputs \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n             AWAITED  a.txt\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 PENDING Step \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nCommand               cp -aT a.txt b.txt\nWorking directory     ./\nInputs        STATIC  ./\n             AWAITED  (a.txt)\nOutputs      AWAITED  b.txt\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   WARNING \u2502 Skipping cleanup due to incomplete build.\n   WARNING \u2502 Check logs: .stepup/fail.log .stepup/warning.log\n  DIRECTOR \u2502 Stopping workers.\n  DIRECTOR \u2502 See you!\n</code></pre>"},{"location":"advanced_topics/environment_variables/","title":"Environment Variables","text":"<p>When defining a step, one can specify the environment variables it uses (not their values). When restarting StepUp with a different value for any of these variables, StepUp will know that it has to rerun the step instead of skipping it, even if input files have not changed.</p> <p>One can only change an environment variable by stopping StepUp, changing the variable, and then starting StepUp again. One cannot modify environment variables while StepUp is running.</p>"},{"location":"advanced_topics/environment_variables/#example","title":"Example","text":"<p>Example source files: <code>docs/advanced_topics/environment_variables/</code></p> <p>Create the following <code>plan.py</code>:</p> <pre><code>#!/usr/bin/env python3\nfrom stepup.core.api import step\n\nstep(\"echo ${MYVAR}\", env=\"MYVAR\")\n</code></pre> <p>Make it executable and run StepUp with a specific value of the variable:</p> <pre><code>chmod +x plan.py\nMYVAR=foo stepup -n 1\n</code></pre> <p>You will see the following output:</p> <pre><code>  DIRECTOR \u2502 Listening on /tmp/stepup-########/director (StepUp 2.0.4)\n   STARTUP \u2502 (Re)initialized boot script\n  DIRECTOR \u2502 Launched worker 0\n     PHASE \u2502 run\n     START \u2502 ./plan.py\n   SUCCESS \u2502 ./plan.py\n     START \u2502 echo ${MYVAR}\n   SUCCESS \u2502 echo ${MYVAR}\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 Standard output \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nfoo\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n  DIRECTOR \u2502 Trying to delete 0 outdated output(s).\n  DIRECTOR \u2502 Stopping workers.\n  DIRECTOR \u2502 See you!\n</code></pre> <p>The variable substitution is performed in the subshell of the worker. StepUp will not try to substitute <code>${MYVAR}</code> before starting the step. The special variables <code>${inp}</code> and <code>${out}</code> are exceptions to this rule, as discussed in the tutorial on dependencies.</p>"},{"location":"advanced_topics/environment_variables/#try-the-following","title":"Try the Following","text":"<ul> <li> <p>Repeat <code>MYVAR=foo stepup -n 1</code> without making changes.   You will see that the <code>echo</code> step is skipped as expected.</p> </li> <li> <p>Now run <code>MYVAR=bar stepup -n 1</code>.   This time, the variable change will cause the step to be executed.</p> </li> </ul>"},{"location":"advanced_topics/environment_variables/#injecting-environment-variables","title":"Injecting Environment Variables","text":"<p>Besides working with external environment variables, you can also inject environment variables into the command of a step. For example:</p> <pre><code>msg = \"hello\"\nstep(f\"MESSAGE={msg} \" + \"echo ${MESSAGE}\")\n</code></pre> <p>Note that this is a different mechanism and it practically serves a different purpose. In this case, there is no point in add the argument <code>env=\"MESSAGE\"</code>, because this step will not be sensitive to the value of <code>MESSAGE</code> defined outside StepUp.</p>"},{"location":"advanced_topics/here_and_root/","title":"HERE and ROOT variables","text":"<p>When a worker runs a step, it defines several environment variables, including <code>HERE</code> and <code>ROOT</code>, which can be relevant for writing advanced scripts. (The workers also define variables starting with <code>STEPUP_</code>, but these are only useful to StepUp itself, not to end users.)</p> <p>The two variables are defined as follows:</p> <ul> <li><code>HERE</code> contains the relative path from the directory where StepUp was started   to the current working directory of the step.</li> <li><code>ROOT</code> contains the opposite: the relative directory from the current working directory   to the directory where StepUp was started.</li> </ul> <p>Hence, <code>HERE/ROOT</code> and <code>ROOT/HERE</code> normalize to the current directory: <code>./</code>.</p> <p>These variables can be useful in the following cases:</p> <ul> <li>For out-of-source builds, where you want to replicate the directory structure of the source material.   (See example below.)</li> <li>To reference a local script that is stored in the top-level directory of your project:   <code>${ROOT}/script.py</code></li> </ul>"},{"location":"advanced_topics/here_and_root/#example","title":"Example","text":"<p>Example source files: <code>docs/advanced_topics/here_and_root/</code></p> <p>This example represents a minimal out-of-source build, which is nevertheless involving several files, due to the inherent complexity of out-of-source builds.</p> <p>Create a <code>source/</code> directory with the following <code>source/plan.py</code>:</p> <pre><code>#!/usr/bin/env python3\nfrom stepup.core.api import mkdir, plan, static\n\nstatic(\"sub/\", \"sub/plan.py\")\nmkdir(\"../public/\")\nplan(\"sub/\")\n</code></pre> <p>Also create a <code>source/sub/</code> directory with a file <code>source/sub/example.txt</code> (arbitrary contents) and the following <code>source/sub/plan.py</code>:</p> <pre><code>#!/usr/bin/env python3\nfrom stepup.core.api import copy, mkdir, static\n\nstatic(\"example.txt\")\ndst = \"${ROOT}/../public/${HERE}/\"\nmkdir(dst)\ncopy(\"example.txt\", dst)\n</code></pre> <p>Make the scripts executable and run everything as follows:</p> <pre><code>chmod +x plan.py sub/plan.py\nstepup -n 1\n</code></pre> <p>You should get the following terminal output:</p> <pre><code>  DIRECTOR \u2502 Listening on /tmp/stepup-########/director (StepUp 2.0.4)\n   STARTUP \u2502 (Re)initialized boot script\n  DIRECTOR \u2502 Launched worker 0\n     PHASE \u2502 run\n     START \u2502 ./plan.py\n   SUCCESS \u2502 ./plan.py\n     START \u2502 mkdir -p ../public/\n   SUCCESS \u2502 mkdir -p ../public/\n     START \u2502 ./plan.py  # wd=sub/\n   SUCCESS \u2502 ./plan.py  # wd=sub/\n     START \u2502 mkdir -p ../../public/sub/  # wd=sub/\n   SUCCESS \u2502 mkdir -p ../../public/sub/  # wd=sub/\n     START \u2502 cp -aT example.txt ../../public/sub/example.txt  # wd=sub/\n   SUCCESS \u2502 cp -aT example.txt ../../public/sub/example.txt  # wd=sub/\n  DIRECTOR \u2502 Trying to delete 0 outdated output(s).\n  DIRECTOR \u2502 Stopping workers.\n  DIRECTOR \u2502 See you!\n</code></pre> <p>The top-level <code>plan.py</code> provides some infrastructure: some static files and creating the public directory where the outputs will be created.</p> <p>The script <code>sub/plan.py</code> uses the <code>ROOT</code> and <code>HERE</code> variables in a way that is independent of the location of this <code>sub/plan.py</code>. It may therefore be fixed in an environment variable, for example:</p> <pre><code>export DST='../public/${HERE}'\n</code></pre> <p>Then you can get this path in any <code>plan.py</code> as follows:</p> <pre><code>from stepup.core.api import getenv\ndst = getenv(\"DST\", back=True)\n</code></pre> <p>The <code>back=True</code> option implies that the variable is a path defined globally. If it is a relative path, it will be interpreted relative to the working directory where StepUp was started and will be translated to the working directory of the script calling <code>getenv()</code>. Any variables present in the environment variable will also be substituted once.</p>"},{"location":"advanced_topics/here_and_root/#try-the-following","title":"Try the Following","text":"<ul> <li> <p>Modify the scripts <code>plan.py</code> and <code>sub/plan.py</code> to utilize a <code>DST</code> variable as explained above.   To achieve this, define <code>DST</code> externally, for instance,   by starting StepUp as <code>DST='../public/${HERE}' stepup -n 1</code>.</p> </li> <li> <p>As a follow-up to the previous point, run StepUp with a different <code>DST</code> value.   For example: <code>DST='../out/${HERE}' stepup -n 1</code>.   You will see that all old output files get cleaned up after the new output is created.</p> </li> </ul>"},{"location":"advanced_topics/introduction/","title":"Introduction","text":"<p>The advanced topic tutorials are recommended after completing the \u201cGetting Started\u201d tutorials and gaining some hands-on experience with StepUp.</p> <p>The following tutorials are useful for larger build workflows with more specialized needs, as well as for developing domain-specific StepUp extensions.</p>"},{"location":"advanced_topics/manual_cleaning/","title":"Manual Cleaning","text":"<p>The automatic cleaning discussed in a previous tutorial is StepUp\u2019s default mechanism for removing irrelevant and unwanted files. In exceptional situations, the automatic cleaning may not be sufficient, and a more manual solution may be required. Examples of such situations are:</p> <ul> <li> <p>A dependency has changed that StepUp cannot track,   such as an upgrade of a system-wide tool used in your workflow.   In this situation, StepUp will not make the affected steps pending,   and you may want to remove the affected outputs to rebuild them.</p> </li> <li> <p>You are planning a rather drastic reorganization of your project,   including renaming some directories containing output files.   When directories are renamed,   StepUp can no longer clean up old outputs in the renamed directories.   In this situation, you will want to clean up outputs manually before renaming directories.</p> </li> </ul> <p>Simply removing outputs with the <code>rm</code> command is possible but quickly becomes tedious for larger projects. The <code>cleanup</code> program, a companion to <code>stepup</code>, can selectively remove numerous outputs with minimal end-user effort. You need to pass as arguments the files whose (indirect) outputs you want to remove. Such arguments can be one of the two things:</p> <ol> <li> <p>If a file is given, all outputs using this file as input will be removed.    Furthermore, if the file itself is also a build output, it will also be removed.</p> </li> <li> <p>If a directory is given, all outputs will be removed from this directory.    Furthermore, if the directory is created in the build, it will also be removed.</p> </li> </ol> <p>Files are removed recursively, so outputs of outputs are also cleaned up. <code>cleanup</code> will only remove files with status <code>OUTDATED</code>, <code>BUILT</code> or <code>VOLATILE</code>. <code>STATIC</code> or <code>AWAITED</code> files, i.e., files that are not the result of step execution, are never removed. In addition, <code>cleanup</code> compares the hash of a file to the last known hash, to make sure it only removes that contain changes made afterward without StepUp.</p> <p>By default, you need to run <code>cleanup</code> in the top-level directory where you also started <code>stepup</code>. This requirement can be lifted by defining the <code>STEPUP_ROOT</code> environment variable, as explained in the next tutorial.</p> <p>Note</p> <p>As StepUp 2.0.0, <code>cleanup</code> also works when <code>stepup</code> is not running.</p>"},{"location":"advanced_topics/manual_cleaning/#try-the-following","title":"Try the Following","text":"<ul> <li> <p>The Static Named Glob tutorial provides a good test case   for experimenting with <code>cleanup</code>.   For this example, run <code>stepup</code> without any arguments.   Then open a second terminal in the same directory and run <code>cleanup ch3/sec3_1_applications.txt</code>.   You will see that the following files have been deleted:</p> <ul> <li><code>ch3/sec3_1_applications.md</code></li> <li><code>public/ch3.md</code></li> </ul> </li> <li> <p>In the same way as in the previous point, try removing all outputs with <code>cleanup ./</code>.</p> </li> </ul>"},{"location":"advanced_topics/optional_steps/","title":"Optional Steps","text":"<p>By default, StepUp will build all steps. As an exception, steps can be made optional by adding the <code>optional=True</code> option. This is the opposite of most build tools, where steps are only executed when they are targets.</p> <p>The reason for this difference is that conventional build tools work with rigid predefined graphs. By accepting command-line arguments with target steps, they introduce some flexibility: this lets the user control which part of the graph is executed.</p> <p>StepUp offers such flexibility differently. The basic premise is that all outdated or missing outputs need to be (re)built. It is the responsibility of the build tool to figure out which steps need executing. This responsibility should not be shifted to users by expecting them to specify targets. That said, some legitimate exceptions exist, in which ignoring steps is a desirable feature. These are supported by StepUp as follows:</p> <ul> <li> <p>One can define steps conditionally, e.g.,   as in the tutorial Static Glob Conditional.   Such conditionals are controlled by external factors and   are picked up by your <code>plan.py</code> without manual interventions.</p> </li> <li> <p>One can make steps optional, as in this tutorial.   This is useful when multiple steps are defined in a loop,   as in the Static Glob tutorial,   of which not all steps are required for the end result.   Use this feature wisely:   It is obviously inefficient to define a few thousand steps of which only a handful are needed.</p> </li> <li> <p>As shown in the next tutorial, one may also block steps,   as a temporary measure to speed up the edit-build cycle.</p> </li> </ul> <p>Steps that define other steps, declare static files, or otherwise extend the workflow, should not be made optional. Until such steps are executed, StepUp has no idea what output these steps will generate, which it would need to decide that an optional step is required by another step.</p>"},{"location":"advanced_topics/optional_steps/#example","title":"Example","text":"<p>Example source files: <code>docs/advanced_topics/optional_steps/</code></p> <p>The example below uses the <code>script()</code> feature introduced in Script (Single Case) and Script (Multiple Cases) to create a somewhat entertaining example. However, practically all step-generating functions support the <code>optional</code> argument, and can thus be made optional in the same way.</p> <p>Create a first script <code>generate.py</code> that generates sequences of the logistic map for different values of the parameter r:</p> <pre><code>#!/usr/bin/env python3\nfrom stepup.core.script import driver\n\n\ndef cases():\n    yield 2.2\n    yield 2.8\n    yield 3.2\n    yield 3.8\n\n\nCASE_FMT = \"logmap_{:5.3f}\"\n\n\ndef case_info(r):\n    return {\"out\": f\"logmap_{r:5.3f}.txt\", \"r\": r}\n\n\ndef run(out, r):\n    x = 0.1\n    with open(out, \"w\") as fh:\n        for _ in range(100):\n            print(f\"{x:10.5f}\", file=fh)\n            x = r * x * (1 - x)\n\n\nif __name__ == \"__main__\":\n    driver()\n</code></pre> <p>Then, write a <code>plot.py</code> script that plots only one of these sequences:</p> <pre><code>#!/usr/bin/env python3\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nfrom stepup.core.script import driver\n\n\ndef info():\n    r = 3.2\n    return {\n        \"inp\": [\"matplotlibrc\", f\"logmap_{r:5.3f}.txt\"],\n        \"out\": \"plot_logmap.png\",\n    }\n\n\ndef run(inp, out):\n    mpl.rc_file(inp[0])\n    seq = np.loadtxt(inp[1])\n    fig, ax = plt.subplots()\n    ax.plot(seq)\n    ax.set_xlabel(\"n\")\n    ax.set_ylabel(\"x_n\")\n    fig.savefig(out)\n\n\nif __name__ == \"__main__\":\n    driver()\n</code></pre> <p>The <code>plan.py</code> file adds steps for both scripts, but makes the data generation optional:</p> <pre><code>#!/usr/bin/env python3\nfrom stepup.core.api import script, static\n\nstatic(\"generate.py\", \"plot.py\", \"matplotlibrc\")\nscript(\"generate.py\", optional=True)\nscript(\"plot.py\")\n</code></pre> <p>Finally, make the scripts executable and run StepUp:</p> <pre><code>chmod +x generate.py plot.py plan.py\nstepup -n 1\n</code></pre> <p>You should get the following output:</p> <pre><code>  DIRECTOR \u2502 Listening on /tmp/stepup-########/director (StepUp 2.0.4)\n   STARTUP \u2502 (Re)initialized boot script\n  DIRECTOR \u2502 Launched worker 0\n     PHASE \u2502 run\n     START \u2502 ./plan.py\n   SUCCESS \u2502 ./plan.py\n     START \u2502 ./generate.py plan --optional\n   SUCCESS \u2502 ./generate.py plan --optional\n     START \u2502 ./plot.py plan\n   SUCCESS \u2502 ./plot.py plan\n     START \u2502 ./generate.py run -- logmap_3.200\n   SUCCESS \u2502 ./generate.py run -- logmap_3.200\n     START \u2502 ./plot.py run\n   SUCCESS \u2502 ./plot.py run\n  DIRECTOR \u2502 Trying to delete 0 outdated output(s).\n  DIRECTOR \u2502 Stopping workers.\n  DIRECTOR \u2502 See you!\n</code></pre> <p>Note that, in this case, it would be trivial to modify the <code>generate.py</code> script to only generate the sequence of interest. Whenever such a simpler approach is possible, it is always preferable. However, in more complex use cases, it is not always possible to figure out which steps are going to be needed or not. In such situations, optional steps can be convenient.</p>"},{"location":"advanced_topics/optional_steps/#try-the-following","title":"Try the Following","text":"<ul> <li> <p>Remove the <code>optional=True</code> keyword argument and rerun the plan.   As expected, additional text files with sequences will be created.</p> </li> <li> <p>Restore the <code>optional=True</code> keyword argument and rerun the plan.   As expected, the Automatic Cleaning feature   removes the outputs that were generated by steps that are no longer present in the workflow.</p> </li> </ul>"},{"location":"advanced_topics/pools/","title":"Pools","text":"<p>It is nearly always preferred to run steps in parallel when possible, so StepUp will launch any queued step as soon as a worker becomes available. A \u201cpool\u201d is a simple mechanism to limit parallelization in the few cases that this would be counterproductive:</p> <ol> <li> <p>Some programs behave poorly (have bugs) when multiple instances are running in parallel.    Here are a few examples encountered in the development of StepUp RepRep:</p> <ul> <li>Inkscape/issue4716</li> <li>markdown-katex/issue16</li> </ul> </li> <li> <p>Some steps may consume a lot of resources, such as memory,    and would require more resources than available when running in parallel.</p> </li> <li> <p>Software licenses may not allow for more than a given number of instances running in parallel.</p> </li> </ol> <p>One defines a pool with <code>pool(name, size)</code>. The size is the maximum number of steps running concurrently within the pool. Steps are assigned to a pool by defining them with the <code>pool=name</code> keyword argument.</p> <p>For StepUp, mainly the first use case (working around concurrency bugs) is relevant, for which the pool size is 1.</p>"},{"location":"advanced_topics/pools/#example","title":"Example","text":"<p>Example source files: <code>docs/advanced_topics/pools/</code></p> <p>The example here illustrates the use of a pool in a simple test case. The steps can run easily in parallel, so you can experiment with the pool size.</p> <p>Create the following <code>plan.py</code>:</p> <pre><code>#!/usr/bin/env python3\nfrom stepup.core.api import pool, step\n\npool(\"test\", 2)\nstep(\"sleep 0.1; echo A\", pool=\"test\")\nstep(\"sleep 0.1; echo B\", pool=\"test\")\nstep(\"sleep 0.1; echo C\", pool=\"test\")\n</code></pre> <p>The <code>sleep</code> command ensures that each step lasts long enough to guarantee they will run in parallel when allowed.</p> <p>Make the plan executable and run it with StepUp:</p> <pre><code>chmod +x plan.py\nstepup -n 4\n</code></pre> <p>You should get the following output:</p> <pre><code>  DIRECTOR \u2502 Listening on /tmp/stepup-########/director (StepUp 2.0.4)\n   STARTUP \u2502 (Re)initialized boot script\n  DIRECTOR \u2502 Launched worker 0\n  DIRECTOR \u2502 Launched worker 1\n  DIRECTOR \u2502 Launched worker 2\n  DIRECTOR \u2502 Launched worker 3\n     PHASE \u2502 run\n     START \u2502 ./plan.py\n     START \u2502 sleep 0.1; echo A\n     START \u2502 sleep 0.1; echo B\n   SUCCESS \u2502 ./plan.py\n   SUCCESS \u2502 sleep 0.1; echo A\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 Standard output \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nA\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   SUCCESS \u2502 sleep 0.1; echo B\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 Standard output \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nB\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n     START \u2502 sleep 0.1; echo C\n   SUCCESS \u2502 sleep 0.1; echo C\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 Standard output \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nC\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n  DIRECTOR \u2502 Trying to delete 0 outdated output(s).\n  DIRECTOR \u2502 Stopping workers.\n  DIRECTOR \u2502 See you!\n</code></pre> <p>Initially, the <code>./plan.py</code> step and two <code>sleep+echo</code> commands are running in parallel. Despite having four workers, the third <code>sleep+echo</code> is only started after the previous two have finished.</p>"},{"location":"advanced_topics/pools/#try-the-following","title":"Try the Following","text":"<ul> <li> <p>Run <code>stepup -n 4</code> again without making changes.   Skipping of steps requires some computation and comparison of hashes,   which is done by worker processes.   However, these hash computations are never subject to pool size restrictions.</p> </li> <li> <p>Change the pool size to <code>1</code> or <code>3</code> and verify that the output matches your expectations.   When you try this, StepUp will continue skipping steps.   To forcibly re-execute steps, you can remove the file <code>.stepup/graph.db</code> and restart StepUp.</p> </li> </ul>"},{"location":"advanced_topics/static_deferred_glob/","title":"Static Deferred Glob","text":"<p>When dealing with massive datasets comprising tens of thousands of files, it doesn\u2019t make sense to render all of them as static when only a handful will actually be utilized. StepUp addresses this issue with the deferred glob feature, which makes previously unknown files static when:</p> <ol> <li>they are used as inputs of a new step and</li> <li>they match a deferred glob pattern.</li> </ol>"},{"location":"advanced_topics/static_deferred_glob/#example","title":"Example","text":"<p>Example source files: <code>docs/advanced_topics/static_deferred_glob/</code></p> <p>Create two text files with some content: <code>foo.txt</code> and <code>bar.txt</code>, and also the following <code>plan.py</code>:</p> <pre><code>#!/usr/bin/env python3\nfrom stepup.core.api import glob, step\nfrom stepup.core.interact import graph\n\nglob(\"*.txt\", _defer=True)\nstep(\"cat foo.txt\", inp=\"foo.txt\")\ngraph(\"graph\")\n</code></pre> <p>Run the plan interactively with StepUp:</p> <pre><code>chmod +x plan.py\nstepup -n 1\n</code></pre> <p>You should get the following screen output:</p> <pre><code>  DIRECTOR \u2502 Listening on /tmp/stepup-########/director (StepUp 2.0.4)\n   STARTUP \u2502 (Re)initialized boot script\n  DIRECTOR \u2502 Launched worker 0\n     PHASE \u2502 run\n     START \u2502 ./plan.py\n   SUCCESS \u2502 ./plan.py\n     START \u2502 cat foo.txt\n   SUCCESS \u2502 cat foo.txt\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 Standard output \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nThis is foo.\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n  DIRECTOR \u2502 Trying to delete 0 outdated output(s).\n  DIRECTOR \u2502 Stopping workers.\n  DIRECTOR \u2502 See you!\n</code></pre> <p>As expected, <code>foo.txt</code> is used as a static file. Of course, this would also have been the case without the <code>_defer=True</code> option. The key difference is that with <code>_defer=True</code>, StepUp does not create a list of all matching <code>*.txt</code> files. This can be seen when examining the file <code>graph.txt</code>, which has no trace of <code>bar.txt</code>:</p> <pre><code>root:\n             creates   file:./\n             creates   file:plan.py\n             creates   step:./plan.py\n\nfile:plan.py\n               state = STATIC\n              digest = e9a2826e 1262a2a9 8b01a7e8 cc5a1e13 b1fd2bb7 5233efc6 14ad6e42 5f4c9ff2\n                     = d79dc863 ccd12e12 e7aa11a3 93d037fc a5cec13f 44f7e0ce 70381bfb 8eb624f6\n          created by   root:\n            consumes   file:./\n            supplies   step:./plan.py\n\nfile:./\n               state = STATIC\n          created by   root:\n            supplies   file:foo.txt\n            supplies   file:plan.py\n            supplies   step:./plan.py\n            supplies   step:cat foo.txt\n\nstep:./plan.py\n               state = RUNNING\n          created by   root:\n            consumes   file:./\n            consumes   file:plan.py\n             creates   dg:*.txt\n             creates   step:cat foo.txt\n\ndg:*.txt\n          created by   step:./plan.py\n             creates   file:foo.txt\n\nfile:foo.txt\n               state = STATIC\n              digest = 0c64fa0d 9b93cfe0 46d049cd 30640438 385cec99 cf27db48 ad87ebb0 0f9d727d\n                     = 646e46e6 ded92d12 458876d7 ba4f147d 6401a78e ffb2f12d 0595392c 89cf2784\n          created by   dg:*.txt\n            consumes   file:./\n            supplies   step:cat foo.txt\n\nstep:cat foo.txt\n               state = QUEUED\n          created by   step:./plan.py\n            consumes   file:./\n            consumes   file:foo.txt\n</code></pre> <p>The node <code>dg:'*.txt;</code> in the graph (green octagon in the figures below) is the result of adding the <code>_defer=True</code> option. This node will create static files as they are needed by other steps. The deferred glob is ideal when there are a large number of files that could match the pattern, of which most are irrelevant for the build. For example, there could be thousands of <code>.txt</code> files in this scenario, but this would not have any effect on the resources consumed by StepUp.</p> <p>The dependency graph:</p> <p></p> <p>The provenance graph:</p> <p></p>"},{"location":"advanced_topics/static_deferred_glob/#try-the-following","title":"Try the Following","text":"<ul> <li> <p>When using deferred globs, steps cannot create outputs that match the deferred glob.   This would mean that a built file could be made static when used as input later,   which is clearly inconsistent.   Try causing this error by adding a step <code>copy(\"foo.txt\", \"foo2.txt\")</code>.</p> </li> <li> <p>Remove the <code>_defer=True</code> option and inspect the corresponding <code>graph.txt</code>.   You should see that <code>bar.txt</code> is now indeed included in the graph.</p> </li> </ul>"},{"location":"advanced_topics/static_named_glob/","title":"Static Named Glob","text":"<p>Conventional glob patterns support a handful of different wildcards. For advanced use cases, StepUp also supports an in-house extension called \u201cnamed glob\u201d. For example, the following pattern will only match files with matching strings at the placeholders.</p> <pre><code>prefix_${*name}_something_${*name}.txt\n</code></pre> <p>The following will match:</p> <pre><code>prefix_aaa_something_aaa.txt\nprefix_bbb_something_bbb.txt\n</code></pre> <p>The following won\u2019t:</p> <pre><code>prefix_aaa_something_bbb.txt\nprefix_bbb_something_aaa.txt\n</code></pre> <p>Named globs are often useful when working with files distributed over multiple directories, each having a central file that repeats a part of the directory name.</p>"},{"location":"advanced_topics/static_named_glob/#example","title":"Example","text":"<p>Example source files: <code>docs/advanced_topics/static_named_glob/</code></p> <p>In the example below, each directory represents a chapter from course notes, containing source files for individual sections. In a realistic setting, one could envision building a PDF presentations from LaTeX sources instead. To keep the example independent of StepUp RepRep, text files will be copied to Markdown files, which will then be concatenated.</p> <p>Create the following directory layout with markdown files:</p> <pre><code>ch1/\nch1/sec1_1_introduction.txt\nch1/sec1_2_objectives.txt\nch2/\nch2/sec2_1_mathematical_requisites.txt\nch2/sec2_2_theory.txt\nch3/\nch3/sec3_1_applications.txt\nch3/sec3_2_discussion.txt\nch4/sec4_1_summary.txt\n</code></pre> <p>Create the following <code>plan.py</code>:</p> <pre><code>#!/usr/bin/env python3\nfrom stepup.core.api import copy, glob, mkdir, step\n\n# Make all chapter directories static\nglob(\"ch*/\")\n\n# Enforce consistent chapter numbers throughout the match,\n# ignoring inconsistent txt files.\nmd_chapter = {}\nfor match in glob(\"ch${*ch}/sec${*ch}_${*sec}_${*name}.txt\", ch=\"[0-9]\", sec=\"[0-9]\"):\n    path_txt = match.single\n    path_md = path_txt[:-3] + \"md\"\n    copy(path_txt, path_md)\n    md_chapter.setdefault(match.ch, []).append(path_md)\n\n# Concatenate all markdown files per chapter\nmkdir(\"public/\")\nfor ch, paths_md in md_chapter.items():\n    step(\"cat ${inp} &gt; ${out}\", inp=paths_md, out=f\"public/ch{ch}.md\")\n</code></pre> <p>Note that the substrings matching the named glob patterns are accessible as attributes of the <code>NGlobMatch</code> object. For example, <code>match.ch</code> is the chapter number (as a string).</p> <p>Make the plan executable and run StepUp:</p> <pre><code>chmod +x plan.py\nstepup -n 1\n</code></pre> <p>You should get the following output:</p> <pre><code>  DIRECTOR \u2502 Listening on /tmp/stepup-########/director (StepUp 2.0.4)\n   STARTUP \u2502 (Re)initialized boot script\n  DIRECTOR \u2502 Launched worker 0\n     PHASE \u2502 run\n     START \u2502 ./plan.py\n   SUCCESS \u2502 ./plan.py\n     START \u2502 cp -aT ch1/sec1_1_introduction.txt ch1/sec1_1_introduction.md\n   SUCCESS \u2502 cp -aT ch1/sec1_1_introduction.txt ch1/sec1_1_introduction.md\n     START \u2502 cp -aT ch1/sec1_2_objectives.txt ch1/sec1_2_objectives.md\n   SUCCESS \u2502 cp -aT ch1/sec1_2_objectives.txt ch1/sec1_2_objectives.md\n     START \u2502 cp -aT ch2/sec2_1_mathematical_requisites.txt ch2/sec2_1_mathematical_requisites.md\n   SUCCESS \u2502 cp -aT ch2/sec2_1_mathematical_requisites.txt ch2/sec2_1_mathematical_requisites.md\n     START \u2502 cp -aT ch2/sec2_2_theory.txt ch2/sec2_2_theory.md\n   SUCCESS \u2502 cp -aT ch2/sec2_2_theory.txt ch2/sec2_2_theory.md\n     START \u2502 cp -aT ch3/sec3_1_applications.txt ch3/sec3_1_applications.md\n   SUCCESS \u2502 cp -aT ch3/sec3_1_applications.txt ch3/sec3_1_applications.md\n     START \u2502 cp -aT ch3/sec3_2_discussion.txt ch3/sec3_2_discussion.md\n   SUCCESS \u2502 cp -aT ch3/sec3_2_discussion.txt ch3/sec3_2_discussion.md\n     START \u2502 cp -aT ch4/sec4_1_summary.txt ch4/sec4_1_summary.md\n   SUCCESS \u2502 cp -aT ch4/sec4_1_summary.txt ch4/sec4_1_summary.md\n     START \u2502 mkdir -p public/\n   SUCCESS \u2502 mkdir -p public/\n     START \u2502 cat ch1/sec1_1_introduction.md ch1/sec1_2_objectives.md &gt; public/ch1.md\n   SUCCESS \u2502 cat ch1/sec1_1_introduction.md ch1/sec1_2_objectives.md &gt; public/ch1.md\n     START \u2502 cat ch2/sec2_1_mathematical_requisites.md ch2/sec2_2_theory.md &gt; public/ch2.md\n   SUCCESS \u2502 cat ch2/sec2_1_mathematical_requisites.md ch2/sec2_2_theory.md &gt; public/ch2.md\n     START \u2502 cat ch3/sec3_1_applications.md ch3/sec3_2_discussion.md &gt; public/ch3.md\n   SUCCESS \u2502 cat ch3/sec3_1_applications.md ch3/sec3_2_discussion.md &gt; public/ch3.md\n     START \u2502 cat ch4/sec4_1_summary.md &gt; public/ch4.md\n   SUCCESS \u2502 cat ch4/sec4_1_summary.md &gt; public/ch4.md\n  DIRECTOR \u2502 Trying to delete 0 outdated output(s).\n  DIRECTOR \u2502 Stopping workers.\n  DIRECTOR \u2502 See you!\n</code></pre>"},{"location":"advanced_topics/step_info/","title":"StepInfo objects","text":"<p>Note</p> <p>This feature was introduced in StepUp 1.3.0.</p> <p>The <code>step()</code> function always return an instance of <code>StepInfo</code>. This object holds arguments used to define the step, which may be useful for creating follow-up steps. All API functions that create a step by calling the <code>step()</code> function also return the <code>StepInfo</code> object.</p> <p>Especially for higher-level API functions that create more advanced steps, such as the ones in StepUp RepRep, it can be convenient to access the paths constructed inside the API function instead of reconstructing them manually in your <code>plan.py</code> script.</p> <p>The <code>StepInfo</code> object has <code>inp</code>, <code>env</code>, <code>out</code> and <code>vol</code> attributes, corresponding to the arguments passed into the <code>step()</code> function. The main difference to the arguments passed in, is that environment variables are substituted in the paths.</p> <p>In addition, <code>StepInfo</code> has three methods: <code>filter_inp()</code>, <code>filter_out()</code> and <code>filter_vol()</code>, which can be used to get a subset of paths. These functions take the same arguments as those of the <code>glob()</code> function and also return an <code>NGlobMulti</code> instance.</p> <p>Note that the <code>StepInfo</code> object will only contain information known at the time the step is defined. Amended information (inputs, outputs, \u2026) cannot be retrieved from <code>StepInfo</code> objects. Also note that relative paths in <code>inp</code>, <code>out</code> and <code>vol</code> are relative to the working directory.</p>"},{"location":"advanced_topics/step_info/#example","title":"Example","text":"<p>Let\u2019s assume you are using a library with an API function <code>create_fancy_pdf</code>, which takes a source directory as input and outputs a PDF file. (This is a hypothetical example for illustrative purposes.) You can find the full list of inputs and the output as follows:</p> <pre><code>from stepup.core.api import static, copy\nfrom stepup.fancy.api import create_fancy_pdf  # hypothetical API function\n\n# Plan the creation of the fancy PDF\nstatic(\"source/\")\nglob(\"source/**\", _defer=True)\ninfo = create_fancy_pdf(\"source/\")\n\n# Copy files related to the fancy PDF, e.g. to publish them or back up files.\nmkdir(\"../public\")\ncopy(info.filter_out(\"*.pdf\").single, \"../public/\")\nmkdir(\"../backup\")\nfor path_inp in info.inp:\n    copy(path_inp, \"../backup\")\n</code></pre>"},{"location":"advanced_topics/stepup_root/","title":"The STEPUP_ROOT variable","text":"<p>If you are working on a large project with several subdirectories, it may be useful to define the <code>STEPUP_ROOT</code> environment variable. It should contain the absolute path of the top-level directory where you would normally call the <code>stepup</code> and <code>cleanup</code> commands. (The top-level directory contains the <code>.stepup</code> subdirectory and the top-level <code>plan.py</code>.)</p> <p>With <code>STEPUP_ROOT</code> set, it is no longer necessary to change to the top-level directory before running <code>stepup</code> and <code>cleanup</code>. Also, the <code>cleanup</code> arguments will be interpreted correctly in subdirectories.</p> <p>You can manually set <code>STEPUP_ROOT</code> in the top-level directory as follows:</p> <pre><code>export STEPUP_ROOT=\"${PWD}\"\n</code></pre> <p>However, this can be tedious, as it has to be set each time you open a new terminal window. It is much easier to set such variables using direnv. Once direnv is configured on your system, you can create an <code>.envrc</code> file with the above <code>export</code> line in the top-level directory. Each time you change to the project directory or any of its subdirectories, the <code>STEPUP_ROOT</code> directory will automatically be set correctly.</p>"},{"location":"advanced_topics/variable_substitution/","title":"Variable Substitution","text":"<p>StepUp does not substitute environment variables in the command (first argument) of the <code>step()</code> function. As discussed in the tutorial on environment variables, the executing shell takes care of such substitutions.</p> <p>However, environment variables in all path-like arguments (e.g. <code>workdir</code>, <code>inp</code>, <code>out</code> and <code>vol</code>) of functions that take such arguments (<code>step()</code>, <code>amend()</code> etc.) are automatically substituted. This substitution takes place before the commands are sent to the director process and all used variables are communicated to the director with an <code>amend()</code> call.</p> <p>If a script needs an environment variable elsewhere, the function <code>getenv()</code> is recommended: It returns the value of the variable and calls <code>amend()</code> to tell the director that the current step depends on this variable.</p>"},{"location":"advanced_topics/variable_substitution/#example","title":"Example","text":"<p>Example source files: <code>docs/advanced_topics/variable_substitution/</code></p> <p>Create a <code>plan.py</code> with the following contents:</p> <pre><code>#!/usr/bin/env python3\nfrom stepup.core.api import static, step\n\nstatic(\"step.py\", \"src_${MYVAR}.txt\")\nstep(\"./step.py &lt; ${inp} &gt; ${out}\", inp=\"src_${MYVAR}.txt\", out=\"dst_${MYVAR}.txt\")\n</code></pre> <p>In addition, create a script <code>step.py</code> as follows:</p> <pre><code>#!/usr/bin/env python3\nimport sys\n\nfrom stepup.core.api import getenv\n\nmyname = repr(getenv(\"MYNUM\"))\nprint(f\"MYNUM={myname}\\n\")\nprint(\"Read from stdin:\")\nprint(sys.stdin.read())\n</code></pre> <p>Make the Python scripts executable and run them as follows:</p> <pre><code>chmod +x plan.py step.py\nMYVAR=foo stepup -n 1\n</code></pre> <p>You should get the following terminal output:</p> <pre><code>  DIRECTOR \u2502 Listening on /tmp/stepup-########/director (StepUp 2.0.4)\n   STARTUP \u2502 (Re)initialized boot script\n  DIRECTOR \u2502 Launched worker 0\n     PHASE \u2502 run\n     START \u2502 ./plan.py\n   SUCCESS \u2502 ./plan.py\n     START \u2502 ./step.py &lt; src_foo.txt &gt; dst_foo.txt\n   SUCCESS \u2502 ./step.py &lt; src_foo.txt &gt; dst_foo.txt\n  DIRECTOR \u2502 Trying to delete 0 outdated output(s).\n  DIRECTOR \u2502 Stopping workers.\n  DIRECTOR \u2502 See you!\n</code></pre> <p>The file <code>dst_foo.txt</code> will contain the following:</p> <pre><code>MYNUM=None\n\nRead from stdin:\nThis is src_foo\n</code></pre> <p>As shown in this example, the function <code>getenv()</code> returns <code>None</code> when a variable does not exist (or any other default you specify). When using variables like <code>${MYVAR}</code> in path-like arguments, the variable must exist or an exception is raised.</p>"},{"location":"advanced_topics/variable_substitution/#try-the-following","title":"Try the Following","text":"<ul> <li>Run StepUp without defining <code>MYVAR</code>: <code>stepup -n 1</code>.   As explained above, this raises an exception.</li> <li>Run StepUp by also defining <code>MYNUM</code>: <code>MYVAR=foo MYNUM=1 stepup -n 1</code>.   Now the string <code>'1'</code> is shown in the output <code>dst_foo.txt</code>.   Note that environment variables are always strings, and need to be converted to other types if needed.</li> </ul>"},{"location":"advanced_topics/volatile_outputs/","title":"Volatile Outputs","text":"<p>It may happen that steps produce auxiliary outputs that are not really of interest, but rather occur as a side effect. For example, LaTeX is notoriously productive in terms of output files. Some of these files will change with every run, e.g., because they contain timestamps.</p> <p>It is useful to inform StepUp of the existence of such volatile files, so they can be cleaned up when appropriate. However, there is no point in computing file hashes for them, as these files are not used as inputs later and may change for no good reason. One may pass a list of such files to the <code>vol</code> argument of the <code>step()</code> function.</p>"},{"location":"advanced_topics/volatile_outputs/#example","title":"Example","text":"<p>Example source files: <code>docs/advanced_topics/volatile_outputs/</code></p> <p>Create the following <code>plan.py</code>, with a single step that produces a trivially volatile output:</p> <pre><code>#!/usr/bin/env python3\nfrom stepup.core.api import step\n\nstep(\"date &gt; date.txt\", vol=\"date.txt\")\n</code></pre> <p>Make the plan executable and run it as follows:</p> <pre><code>chmod +x plan.py\nstepup -n 1\n</code></pre> <p>The file <code>date.txt</code> will contain the current time. You should get the following terminal output:</p> <pre><code>  DIRECTOR \u2502 Listening on /tmp/stepup-########/director (StepUp 2.0.4)\n   STARTUP \u2502 (Re)initialized boot script\n  DIRECTOR \u2502 Launched worker 0\n     PHASE \u2502 run\n     START \u2502 ./plan.py\n   SUCCESS \u2502 ./plan.py\n     START \u2502 date &gt; date.txt\n   SUCCESS \u2502 date &gt; date.txt\n  DIRECTOR \u2502 Trying to delete 0 outdated output(s).\n  DIRECTOR \u2502 Stopping workers.\n  DIRECTOR \u2502 See you!\n</code></pre>"},{"location":"advanced_topics/volatile_outputs/#try-the-following","title":"Try the Following","text":"<ul> <li> <p>Remove the file <code>date.txt</code> and run StepUp again.   You will see that the step gets ignored:   StepUp does not care much about the state of volatile files.   It only keeps track of them, so they can be removed when needed.</p> </li> <li> <p>Manually recreate the file <code>date.txt</code> with some arbitrary contents,   and run StepUp.   Again, the step gets skipped because the contents of the   volatile <code>date.txt</code> are not considered when deciding if a step is outdated.</p> </li> <li> <p>Comment out the step in <code>plan.py</code> and run StepUp again.   Because the step is removed, the volatile output is also removed.</p> </li> </ul>"},{"location":"getting_started/automatic_cleaning/","title":"Automatic Cleaning","text":"<p>StepUp follows the same cleanup strategy as tup: If a step is removed or modified so that an output file is no longer created, StepUp will remove this output. This is also similar to Ninja\u2019s <code>cleandead</code> command, but it is not optional in StepUp.</p> <p>The main advantage of automatic cleaning is that it eliminates potential bugs and confusion related to old output files that are no longer relevant.</p>"},{"location":"getting_started/automatic_cleaning/#try-the-following","title":"Try the Following","text":"<p>To illustrate the automatic cleanup, take the files from the example Copy and mkdir and start StepUp in interactive mode. Make the following changes and rerun the affected steps after each point by pressing <code>r</code> in the terminal:</p> <ul> <li> <p>Change the directory <code>sub/</code> to <code>foo/</code> in <code>plan.py</code>.   Rerunning StepUp will not only create <code>foo/</code> and <code>foo/hello.txt</code>.   After completing all pending steps, <code>sub/</code> and <code>sub/hello.txt</code> are removed.</p> </li> <li> <p>Change all occurrences of <code>hello.txt</code> in <code>plan.py</code> to <code>hi.txt</code>.   Rerunning StepUp will not only create <code>hi.txt</code> and <code>foo/hi.txt</code>.   After completing all pending steps, <code>hello.txt</code> and <code>foo/hello.txt</code> are removed.</p> </li> <li> <p>Undo all changes and rerun StepUp again.   You should end up with the original outputs without any leftovers from the previous two steps.</p> </li> </ul>"},{"location":"getting_started/call/","title":"Function calls","text":"<p>Note</p> <p>This feature was introduced in StepUp 2.0.0.</p> <p>Warning</p> <p>This feature is experimental and may change significantly in future 2.x releases.</p> <p>The <code>call()</code> function is a function wrapper for local executable scripts. These scripts can be written in any language, as long as they adhere to the \u201ccall protocol\u201d described below. StepUp provides a <code>driver()</code> function in the module <code>stepup.core.call</code> to facilitate the implementation of Python scripts that adhere to the call protocol.</p>"},{"location":"getting_started/call/#call-protocol","title":"Call protocol","text":"<p>In its simplest form, the following use of <code>call()</code> in a <code>plan.py</code> script</p> <pre><code>call(\"executable\", parameter=\"value\")\n</code></pre> <p>is roughly equivalent to</p> <pre><code>step(\"./executable '{\\\"parameter\\\": \\\"value\\\"}'\", inp=\"executable\")\n</code></pre> <p>(It also works without any parameters.) The script <code>executable</code> is expected to decode the JSON given on the command-line, and then use these parameters.</p> <p>The <code>call()</code> function supports many optional arguments that control with which options the executable is called. In a nutshell, the parameters can also be provided through an input file. By default, this is a JSON file, but PICKLE is provided as a fallback in case the types of the parameters are not compatible with JSON. When the executable script produces a \u201creturn value\u201d, it should write this to an output file, either in JSON or PICKLE format.</p> <p>Because of the delayed execution, the <code>call()</code> function cannot return this value. If you are familiar with Python\u2019s builtin <code>concurrent.futures</code> module, you can think of the output file of the script as the <code>Future</code> object that is returned by <code>concurrent.futures.Executor.submit()</code>. The <code>call()</code> function returns a <code>StepInfo</code> object from which you can extract the output file path.</p> <p>To fully support the <code>call()</code> protocol, the executable must be able to handle the following command-line arguments:</p> <ul> <li><code>JSON_INP</code>:   The JSON-encoded parameters.</li> <li><code>--inp=PATH_INP</code>:   As an alternative to the previous, a file with parameters in JSON or PICKLE format.</li> <li><code>--out=PATH_OUT</code>:   The output file to use (if there is a return value), either in JSON or PICKLE format.</li> <li><code>--amend-out</code>:   If given, the executable must call <code>amend(out=PATH_OUT)</code> before writing the output file.</li> </ul>"},{"location":"getting_started/call/#call-driver","title":"Call driver","text":"<p>StepUp implements a <code>driver()</code> function in the module <code>stepup.core.call</code> that greatly facilitates writing Python scripts that adhere to the call protocol. The usage of this <code>driver()</code> function is illustrated in the example below.</p> <p>Note that the <code>driver()</code> function also detects local modules that are imported in the script, and amends these as required inputs. Changes to modules imported in your Python script will automatically trigger a re-run of the script. By default, only the modules inside <code>STEPUP_ROOT</code> are treated as dependencies. You can specify additional directories in the <code>STEPUP_EXTERNAL_SOURCES</code> environment variable.</p>"},{"location":"getting_started/call/#example","title":"Example","text":"<p>Example source files: <code>docs/getting_started/call/</code></p> <p>First create a <code>wavegen.py</code> script as follows:</p> <pre><code>#!/usr/bin/env python3\nfrom math import pi, sin\n\nfrom stepup.core.call import driver\n\n\ndef run(freq: float, duration: float, rate: int = 44100):\n    \"\"\"Generate a sine wave with given frequency, duration, and sample rate.\"\"\"\n    return [sin(2 * pi * freq * i / rate) for i in range(int(duration * rate))]\n\n\nif __name__ == \"__main__\":\n    driver()\n</code></pre> <p>Then create a <code>plan.py</code> script as follows:</p> <pre><code>#!/usr/bin/env python3\nfrom stepup.core.api import call, static\n\nstatic(\"wavegen.py\")\ncall(\"wavegen.py\", out=\"wave1.json\", freq=440.0, duration=1.0)\ncall(\"wavegen.py\", out=\"wave2.json\", freq=380.0, duration=0.5, rate=22050)\n</code></pre> <p>Finally, make the Python scripts executable and start StepUp:</p> <pre><code>chmod +x wavegen.py plan.py\nstepup -n 1\n</code></pre> <p>You should see the following output on screen:</p> <pre><code>  DIRECTOR \u2502 Listening on /tmp/stepup-########/director (StepUp 2.0.4)\n   STARTUP \u2502 (Re)initialized boot script\n  DIRECTOR \u2502 Launched worker 0\n     PHASE \u2502 run\n     START \u2502 ./plan.py\n   SUCCESS \u2502 ./plan.py\n     START \u2502 ./wavegen.py '{\"freq\": 440.0, \"duration\": 1.0}' --out=wave1.json\n   SUCCESS \u2502 ./wavegen.py '{\"freq\": 440.0, \"duration\": 1.0}' --out=wave1.json\n     START \u2502 ./wavegen.py '{\"freq\": 380.0, \"duration\": 0.5, \"rate\": 22050}' --out=wave2.json\n   SUCCESS \u2502 ./wavegen.py '{\"freq\": 380.0, \"duration\": 0.5, \"rate\": 22050}' --out=wave2.json\n  DIRECTOR \u2502 Trying to delete 0 outdated output(s).\n  DIRECTOR \u2502 Stopping workers.\n  DIRECTOR \u2502 See you!\n</code></pre>"},{"location":"getting_started/call/#practical-considerations","title":"Practical considerations","text":"<ul> <li>As shown by the example, the <code>driver()</code> function takes care of   parsing the command-line arguments in the call protocol and amending the output.   You don\u2019t need to worry about this in your script.   You simply add the <code>run()</code> function that takes the parameters as arguments   and returns the result.</li> <li>Scripts that use the <code>driver()</code> function can be run as standalone scripts.   This is useful for debugging and testing.</li> <li> <p>Scripts that adhere to the call protocol can be reused across the entire workflow.   If you want to place it in the top-level directory and execute it in any other directory,   you can use the <code>ROOT</code> variable:</p> <pre><code>call(\"${ROOT}/wavegen.py\", freq=235, duration=1.0, out=\"sine.json\")\n</code></pre> </li> </ul>"},{"location":"getting_started/copy_mkdir/","title":"Copy and mkdir","text":"<p>Copying a file or making a directory can be planned using the <code>copy()</code> and <code>mkdir()</code> functions, respectively. These functions perform a few sanity checks and then create a step with the corresponding shell command.</p> <p>The example below will also be used in the Automatic Cleaning tutorial.</p>"},{"location":"getting_started/copy_mkdir/#example","title":"Example","text":"<p>Example source files: <code>docs/getting_started/copy_mkdir/</code></p> <p>Create a file <code>plan.py</code> with the following contents:</p> <pre><code>#!/usr/bin/env python3\nfrom stepup.core.api import copy, mkdir, step\n\nstep(\"echo hello &gt; hello.txt\", out=\"hello.txt\")\nmkdir(\"sub/\")\ncopy(\"hello.txt\", \"sub/\")\n</code></pre> <p>Make it executable and run it with StepUp as follows:</p> <pre><code>chmod +x plan.py\nstepup -n 1\n</code></pre> <p>You should get the following output:</p> <pre><code>  DIRECTOR \u2502 Listening on /tmp/stepup-########/director (StepUp 2.0.4)\n   STARTUP \u2502 (Re)initialized boot script\n  DIRECTOR \u2502 Launched worker 0\n  DIRECTOR \u2502 Launched worker 1\n     PHASE \u2502 run\n     START \u2502 ./plan.py\n     START \u2502 echo hello &gt; hello.txt\n   SUCCESS \u2502 echo hello &gt; hello.txt\n     START \u2502 mkdir -p sub/\n   SUCCESS \u2502 mkdir -p sub/\n   SUCCESS \u2502 ./plan.py\n     START \u2502 cp -aT hello.txt sub/hello.txt\n   SUCCESS \u2502 cp -aT hello.txt sub/hello.txt\n  DIRECTOR \u2502 Trying to delete 0 outdated output(s).\n  DIRECTOR \u2502 Stopping workers.\n  DIRECTOR \u2502 See you!\n</code></pre>"},{"location":"getting_started/copy_mkdir/#notes","title":"Notes","text":"<ul> <li> <p>StepUp expects all directories to end with a trailing delimiter (<code>/</code>).   In the example above, <code>mkdir()</code> and <code>copy()</code> have a <code>sub/</code> argument, which is a directory.   This imposes some clarity on the <code>plan.py</code> file and improves readability.</p> </li> <li> <p>The second argument of <code>copy()</code> can also be a file.   For example, replace <code>sub/</code> with <code>sub/hello.txt</code>, and you will get exactly the same result.   You can also use a different filename, such as <code>sub/hi.txt</code>.</p> </li> </ul>"},{"location":"getting_started/dependencies/","title":"Dependencies","text":"<p>This tutorial demonstrates how StepUp tracks dependencies.</p>"},{"location":"getting_started/dependencies/#example","title":"Example","text":"<p>Example source files: <code>docs/getting_started/dependencies/</code></p> <p>The following <code>plan.py</code> defines two steps, with the second making use of the output from the first.</p> <pre><code>#!/usr/bin/env python3\nfrom stepup.core.api import step\nfrom stepup.core.interact import graph\n\nstep(\"echo First line. &gt; ${out}; echo Second line. &gt;&gt; ${out}\", out=\"story.txt\")\nstep(\"grep First ${inp}\", inp=\"story.txt\")\ngraph(\"graph\")\n</code></pre> <p>The placeholders <code>${inp}</code> and <code>${out}</code> are replaced by the <code>inp</code> and <code>out</code> keyword arguments. (This happens early, before the steps are sent to the director process.)</p> <p>The <code>graph()</code> function writes the graph in a few formats, which are used for visualization below.</p> <p>Now run StepUp with two workers:</p> <pre><code>stepup -n 2\n</code></pre> <p>You will see the following output:</p> <pre><code>  DIRECTOR \u2502 Listening on /tmp/stepup-########/director (StepUp 2.0.4)\n   STARTUP \u2502 (Re)initialized boot script\n  DIRECTOR \u2502 Launched worker 0\n  DIRECTOR \u2502 Launched worker 1\n     PHASE \u2502 run\n     START \u2502 ./plan.py\n     START \u2502 echo First line. &gt; story.txt; echo Second line. &gt;&gt; story.txt\n   SUCCESS \u2502 echo First line. &gt; story.txt; echo Second line. &gt;&gt; story.txt\n     START \u2502 grep First story.txt\n   SUCCESS \u2502 ./plan.py\n   SUCCESS \u2502 grep First story.txt\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 Standard output \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nFirst line.\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n  DIRECTOR \u2502 Trying to delete 0 outdated output(s).\n  DIRECTOR \u2502 Stopping workers.\n  DIRECTOR \u2502 See you!\n</code></pre> <p>Despite the fact that StepUp has launched two workers, it carries out the steps sequentially, because it knows that the output of the first step will be used by the second.</p> <p>Note, however, that the <code>echo</code> commands are already started before <code>./plan.py</code> has finished. This is the expected behavior: even without a complete overview of all the build steps, StepUp will start the steps for which it has sufficient information.</p>"},{"location":"getting_started/dependencies/#graphs","title":"Graphs","text":"<p>The <code>plan.py</code> script writes a few files to analyze and visualize the graphs StepUp uses internally. The file <code>graph.txt</code> is a detailed human-readable version of <code>.stepup/graph.db</code>:</p> <pre><code>root:\n             creates   file:./\n             creates   file:plan.py\n             creates   step:./plan.py\n\nfile:plan.py\n               state = STATIC\n              digest = 7a11aa45 ad1f79f7 a08da7a0 5eb932da e3f4f931 678bdd02 9a4241bb 41fa2929\n                     = a72d2dea 369c44d7 ab39f96f 7ed5800d f8e5f9c4 721be23b 80d279ae fd65a0e2\n          created by   root:\n            consumes   file:./\n            supplies   step:./plan.py\n\nfile:./\n               state = STATIC\n          created by   root:\n            supplies   file:plan.py\n            supplies   file:story.txt\n            supplies   step:./plan.py\n            supplies   step:echo First line. &gt; story.txt; echo Second line. &gt;&gt; story.txt\n            supplies   step:grep First story.txt\n\nstep:./plan.py\n               state = RUNNING\n          created by   root:\n            consumes   file:./\n            consumes   file:plan.py\n             creates   step:echo First line. &gt; story.txt; echo Second line. &gt;&gt; story.txt\n             creates   step:grep First story.txt\n\nstep:echo First line. &gt; story.txt; echo Second line. &gt;&gt; story.txt\n               state = RUNNING\n          created by   step:./plan.py\n            consumes   file:./\n             creates   file:story.txt\n            supplies   file:story.txt\n\nfile:story.txt\n               state = AWAITED\n          created by   step:echo First line. &gt; story.txt; echo Second line. &gt;&gt; story.txt\n            consumes   file:./\n            consumes   step:echo First line. &gt; story.txt; echo Second line. &gt;&gt; story.txt\n            supplies   step:grep First story.txt\n\nstep:grep First story.txt\n               state = PENDING\n          created by   step:./plan.py\n            consumes   file:./\n            consumes   file:story.txt\n</code></pre> <p>This text format may not always be the most convenient way to understand how StepUp connects all the steps and files. A more intuitive picture can be created with GraphViz using the <code>.dot</code> files as input. The figures below were created using the following commands:</p> <pre><code>dot -v graph_provenance.dot -Tsvg -o graph_provenance.svg\ndot -v graph_dependency.dot -Tsvg -o graph_dependency.svg\n</code></pre> <p>The workflow in StepUp consists of two graphs involving (a subset of) the same set of nodes: the supplier graph and the creator graph.</p>"},{"location":"getting_started/dependencies/#dependency-graph","title":"Dependency Graph","text":"<p>This graph shows how information is passed from one node to the next as the steps are executed.</p> <p></p> <p>This is an intuitive graph showing the execution flow. A similar graph is used by most other build tools. Not shown in this diagram are the directories, which StepUp treats in the same way as files.</p>"},{"location":"getting_started/dependencies/#provenance-graph","title":"Provenance Graph","text":"<p>This one shows who created each node in the graph:</p> <p></p> <p>This diagram is a little less intuitive and requires more explanation. Each node in StepUp\u2019s workflow is created by exactly one other node, except for the Root node, which is its own creator. In this example, there are three nodes that create other nodes:</p> <ul> <li> <p>The <code>root</code> node is an internal node controlled by StepUp.   Upon startup, StepUp creates <code>root</code> and a few other nodes by default:</p> <ul> <li>The initial <code>plan.py</code> file</li> <li>The initial <code>./plan.py</code> step (with working directory <code>./</code>.)</li> <li>The working directory <code>./</code> is created just like any other directory that is used.</li> </ul> </li> <li> <p>The <code>./plan.py</code> step creates two nodes,   see the two <code>step()</code> function calls in the <code>plan.py</code> script above.</p> <ul> <li>The <code>grep</code> step.<ul> <li>The <code>echo</code> step.</li> </ul> </li> </ul> </li> <li> <p>The <code>echo</code> step creates one output file: <code>story.txt</code>.</p> </li> </ul> <p>This provenance graph is used by StepUp to decide which steps to keep and which to clean up. After some files have changed and StepUp is run again, some nodes may no longer be created. These \u201cold\u201d nodes will still exist in the database as \u201corphaned\u201d nodes, i.e. without a creator. After all steps have been successfully completed, StepUp will remove orphaned nodes that are not suppliers to other steps. When output file nodes are deleted, the corresponding files are also removed from disk. (This is done carefully: StepUp will only remove files if it knows they were created in a previous run and if the file hash still matches the one recorded immediately after the file was built.) If some steps use orphaned nodes as input, those steps will remain pending, resulting in an incomplete build and blocking the removal of the orphaned nodes.</p> <p>Example:</p> <ul> <li>After modifying <code>plan.py</code> and rerunning this step,   all nodes created by the <code>./plan.py</code> step will be orphaned.</li> <li>The new <code>plan.py</code> may recreate some of the old nodes in exactly the same way,   in which case the orphaned nodes will simply be restored,   along with all of their products and related information.</li> <li>If some nodes are not recreated, they will remain orphaned,   and will be removed after a complete and successful build.</li> <li>The new <code>plan.py</code> can also define new nodes, which simply extend the graph.</li> <li>Nodes that are recreated with different properties will override any existing orphaned nodes.</li> </ul>"},{"location":"getting_started/dependencies/#try-the-following","title":"Try the Following","text":"<ul> <li> <p>Run <code>stepup -n 2</code> again. As expected, the steps are now skipped.</p> </li> <li> <p>Modify the <code>grep</code> command to select the second line and run <code>stepup -n 2</code> again.   The <code>echo</code> commands are skipped as they have not changed.</p> </li> <li> <p>Change the order of the two steps in <code>plan.py</code> and run <code>stepup -n 2</code>.   The step <code>./plan.py</code> is executed because the file has changed,   but the <code>echo</code> and <code>grep</code> steps are skipped.   This shows that <code>plan.py</code> is nothing but a plan, not its execution.   When <code>plan.py</code> is executed, it simply sends instructions to the director process.</p> </li> <li> <p>Rename the file <code>story.txt</code> to <code>lines.txt</code> (in both steps) and restart StepUp.   The old <code>story.txt</code> output file will be automatically removed from disk,   since this is an (intermediate) output file whose node will be orphaned and cleaned up.</p> </li> </ul>"},{"location":"getting_started/distributed_plans/","title":"Distributed Plans","text":"<p>When your project grows, defining the entire workflow in a single <code>plan.py</code> file may become inconvenient. Especially when working with nested directories for different parts of the project, it may be convenient to distribute the workflow over multiple <code>plan.py</code> files.</p>"},{"location":"getting_started/distributed_plans/#example","title":"Example","text":"<p>Example source files: <code>docs/getting_started/distributed_plans/</code></p> <p>Create a simple example with a top-level <code>plan.py</code> as follows:</p> <pre><code>#!/usr/bin/env python3\nfrom stepup.core.api import plan, static\n\nstatic(\"sub/\", \"sub/plan.py\", \"part1.txt\", \"sub/part2.txt\")\nplan(\"sub/\")\n</code></pre> <p>The top-level plan defines a few static files and then calls another plan in <code>sub/</code>. Create a file <code>sub/plan.py</code> as follows:</p> <pre><code>#!/usr/bin/env python3\nfrom stepup.core.api import step\n\nstep(\"cat part2.txt\", inp=\"part2.txt\")\nstep(\"cat ../part1.txt\", inp=\"../part1.txt\")\n</code></pre> <p>Also create two files <code>part1.txt</code> and <code>sub/part2.txt</code> with a bit of text. Make both plans executable and run StepUp as follows:</p> <pre><code>chmod +x plan.py sub/plan.py\n</code></pre> <p>You will get the following output:</p> <pre><code>  DIRECTOR \u2502 Listening on /tmp/stepup-########/director (StepUp 2.0.4)\n   STARTUP \u2502 (Re)initialized boot script\n  DIRECTOR \u2502 Launched worker 0\n     PHASE \u2502 run\n     START \u2502 ./plan.py\n   SUCCESS \u2502 ./plan.py\n     START \u2502 ./plan.py  # wd=sub/\n   SUCCESS \u2502 ./plan.py  # wd=sub/\n     START \u2502 cat part2.txt  # wd=sub/\n   SUCCESS \u2502 cat part2.txt  # wd=sub/\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 Standard output \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nThis is part 2.\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n     START \u2502 cat ../part1.txt  # wd=sub/\n   SUCCESS \u2502 cat ../part1.txt  # wd=sub/\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 Standard output \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nThis is part 1.\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n  DIRECTOR \u2502 Trying to delete 0 outdated output(s).\n  DIRECTOR \u2502 Stopping workers.\n  DIRECTOR \u2502 See you!\n</code></pre>"},{"location":"getting_started/distributed_plans/#practical-considerations","title":"Practical Considerations","text":"<ul> <li>The main benefit of having multiple <code>plan.py</code> files   is to improve the logical structure of your project.   It may also be helpful when a part of your <code>plan.py</code> is computationally demanding, in which   case it can be factored out so that it does not slow down the rest of the build.   However, ideally, the <code>plan.py</code> scripts execute quickly, leaving the hard work to other steps.</li> <li>When there are multiple <code>plan.py</code> files,   keep in mind that their order of execution cannot be relied upon.   They are executed in parallel, and their relative starting times depend   on factors unknown a priori, such as system load and number of workers.</li> </ul>"},{"location":"getting_started/failing_steps/","title":"Failing steps","text":"<p>The development of a StepUp workflow is an interactive process, where it is common to have failing steps. These will result in screen output with a bright red <code>FAIL</code> message. At the end of a run, a warning message will be displayed that some steps have failed.</p> <p>Here, we provide some guidance on how to handle failing steps.</p> <ul> <li> <p>Check the error message:   The error message will often provide a clue to what went wrong.   If your workflow is so large that the error message has scrolled out of view,   you can always find the error message in the file <code>.stepup/fail.log</code>.   When you open this file in VSCode or PyCharm,   the file will be automatically reloaded when the workflow is rerun.   (There is a similar file <code>.stepup/warning.log</code> for warnings.)</p> </li> <li> <p>External causes:   If the source of the problem is unrelated to STATIC files known to StepUp,   fixing the problem will not result in a file change that StepUp can detect.   Therefore, when you restart StepUp from scratch,   it will automatically rerun previously failed steps.   However, when working interactively with <code>-w</code> or <code>-W</code>,   failed steps will not be rerun automatically.</p> </li> </ul>"},{"location":"getting_started/first_step/","title":"First Step","text":"<p>The goal of the first tutorial is to introduce the basic usage of StepUp. For the sake of simplicity, a minimal workflow will be defined that does very little.</p>"},{"location":"getting_started/first_step/#example","title":"Example","text":"<p>Example source files: <code>docs/getting_started/first_step/</code></p> <p>Create a file <code>plan.py</code> with the following contents:</p> <pre><code>#!/usr/bin/env python3\nfrom stepup.core.api import step\n\nstep(\"echo Hello World\")\n</code></pre> <p>Make this file executable with <code>chmod +x plan.py</code>.</p> <ol> <li>The first line is required to have the plan executed by the Python 3 interpreter.</li> <li>The second line imports the <code>step()</code> function from StepUp Core.    This module contains functions to communicate with the director process    of StepUp to define steps and other parts of the workflow.</li> <li>The last line defines a step that writes <code>Hello World</code> to the standard output.    The (first) argument of <code>step()</code> is a single string    that can be interpreted by the default shell, typically <code>/usr/bin/sh</code>.    You may use IO redirection, pipes, and other features supported by the shell.    (StepUp will not provide any standard input.    It does capture standard output and error, as shown below.)</li> </ol> <p>In the same directory, run:</p> <pre><code>stepup -n 1\n</code></pre> <ul> <li>The option <code>-n 1</code> sets the maximum number of workers to 1, i.e. no parallel execution of steps.</li> </ul> <p>You should see the following output, with colors if your virtual terminal supports them:</p> <pre><code>  DIRECTOR \u2502 Listening on /tmp/stepup-########/director (StepUp 2.0.3.post4)\n   STARTUP \u2502 (Re)initialized boot script\n  DIRECTOR \u2502 Launched worker 0\n     PHASE \u2502 run\n     START \u2502 ./plan.py\n   SUCCESS \u2502 ./plan.py\n     START \u2502 echo Hello World\n   SUCCESS \u2502 echo Hello World\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 Standard output \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nHello World\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n  DIRECTOR \u2502 Trying to delete 0 outdated output(s).\n  DIRECTOR \u2502 Stopping workers.\n  DIRECTOR \u2502 See you!\n</code></pre> <p>Let\u2019s analyze the output:</p> <ul> <li>The first three lines are part of StepUp startup sequence.   The address <code>/tmp/stepup-########/director</code>   is a Unix domain socket   through which the director receives instructions from other processes to define the workflow.   (The hash signs represent random characters.)</li> <li>The <code>START</code> and <code>SUCCESS</code> lines are shown for steps executed by StepUp:<ul> <li>The step <code>./plan.py</code> is created by default and runs the script that you just created.</li> <li>Then the step <code>echo Hello World</code> is the step defined in <code>plan.py</code>.</li> </ul> </li> <li>When a step produces output, it is shown after the step has completed.</li> <li>When no more steps can be executed,   StepUp checks if it can clean up outdated outpus and then exits.</li> </ul> <p>Now repeat the execution of StepUp with:</p> <pre><code>stepup -n 1\n</code></pre> <p>You will see a slightly different output:</p> <pre><code>  DIRECTOR \u2502 Listening on /tmp/stepup-########/director (StepUp 2.0.3.post4)\n   STARTUP \u2502 Making failed steps pending\n   STARTUP \u2502 Watching 1 director(y|ies) from initial database\n   STARTUP \u2502 Scanning initial database for changed files\n   STARTUP \u2502 Scanning initial database for new nglob matches\n  DIRECTOR \u2502 Launched worker 0\n     PHASE \u2502 run\n  DIRECTOR \u2502 Trying to delete 0 outdated output(s).\n  DIRECTOR \u2502 Stopping workers.\n  DIRECTOR \u2502 See you!\n</code></pre> <p>The startup sequence is now a bit longer because StepUp loads the workflow from <code>.stepup/graph.db</code>, which was created in the first run. It looks for relevant file changes and because <code>plan.py</code> has not changed, it will not rerun it. Even if file time stamps have changed, it will also check if files have actually changed by comparing a Blake2 hash of input files, used environment variables and produced outputs. When you manually remove <code>.stepup/graph.db</code>, StepUp will not know anymore that it already executed some steps and runs all of them again.</p>"},{"location":"getting_started/first_step/#try-the-following","title":"Try the Following","text":"<ul> <li> <p>Change the arguments of the <code>echo</code> command in <code>plan.py</code> and run <code>stepup -n 1</code> again.   As expected, StepUp detects the change and repeats the <code>plan.py</code> and <code>echo</code> steps.</p> </li> <li> <p>Normally, you would never run <code>./plan.py</code> directly as a normal Python script, i.e.,   without running it through <code>stepup</code>.   Try it anyway, just to see what happens.   The terminal output shows the commands that would normally be sent to the StepUp director   process when <code>plan.py</code> is executed by <code>stepup</code>.   You should get the following screen output.</p> <pre><code>step('dummy:', 'echo Hello World', [], [], [], [], Path('./'), False, None, False)\n</code></pre> <p>This output contains internal details of StepUp, which can be useful for debugging purposes.</p> </li> </ul>"},{"location":"getting_started/interactive_usage/","title":"Interactive Usage","text":"<p>Note</p> <p>The command-line options related to interactive usage have changed in StepUp 2.0.0</p> <p>All previous tutorials have run StepUp non-interactively, for the sake of simplicity. In practice, this is mainly useful when building projects in batch jobs, e.g., in the cloud. When working on a project, interactive usage is more efficient and convenient, but requires a little more explanation.</p> <p>The Static Glob tutorial is a good example to demonstrate the interactive use of StepUp. Running StepUp as follows will not exit the terminal user interface:</p> <pre><code>stepup -w\n</code></pre> <p>After the line <code>PHASE \u2502 watch</code> appears, StepUp just waits for changes to the (static) files.</p>"},{"location":"getting_started/interactive_usage/#change-an-existing-file","title":"Change an Existing File","text":"<p>For example, while StepUp is still running, edit and save the file <code>src/foo.txt</code>. You will see at least the following:</p> <pre><code>    UPDATED \u2502 src/foo.txt\n</code></pre> <p>Now go back to the terminal and press the character <code>?</code> to display the supported keys with interactive commands:</p> <pre><code>\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 Keys \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\n   r = run     q = shutdown     d = drain     j = join     g = graph\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n</code></pre> <p>Now press (lower case) <code>r</code> to run steps whose (indirect) inputs have changed. The new file <code>src/foo.txt</code> is copied again to <code>dst/foo.txt</code>, while other steps are ignored.</p> <p>The interactive commands are described in detail in the Interactive Command Reference.</p>"},{"location":"getting_started/interactive_usage/#add-a-new-file-that-matches-globsrctxt","title":"Add a New File That Matches <code>glob(\"src/*.txt\")</code>","text":"<p>Create a new file <code>src/spam.txt</code> with content of your choice while StepUp is still running. You will see at least the following:</p> <pre><code>    UPDATED \u2502 src/spam.txt\n</code></pre> <p>Now press (lower case) <code>r</code> again. The <code>./plan.py</code> step is executed again because a new file has appeared that matches a glob pattern used in <code>plan.py</code>. Running <code>./plan.py</code> again will, in turn, create a new step to copy <code>src/spam.txt</code> to <code>dst/spam.txt</code>.</p>"},{"location":"getting_started/interactive_usage/#screen-recording","title":"Screen Recording","text":"<p>The following recording shows the terminal output when starting StepUp from scratch with two workers, changing <code>src/foo.txt</code> and re-running, followed by adding <code>src/spam.txt</code> and re-running:</p>"},{"location":"getting_started/interactive_usage/#watch-mode-with-automatic-re-run","title":"Watch mode with automatic re-run","text":"<p>If you prefer to avoid switching back and forth between the terminal and the editor, you can use the <code>-W</code> option instead of <code>-w</code>. This will automatically re-run the steps half a second after the first file change:</p> <pre><code>stepup -W\n</code></pre>"},{"location":"getting_started/introduction/","title":"Introduction","text":"<p>The \u201cGetting Started\u201d section consists of a series of short tutorials. Each tutorial introduces a few concepts at a time to maintain a gentle learning curve. The following initial competencies are assumed:</p> <ul> <li>Basic Python programming.</li> <li>Working with a virtual terminal.</li> <li>Editing text files.</li> </ul> <p>Note that the examples in the tutorials are all small and use StepUp in serial mode (<code>-n 1</code>) and non-interactively. We believe this offers the best learning experience. However, StepUp really shines in more complex use cases and when used interactively. Once you know how StepUp works, you can impress yourself by effortlessly mastering the daunting complexity of your projects. :)</p>"},{"location":"getting_started/introduction/#tutorial-source-files","title":"Tutorial source files","text":"<p>Input files for each tutorial are stored in a corresponding subdirectory under <code>docs/getting_started/</code> within StepUp Core\u2019s source code. Each directory contains a script named <code>main.sh</code>, which simply runs the example in non-interactive mode, generating the outputs that are included in the documentation.</p>"},{"location":"getting_started/introduction/#stepup-architecture","title":"StepUp architecture","text":"<p>The tutorials use terminology defined in the small architecture overview given below. This overview summarizes the internals of StepUp, omitting many details for the sake of clarity. It provides just enough background to get a basic understanding of its core concepts.</p>"},{"location":"getting_started/introduction/#workflow-graphs","title":"Workflow (graphs)","text":"<p>StepUp keeps track of what it needs to do and what it has already done in a workflow data structure. This workflow is represented by two direct acyclic graphs (DAGs), which comprise the same nodes.</p>"},{"location":"getting_started/introduction/#nodes","title":"Nodes","text":"<p>The nodes of the graph can be instances of the following main classes:</p> <ul> <li> <p>A <code>Step</code> defines a program that can be executed with all the information for a specific execution:   working directory, command, arguments, inputs, outputs, etc.   A step can also be in one of the following states:</p> <ul> <li><code>PENDING</code>: the step cannot yet be scheduled   because some inputs have not been declared or built yet.</li> <li><code>QUEUED</code>: all inputs are available and the step is waiting to be executed.</li> <li><code>RUNNING</code>: the step is being executed by one of the workers.</li> <li><code>SUCCEEDED</code>: the step has been successfully completed.</li> <li><code>FAILED</code>: the subprocess exited with a non-zero exit code or   some output files were not created.</li> </ul> </li> <li> <p>A <code>File</code> defines a path and a status, which can be any of the following:</p> <ul> <li><code>AWAITED</code>: the file is the output of a step that has never been executed so far.   (Such files are never deleted when cleaning up outputs.)</li> <li><code>BUILT</code>: the file is the output of a step that has been successfully executed.</li> <li><code>OUTDATED</code>: the file is the output of a step that has been executed,   but inputs of the step have been modified since then.</li> <li><code>VOLATILE</code>: the file is (or can be) created by a step, but it is volatile.   It cannot be used as input, no hashes are computed for it.   These files are only registered so that they can be removed when appropriate.   They are typically different every time they are created,   even with the same inputs.</li> <li><code>STATIC</code>: the file is written by you and can only be an input to a step.   (Note that step inputs can also be outputs of previous steps.)</li> <li><code>MISSING</code>: a static file that has gone missing.</li> </ul> </li> </ul> <p>There are also a few special nodes:</p> <ul> <li>The <code>Root</code> node is the top-level node, of which there is only one.</li> <li>A <code>DeferredGlob</code> node contains a glob   pattern of files that are made static when they are used as input.</li> </ul>"},{"location":"getting_started/introduction/#edges","title":"Edges","text":"<p>The StepUp workflow has two types of directed edges (arrows) connecting pairs of nodes. Each type of edge is used to define a graph with its own rules and logic.</p> <ul> <li> <p>The \u201cdependency graph\u201d consists of \u201csupplier \u279c consumer\u201d edges.   In this graph, an edge points from a node   that provides something to a node that uses that something.   A few examples:</p> <ul> <li>If a step uses a file as its input, it is the consumer of that file.</li> <li>Likewise, a step is the supplier of its outputs</li> <li>Every file is the consumer of its parent directory.   (The only exceptions are <code>./</code> and <code>/</code>.)</li> <li>A step is the consumer of its working directory.</li> </ul> <p>The following diagram from the Dependencies tutorial illustrates this type of edge. (Directories are not included, steps are blue ellipses, files are grey rectangles.)</p> <p></p> <p>The build algorithm in StepUp will traverse upwards through this graph as it executes the steps, similarly to tup.</p> </li> <li> <p>The \u201cprovenance graph\u201d consists of \u201ccreator \u279c product\u201d edges.   An edge is added to this graph whenever a new node is created.   Each (active) node must have one creator, but nodes can have multiple products.   Examples include:</p> <ul> <li>A step is the creator of its output files.</li> <li>If a <code>plan.py</code> defines new steps, then the <code>./plan.py</code> step is the creator of   the new steps.   (The same goes for any other step creating new steps.)</li> <li>If a step declares a static file, the step is the creator of the static file.</li> <li>The initial <code>plan.py</code> step has the <code>Root</code> node as its creator.</li> <li>Only the <code>Root</code> node is its own creator, making it the top-level node by construction.</li> </ul> <p>The following graph from the Dependencies tutorial illustrates this type of edge. (Steps are blue ellipses, files are grey rectangles, root is an orange hexagon.)</p> <p></p> </li> </ul>"},{"location":"getting_started/introduction/#processes","title":"Processes","text":"<p>The following diagram illustrates how the components of StepUp interact. Legend:</p> <ul> <li>White boxes: your fingers and eyes</li> <li>Grey boxes: processes<ul> <li>The terminal user interface is the part of StepUp that you interact with   when you run the <code>stepup</code> command.</li> <li>The director holds the workflow data structure and is responsible   for scheduling steps and watching for file changes.</li> <li>The worker processes execute steps and compute file and step hashes.</li> </ul> </li> <li>Grey arrows: standard input and standard output.</li> <li>Yellow arrows: startup of subprocesses</li> <li>Blue arrows: remote procedure calls to control the director and the workers</li> <li>Purple arrows: remote procedure calls for progress updates</li> <li>Green arrows: remote procedure calls to extend the workflow</li> </ul> <p></p>"},{"location":"getting_started/no_rules/","title":"No Rules","text":"<p>Most other built tools introduce the concept of a build rule, to specify how a common build step can be applied to different inputs. StepUp does not need to introduce the concept of a build rule because Python functions and loops already provide similar facilities.</p> <p>StepUp already comes with a few built-in \u201crules\u201d defined int this way: <code>plan()</code>, <code>copy()</code>, <code>mkdir()</code>, <code>getenv()</code> and <code>script()</code>. Some of these were already discussed in the previous tutorials, and their source code offers some inspiration for writing your own.</p>"},{"location":"getting_started/no_rules/#example","title":"Example","text":"<p>Example source files: <code>docs/getting_started/no_rules/</code></p> <p>Here, we show a simple example of a custom rule to convert a text file to upper case with the <code>tr</code> command.</p> <p>Create the following <code>plan.py</code>:</p> <pre><code>#!/usr/bin/env python3\nfrom stepup.core.api import glob, step\n\n\ndef upper(src, dst):\n    step(\"tr '[:lower:]' '[:upper:]' &lt; ${inp} &gt; ${out}\", inp=src, out=dst)\n\n\nfor path in glob(\"lower*.txt\"):\n    upper(path, \"upper\" + path[5:])\n</code></pre> <p>In addition, make two text files <code>lower1.txt</code> and <code>lower2.txt</code> with some random contents. Then make the plan executable and launch StepUp:</p> <pre><code>chmod +x plan.py\nstepup -n 1\n</code></pre> <p>This will show the following output:</p> <pre><code>  DIRECTOR \u2502 Listening on /tmp/stepup-########/director (StepUp 2.0.4)\n   STARTUP \u2502 (Re)initialized boot script\n  DIRECTOR \u2502 Launched worker 0\n     PHASE \u2502 run\n     START \u2502 ./plan.py\n   SUCCESS \u2502 ./plan.py\n     START \u2502 tr '[:lower:]' '[:upper:]' &lt; lower1.txt &gt; upper1.txt\n   SUCCESS \u2502 tr '[:lower:]' '[:upper:]' &lt; lower1.txt &gt; upper1.txt\n     START \u2502 tr '[:lower:]' '[:upper:]' &lt; lower2.txt &gt; upper2.txt\n   SUCCESS \u2502 tr '[:lower:]' '[:upper:]' &lt; lower2.txt &gt; upper2.txt\n  DIRECTOR \u2502 Trying to delete 0 outdated output(s).\n  DIRECTOR \u2502 Stopping workers.\n  DIRECTOR \u2502 See you!\n</code></pre>"},{"location":"getting_started/script_multiple/","title":"Script (Multiple Cases)","text":"<p>In the previous tutorial, the script protocol and driver were illustrated with a single use case of a script. The script protocol also supports scripts that can be executed with different combinations of inputs.</p>"},{"location":"getting_started/script_multiple/#multiple-cases-script-driver","title":"Multiple Cases Script Driver","text":"<p>A Python script using the script protocol for multiple cases has the following structure.</p> <pre><code>#!/usr/bin/env python3\nfrom stepup.core.script import driver\n\ndef cases():\n    yield 1\n    yield 2\n\nCASE_FMT = \"foo{}\"\n\ndef case_info(case: int):\n    return {\n        \"inp\": ..., # a single input path or a list of input paths\n        \"out\": ..., # a single output path or a list of input paths\n        \"static\": ..., # declare a static file or a list of static files\n        \"stdout\": ..., # redirect the standard output to a file (StepUp 1.3.0)\n        \"stderr\": ..., # redirect the standard error to a file (StepUp 1.3.0)\n        \"just_any\": \"argument that you want to add\",\n    }\n\ndef run(inp, out, just_any):\n    ...\n\nif __name__ == \"__main__\":\n    driver()\n</code></pre> <p>The script has the following elements:</p> <ul> <li> <p>The generator <code>cases()</code> takes no arguments and yields cases   that correspond to different ways of running the script.   Here, the cases are simple integers <code>1</code> and <code>2</code>, but richer data are also supported.   The <code>item</code> in <code>yield item</code> is translated into an <code>args</code> list and a <code>kwargs</code> dictionary as follows:</p> <ul> <li>If <code>item</code> is a dictionary: <code>args = []; kwargs = item</code></li> <li>Else if <code>item</code> is a tuple of a list and a dictionary: <code>args, kwargs = item</code></li> <li>Else if <code>item</code> is a list or tuple: <code>args = list(item); kwargs = {}</code></li> <li>Else: <code>args = [item]; kwargs = {}</code></li> </ul> </li> <li> <p>The cases will be represented by a string argument on the command line formatted with   <code>CASE_FMT.format(*args, **kwargs)</code>, where <code>args</code> and <code>kwargs</code> are derived from the iterates   from the <code>cases()</code> generator.   The formatted string must retain all information of <code>args</code> and <code>kwargs</code>,   so that they can be derived again from the formatted string   with the parse library.</p> <ul> <li>Here, the two string representations will be <code>foo1</code> and <code>foo2</code>.</li> <li>The corresponding steps will be <code>./script.py run foo1</code> and <code>./script.py run foo2</code></li> </ul> </li> <li> <p>The function <code>case_info()</code> is used to translate <code>args</code> and <code>kwargs</code> into a more detailed   planning of the run steps.   The returned dictionary is handled in the same way as that of the <code>info()</code> function in   the previous tutorial Script (Single Case).</p> </li> <li> <p>The function <code>run()</code> works in the same way as for the single case script driver.</p> </li> </ul>"},{"location":"getting_started/script_multiple/#example","title":"Example","text":"<p>Example source files: <code>docs/getting_started/script_multiple/</code></p> <p>To make the example more engaging, it leverages NumPy and Matplotlib. The same plotting function is applied to two datasets of hourly temperatures recorded at the airports of Brussels and Ostend in February 2024, downloaded from the ASOS network hosted by Iowa State University.</p> <p>Create a script <code>plan.py</code> that just calls the plotting script:</p> <pre><code>#!/usr/bin/env python3\nfrom stepup.core.api import script, static\n\nstatic(\"plot.py\", \"ebbr.csv\", \"ebos.csv\", \"matplotlibrc\")\nscript(\"plot.py\")\n</code></pre> <p>The script <code>plot.py</code> uses the script driver with multiple cases:</p> <pre><code>#!/usr/bin/env python3\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nimport numpy as np\nfrom matplotlib.dates import DateFormatter\n\nfrom stepup.core.script import driver\n\n\ndef cases():\n    yield \"ebbr\"\n    yield \"ebos\"\n\n\nCASE_FMT = \"plot_{}\"\n\n\ndef case_info(airport):\n    return {\n        \"inp\": [\"matplotlibrc\", f\"{airport}.csv\"],\n        \"out\": f\"plot_{airport}.png\",\n        \"airport\": airport,\n    }\n\n\ndef run(inp, out, airport):\n    mpl.rc_file(inp[0])\n    dtype = [(\"dt\", \"datetime64[s]\"), (\"tmpc\", \"f8\")]\n    data = np.loadtxt(inp[1], dtype=dtype, delimiter=\",\", skiprows=1).T\n    fig, ax = plt.subplots()\n    ax.plot(data[\"dt\"], data[\"tmpc\"])\n    ax.xaxis.set_major_formatter(DateFormatter(\"%d\"))\n    ax.set_xlabel(\"Day of the month February 2024\")\n    ax.set_xlim(data[\"dt\"][0], data[\"dt\"][-1])\n    ax.set_ylabel(\"Temperature [\u00b0C]\")\n    ax.set_title(f\"Airport {airport.upper()}\")\n    fig.savefig(out)\n\n\nif __name__ == \"__main__\":\n    driver()\n</code></pre> <p>Make the scripts executable and run StepUp to get the results:</p> <pre><code>chmod +x plan.py plot.py\nstepup -n 1\n</code></pre> <p>You should see the following terminal output with the plan and run steps of the plotting script:</p> <pre><code>  DIRECTOR \u2502 Listening on /tmp/stepup-########/director (StepUp 2.0.4)\n   STARTUP \u2502 (Re)initialized boot script\n  DIRECTOR \u2502 Launched worker 0\n     PHASE \u2502 run\n     START \u2502 ./plan.py\n   SUCCESS \u2502 ./plan.py\n     START \u2502 ./plot.py plan\n   SUCCESS \u2502 ./plot.py plan\n     START \u2502 ./plot.py run -- plot_ebbr\n   SUCCESS \u2502 ./plot.py run -- plot_ebbr\n     START \u2502 ./plot.py run -- plot_ebos\n   SUCCESS \u2502 ./plot.py run -- plot_ebos\n  DIRECTOR \u2502 Trying to delete 0 outdated output(s).\n  DIRECTOR \u2502 Stopping workers.\n  DIRECTOR \u2502 See you!\n</code></pre> <p>This produces the following figures:</p> <p> </p>"},{"location":"getting_started/script_multiple/#try-the-following","title":"Try the Following","text":"<ul> <li> <p>Download temperature data for the same month of an airport close to your home and format it   similarly to the <code>*.csv</code> already present.   Extend the <code>cases()</code> generator to also process your temperature data.</p> </li> <li> <p>It is common for iterates of <code>cases()</code> to be reused by multiple scripts.   One way to centralize this information is by defining a list <code>airports</code> in a <code>settings.py</code> module.   By locally importing this module in the <code>cases()</code> function,   the driver will make <code>settings.py</code> an input only of the planning step of the script:</p> <pre><code>def cases():\n    from settings import airports\n    yield from airports\n</code></pre> </li> <li> <p>For debugging purposes, it is sometimes useful to run just a single case of a script.   To facilitate this type of debugging, the script can be called with the <code>cases</code> argument.   When you run the following command:</p> <pre><code>./plot.py cases\n</code></pre> <p>you will get a list of different ways to execute the script\u2019s <code>run()</code> function:</p> <pre><code>./plot.py run -- 'plot_ebbr'\n./plot.py run -- 'plot_ebos'\n</code></pre> </li> </ul>"},{"location":"getting_started/script_single/","title":"Script (Single Case)","text":"<p>StepUp Core implements a simple script protocol for defining scripts that combine planning and execution in a single source file. This can be more convenient than putting a lot of detail in the <code>plan.py</code> file.</p> <p>The script and call protocols are similar in that they both simplify planning step. To help you decide which one to use, consider the following:</p> <ul> <li> <p>The call protocol is most convenient when you have a single script   that can be run with different parameters.   The script itself does not need to know about the parameters upfront.</p> </li> <li> <p>The script protocol is most convenient when you prefer to have all the details of the script,   including the planning (inputs, outputs, \u2026) and execution, in a single source file.   Such self-contained scripts are easier to understand and maintain.</p> </li> </ul>"},{"location":"getting_started/script_single/#script-protocol","title":"Script Protocol","text":"<p>The <code>script()</code> protocol itself is rather simple. The following line in <code>plan.py</code>:</p> <pre><code>script(\"executable\", workdir=\"sub\")\n</code></pre> <p>is roughly equivalent to:</p> <pre><code>step(\"./executable plan\", inp=\"executable\", workdir=\"sub\")\n</code></pre> <p>Note that the use of a subdirectory is not required. The <code>./executable plan</code> step is expected to define additional steps to actually run something useful with the executable. A common scenario is to plan a single <code>./executable run</code> step with appropriate inputs and outputs.</p> <p>When the <code>optional=True</code> keyword argument is given to the <code>script()</code> function, it executes <code>./executable plan --optional</code>. The script protocol requires that all run steps created by this planning step should then receive the <code>optional=True</code> keyword argument. Note that the plan step itself is never an optional step: It is always executed.</p> <p>The <code>script()</code> function also supports the <code>step_info=\"some_file.json</code> argument. This results in an extra argument <code>--step-info=some_file.json</code> for <code>./executable plan</code>. The planning of the run scripts is then expected to write all the information about the created run steps to this JSON file. In complex workflows, it may be useful to load this JSON file with <code>load_step_info()</code>. Consult the section on StepInfo Objects to learn how to use these objects.</p> <p>In addition, the <code>script()</code> function also supports all the arguments of <code>step()</code>, which it simply passes on when creating the <code>./executable plan</code> step.</p> <p>Note</p> <p>The <code>step_info</code> argument, and support for all <code>step()</code> arguments were added in StepUp 2.0.0.</p>"},{"location":"getting_started/script_single/#script-driver","title":"Script driver","text":"<p>StepUp implements a <code>driver()</code> function in the module <code>stepup.core.script</code> that greatly facilitates writing Python scripts that adhere to the script protocol.</p> <p>It can be used in two ways:</p> <ol> <li> <p>To run the executable for just one specific case of inputs and outputs (this tutorial).</p> </li> <li> <p>To run the same script with multiple combinations of inputs and outputs (next tutorial).</p> </li> </ol> <p>In both cases, the script driver will detect local modules that are imported in the script, and amend these as required inputs. By default, only the modules inside <code>STEPUP_ROOT</code> are treated as dependencies. You can specify additional directories in the <code>STEPUP_EXTERNAL_SOURCES</code> environment variable.</p>"},{"location":"getting_started/script_single/#single-case-script-driver","title":"Single Case Script Driver","text":"<p>A Python script using the driver for a single case has the following structure.</p> <pre><code>#!/usr/bin/env python3\nfrom stepup.core.script import driver\n\ndef info():\n    return {\n        \"inp\": ..., # a single input path or a list of input paths\n        \"out\": ..., # a single output path or a list of input paths\n        \"static\": ..., # declare a static file or a list of static files\n        \"stdout\": ..., # redirect the standard output to a file (StepUp 1.3.0)\n        \"stderr\": ..., # redirect the standard error to a file (StepUp 1.3.0)\n        \"just_any\": \"argument that you want to add\",\n    }\n\ndef run(inp, out, just_any):\n    ...\n\nif __name__ == \"__main__\":\n    driver()\n</code></pre> <ul> <li> <p>The <code>info()</code> function provides the data necessary to plan the execution of the script.   It is executed when calling the script as <code>./script.py plan</code>.</p> <p>Note</p> <p>All dictionary items are optional. The <code>info()</code> function can even return an empty dictionary. The keys <code>inp</code>, <code>out</code>, <code>static</code>, <code>stdout</code> and <code>stderr</code> affect the planning the run part, as explained in the comments above.</p> </li> <li> <p>The <code>run()</code> function is called to perform the useful work and   is executed when the script is executed as <code>./script.py run</code>.</p> <p>Note</p> <p>The <code>run()</code> function can have any argument defined in the dictionary returned by <code>info()</code>, but it does not have to specify all of them. The argument list of <code>run()</code> can contain fewer arguments (or even none at all).</p> </li> </ul>"},{"location":"getting_started/script_single/#example","title":"Example","text":"<p>Example source files: <code>docs/getting_started/script_single/</code></p> <p>Consider a script that has parameters defined in a config file <code>config.json</code>, which may be used by multiple script, e.g. for reasons of consistency. For this example, the configuration contains a number of steps and a frequency in arbitrary units, serialized in a JSON file:</p> <pre><code>{\n  \"nstep\": 100,\n  \"freq\": 0.1\n}\n</code></pre> <p>This file is used in a script <code>generate.py</code> as follows:</p> <pre><code>#!/usr/bin/env python3\nimport json\n\nimport numpy as np\n\nfrom stepup.core.script import driver\n\n\ndef info():\n    return {\n        \"inp\": \"config.json\",\n        \"out\": [\"cos.npy\", \"sin.npy\"],\n    }\n\n\ndef run(inp, out):\n    with open(\"config.json\") as fh:\n        config = json.load(fh)\n    nstep = config[\"nstep\"]\n    freq = config[\"freq\"]\n    np.save(out[0], np.cos(2 * np.pi * freq * np.arange(nstep)))\n    np.save(out[1], np.sin(2 * np.pi * freq * np.arange(nstep)))\n\n\nif __name__ == \"__main__\":\n    driver()\n</code></pre> <p>Also, add the following <code>plan.py</code> file:</p> <pre><code>#!/usr/bin/env python3\nfrom stepup.core.api import script, static\n\nstatic(\"generate.py\", \"config.json\")\nscript(\"generate.py\")\n</code></pre> <p>Finally, make the Python scripts executable and give StepUp a spin:</p> <pre><code>chmod +x generate.py plan.py\nstepup -n 1\n</code></pre> <p>You should see the following output on screen:</p> <pre><code>  DIRECTOR \u2502 Listening on /tmp/stepup-########/director (StepUp 2.0.4)\n   STARTUP \u2502 (Re)initialized boot script\n  DIRECTOR \u2502 Launched worker 0\n     PHASE \u2502 run\n     START \u2502 ./plan.py\n   SUCCESS \u2502 ./plan.py\n     START \u2502 ./generate.py plan\n   SUCCESS \u2502 ./generate.py plan\n     START \u2502 ./generate.py run\n   SUCCESS \u2502 ./generate.py run\n  DIRECTOR \u2502 Trying to delete 0 outdated output(s).\n  DIRECTOR \u2502 Stopping workers.\n  DIRECTOR \u2502 See you!\n</code></pre> <p>As expected, this creates two files: <code>cos.npy</code> and <code>sin.npy</code>.</p>"},{"location":"getting_started/script_single/#try-the-following","title":"Try the Following","text":"<ul> <li> <p>Modify the file <code>config.json</code> and re-run StepUp.   The planning is skipped because the script itself did not change.   Only the run function is called to work with the updated <code>config.json</code>.</p> </li> <li> <p>Delete one of the outputs and rerun StepUp.   Again, the planning is skipped and the computation is repeated to recreate the missing output.</p> </li> <li> <p>Create a new module <code>utils.py</code> with a <code>compute()</code> function to calculate the cosine and sine arrays   with parameters <code>nstep</code> and <code>freq</code>.   Import this module into <code>generate.py</code>, use it in <code>run()</code> and re-run StepUp.   This will automatically make <code>utils.py</code> an input for the planning and running of <code>generate.py</code>.   Test this by making a small change to <code>utils.py</code> and re-running it.   (Note that local imports inside the <code>run()</code> function will not be identified automatically and   are therefore not recommended.)</p> </li> </ul>"},{"location":"getting_started/static_files/","title":"Static Files","text":"<p>When steps use input files written by you, this must be explicitly stated in <code>plan.py</code> by declaring the human-written files as static files. This informs StepUp that it does not need to wait for other steps whose outputs are the required files.</p>"},{"location":"getting_started/static_files/#example","title":"Example","text":"<p>Example source files: <code>docs/getting_started/static_files/</code></p> <p>Create a file <code>limerick.txt</code> with the following contents:</p> <pre><code>A physicist named Erwin, quite shrewd,\nPut a feline in a box rather crude.\nWith a vial of doom,\nAnd radioactive gloom,\nThe poor cat's fate, both alive and subdued!\n</code></pre> <p>Also create the following <code>plan.py</code>:</p> <pre><code>#!/usr/bin/env python3\nfrom stepup.core.api import static, step\n\nstatic(\"limerick.txt\")\nstep(\"nl ${inp} &gt; ${out}\", inp=\"limerick.txt\", out=\"numbered.txt\")\n</code></pre> <p>The <code>static()</code> function declares a static file, i.e. one that you have created.</p> <p>Make the plan executable and run it with StepUp as follows:</p> <pre><code>chmod +x plan.py\nstepup -n 1\n</code></pre> <p>You should get the following output:</p> <pre><code>  DIRECTOR \u2502 Listening on /tmp/stepup-########/director (StepUp 2.0.4)\n   STARTUP \u2502 (Re)initialized boot script\n  DIRECTOR \u2502 Launched worker 0\n     PHASE \u2502 run\n     START \u2502 ./plan.py\n   SUCCESS \u2502 ./plan.py\n     START \u2502 nl limerick.txt &gt; numbered.txt\n   SUCCESS \u2502 nl limerick.txt &gt; numbered.txt\n  DIRECTOR \u2502 Trying to delete 0 outdated output(s).\n  DIRECTOR \u2502 Stopping workers.\n  DIRECTOR \u2502 See you!\n</code></pre> <p>As expected, StepUp does not wait for another step to create <code>limerick.txt</code> because the file is static. The file <code>numbered.txt</code> will contain a copy of the limerick with line numbers.</p>"},{"location":"getting_started/static_files/#try-the-following","title":"Try the Following","text":"<ul> <li> <p>Replace <code>gloom</code> by <code>boom</code> in <code>limerick.txt</code> and run <code>stepup -n 1</code> again.   The line numbering is repeated, but the step <code>./plan.py</code> is skipped as it did not change.</p> </li> <li> <p>Change the order of <code>static()</code> and <code>step()</code> in <code>plan.py</code> and run <code>stepup -n 1</code> again.   This has no apparent effect, but the step is only sent to the worker process after the director   is informed that the file <code>limerick.txt</code> is static.</p> </li> <li> <p>Comment out the <code>static()</code> function call and run <code>stepup -n 1</code> again.   StepUp will refuse to execute the line numbering step and will show a warning explaining why.</p> </li> </ul>"},{"location":"getting_started/static_glob/","title":"Static Glob","text":"<p>Explicitly declaring static files with the <code>static()</code> function from the previous tutorial becomes tedious when dealing with many static files. To simplify matters, StepUp supports \u201cglob\u201d patterns, i.e., wildcards such as <code>*</code> and <code>?</code>.</p> <p>The <code>glob()</code> function is similar to <code>static()</code> and supports globbing, including some non-standard glob techniques discussed in the following tutorials.</p> <p>Here, only the basic usage of <code>glob()</code> is covered. In the following tutorial, the use of <code>glob()</code> in conditionals is discussed. See Static Named Glob and Static Deferred Glob for more advanced use cases.</p>"},{"location":"getting_started/static_glob/#example","title":"Example","text":"<p>Example source files: <code>docs/getting_started/static_glob/</code></p> <p>Create a subdirectory <code>src/</code> with two files: <code>sub/foo.txt</code> and <code>sub/bar.txt</code>. Also, create a <code>plan.py</code> file with the following contents:</p> <pre><code>#!/usr/bin/env python3\nfrom stepup.core.api import copy, glob, mkdir, static\n\nstatic(\"src/\")\nmkdir(\"dst/\")\nfor path_src in glob(\"src/*.txt\"):\n    copy(path_src, \"dst/\")\n</code></pre> <p>Make the plan executable and run it non-interactively:</p> <pre><code>chmod +x plan.py\nstepup -n 1\n</code></pre> <p>This should produce the following output:</p> <pre><code>  DIRECTOR \u2502 Listening on /tmp/stepup-########/director (StepUp 2.0.4)\n   STARTUP \u2502 (Re)initialized boot script\n  DIRECTOR \u2502 Launched worker 0\n     PHASE \u2502 run\n     START \u2502 ./plan.py\n   SUCCESS \u2502 ./plan.py\n     START \u2502 mkdir -p dst/\n   SUCCESS \u2502 mkdir -p dst/\n     START \u2502 cp -aT src/bar.txt dst/bar.txt\n   SUCCESS \u2502 cp -aT src/bar.txt dst/bar.txt\n     START \u2502 cp -aT src/foo.txt dst/foo.txt\n   SUCCESS \u2502 cp -aT src/foo.txt dst/foo.txt\n  DIRECTOR \u2502 Trying to delete 0 outdated output(s).\n  DIRECTOR \u2502 Stopping workers.\n  DIRECTOR \u2502 See you!\n</code></pre> <p>Note that all files found by the <code>glob()</code> function are declared static in the workflow. Hence, they cannot be outputs of other steps. (This is not optional.)</p>"},{"location":"getting_started/static_glob/#try-the-following","title":"Try the Following","text":"<ul> <li> <p>Run StepUp again without making any changes.   You will notice that the <code>./plan.py</code> step is executed again despite not having changed it.   When StepUp starts from scratch,   it has to assume that new files could have been added (since the last run) and   that match the glob pattern.   Hence, a step calling the <code>glob()</code> function cannot be skipped.   (This can be avoided when using StepUp interactively. More on that later.)</p> </li> <li> <p>Add a file <code>src/egg.txt</code> and run StepUp again with the same arguments.   You will notice that known steps for <code>sub/foo.txt</code> and <code>sub/bar.txt</code> are skipped.   A new step is added for <code>src/egg.txt</code>.</p> </li> </ul>"},{"location":"getting_started/static_glob_conditional/","title":"Static Glob Conditional","text":"<p>The <code>glob()</code> function introduced in the previous tutorial also works in conditional expressions. This is particularly useful when not using any wildcards at all:</p> <pre><code>from stepup.core.api import glob\n\nif glob(\"dataset/\"):\n    # The dataset exists, is a directory and is now static.\n    # Steps for plan A.\n    ...\nelse:\n    # The directory dataset is not available.\n    # Steps for plan B.\n    ...\n</code></pre> <p>A similar conditional would not work with the <code>static()</code> function because it would raise an exception when the file does not exist.</p>"},{"location":"getting_started/static_glob_conditional/#example","title":"Example","text":"<p>Example source files: <code>docs/getting_started/static_glob_conditional/</code></p> <p>Let\u2019s simulate a scenario where <code>dataset/</code>, if it exists, is remote storage with a huge dataset. Plan A is to extract useful information from the dataset. However, there may be reasons why this is not always possible or desirable:</p> <ul> <li>Not all your collaborators may have access to this storage at all times.</li> <li>The extraction is slow or expensive otherwise.</li> </ul> <p>Plan B is to use the results of the extraction from a previous run and declare them as static files.</p> <p>Create the following <code>plan.py</code>:</p> <pre><code>#!/usr/bin/env python3\nfrom stepup.core.api import glob, static, step\n\nif glob(\"dataset/\"):\n    static(\"dataset/bigfile.txt\", \"expensive.py\")\n    step(\n        \"./expensive.py\",\n        inp=[\"dataset/bigfile.txt\", \"expensive.py\"],\n        out=\"average.txt\",\n    )\nelse:\n    static(\"average.txt\")\n\nstep(\"cat average.txt\", inp=\"average.txt\")\n</code></pre> <p>For this example, the script <code>expensive.py</code> is not expensive at all. It just serves as an illustration of a more realistic scenario where this script may do some non-tritial work. In this example, <code>expensive.py</code> just computes the average of all numbers in <code>dataset/bigfile.txt</code> and writes out the result to <code>average.txt</code>:</p> <pre><code>#!/usr/bin/env python3\n\ntotal = 0.0\ncount = 0\nwith open(\"dataset/bigfile.txt\") as fh:\n    for line in fh:\n        total += float(line)\n        count += 1\n\nwith open(\"average.txt\", \"w\") as fh:\n    print(f\"{total / count:f}\", file=fh)\n</code></pre> <p>Now put some values in <code>dataset/bigfile.txt</code>, e.g.:</p> <pre><code>1.2\n2.3\n7.9\n1.8\n-0.3\n</code></pre> <p>To run the example, make the scripts executable and fire up StepUp in non-interactive mode:</p> <pre><code>chmod +x expensive.py plan.py\nstepup -n 1\n</code></pre> <p>You should get the following output:</p> <pre><code>  DIRECTOR \u2502 Listening on /tmp/stepup-########/director (StepUp 2.0.3.post4)\n   STARTUP \u2502 (Re)initialized boot script\n  DIRECTOR \u2502 Launched worker 0\n     PHASE \u2502 run\n     START \u2502 ./plan.py\n   SUCCESS \u2502 ./plan.py\n     START \u2502 ./expensive.py\n   SUCCESS \u2502 ./expensive.py\n     START \u2502 cat average.txt\n   SUCCESS \u2502 cat average.txt\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 Standard output \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n2.580000\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n  DIRECTOR \u2502 Trying to delete 0 outdated output(s).\n  DIRECTOR \u2502 Stopping workers.\n  DIRECTOR \u2502 See you!\n</code></pre> <p>Now, simulate the situation where the dataset is absent by renaming the directory:</p> <pre><code>mv dataset tmp\nstepup -n 1\n</code></pre> <p>The new output reveals that the dataset is completely ignored while the file <code>average.txt</code> is still used:</p> <pre><code>  DIRECTOR \u2502 Listening on /tmp/stepup-########/director (StepUp 2.0.3.post4)\n   STARTUP \u2502 Making failed steps pending\n   STARTUP \u2502 Watching 2 director(y|ies) from initial database\n   STARTUP \u2502 Scanning initial database for changed files\n   DELETED \u2502 dataset/\n   DELETED \u2502 dataset/bigfile.txt\n   STARTUP \u2502 Scanning initial database for new nglob matches\n  DIRECTOR \u2502 Launched worker 0\n     PHASE \u2502 run\n     START \u2502 ./plan.py\n   SUCCESS \u2502 ./plan.py\n      SKIP \u2502 cat average.txt\n  DIRECTOR \u2502 Trying to delete 0 outdated output(s).\n  DIRECTOR \u2502 Stopping workers.\n  DIRECTOR \u2502 See you!\n</code></pre> <p>Since the file <code>average.txt</code> did not change, the step <code>cat average.txt</code> is skipped.</p>"},{"location":"getting_started/static_glob_conditional/#practical-considerations","title":"Practical Considerations","text":"<ul> <li> <p>For simplity\u2019s sake, the example involves few calculations.   In a more realistic setting, the step <code>cat average.txt</code> is replaced by several scripts that   make visualizations of the information extracted from the large dataset.   Tweaking these visualizations for clarity usually takes some iterations,   for which access to the large dataset is not necessary.</p> </li> <li> <p>A StepUp project practically always resides in a Git repository.   While the files extracted from the large dataset can be reproduced easily,   it may still be relevant to commit them into the Git repository:</p> <ul> <li> <p>Not all collaborators may have access to the dataset,   but you still want them to be able to reproduce the workflow.</p> </li> <li> <p>In the long run, the large dataset might be removed   because it is too big and old to keep around.   The extracted data then become a relevant and compact subset   that can be easily stored for longer periods.</p> </li> </ul> </li> </ul>"},{"location":"getting_started/workdir/","title":"Working directory","text":"<p>Every step is executed in a working directory, which you can specify when creating a step. If the arguments <code>inp</code>, <code>out</code> and <code>vol</code> contain relative paths, they are assumed to be relative to the working directory.</p> <p>Warning</p> <p>StepUp assumes that the current working directory is not changed between importing any <code>stepup</code> module and calling functions from <code>stepup.core.api</code></p>"},{"location":"getting_started/workdir/#example","title":"Example","text":"<p>Example source files: <code>docs/getting_started/workdir/</code></p> <p>Create a top-level <code>plan.py</code> as follows:</p> <pre><code>#!/usr/bin/env python3\nfrom stepup.core.api import static, step\n\nstatic(\"out/\")\nstep(\"echo 'a friendly file' &gt; ${out}\", workdir=\"out/\", out=\"hello.txt\")\n</code></pre> <p>Make the scripts executable and run everything as follows:</p> <pre><code>chmod +x plan.py\nmkdir out/\nstepup -n 1\n</code></pre> <p>You should get the following terminal output:</p> <pre><code>  DIRECTOR \u2502 Listening on /tmp/stepup-########/director (StepUp 2.0.4)\n   STARTUP \u2502 (Re)initialized boot script\n  DIRECTOR \u2502 Launched worker 0\n     PHASE \u2502 run\n     START \u2502 ./plan.py\n   SUCCESS \u2502 ./plan.py\n     START \u2502 echo 'a friendly file' &gt; hello.txt  # wd=out/\n   SUCCESS \u2502 echo 'a friendly file' &gt; hello.txt  # wd=out/\n  DIRECTOR \u2502 Trying to delete 0 outdated output(s).\n  DIRECTOR \u2502 Stopping workers.\n  DIRECTOR \u2502 See you!\n</code></pre> <p>This will create an output file <code>out/hello.txt</code></p>"},{"location":"getting_started/workdir/#further-reading","title":"Further reading","text":"<ul> <li> <p>The <code>step()</code> function   and related functions that use <code>step()</code> internally   all return a <code>StepInfo</code> object,   which may be used for defining follow-up steps.   The <code>StepInfo</code> objects follow the same convention:   their <code>inp</code>, <code>out</code> and <code>vol</code> attributes are lists of paths.   If these are relative paths, they are relative to the <code>step_info.workdir</code> attribute.   Consult the section StepInfo Objects for more details.</p> </li> <li> <p>In advanced workflows, the HERE and ROOT variables   can be convenient to construct relative paths based on the current working directory.</p> </li> </ul>"},{"location":"reference/environment_variables/","title":"Environment Variables","text":"<p>The following environment variables can be used to configure StepUp.</p> <ul> <li><code>STEPUP_DEBUG</code>: Set to <code>\"1\"</code> to enable debug output.   This implies <code>STEPUP_LOG_LEVEL=DEBUG</code> (if the variable is unset)   and will require internal consistency checks to pass,   rather than applying corrections to overcome the inconsistencies.   (Every such inconsistency is due to a bug, which should be fixed eventually.)</li> <li><code>STEPUP_EXTERNAL_SOURCES</code>: a colon-separated list of directories outside <code>STEPUP_ROOT</code>   where automatically detected dependencies should be retained and converted to relative paths.   This is useful when you have source files that are not part of the StepUp project.   For example, if you are developing a Python library and use it in a StepUp project,   changes to the development version of the library will cause StepUp to re-run the affected steps.   This variable can contain absolute paths and paths relative to <code>STEPUP_ROOT</code>.</li> <li><code>STEPUP_LOG_LEVEL</code>: The log level to use for the log files in <code>~/.stepup/</code>.   Possible values are <code>DEBUG</code>, <code>INFO</code>, <code>WARNING</code>, <code>ERROR</code>, and <code>CRITICAL</code>.   The default is <code>WARNING</code>.   (This can be overridden by the <code>--log-level</code> command-line option.)</li> <li><code>STEPUP_ROOT</code>: The root directory containing the top-level <code>plan.py</code> file.   If not set, StepUp will look for this file in the current directory.</li> <li><code>STEPUP_SYNC_RPC_TIMOUT</code>: The timeout in seconds for the synchronous RPC server.   The default is 300 seconds.   Set this to a smaller value if you want to detect deadlocks more quickly.</li> </ul> <p>We recommend using tools like direnv to manage these variables. Once <code>direnv</code> is installed and configured, you can create a <code>.envrc</code> file in the root directory of your project, e.g. with the following contents:</p> <pre><code>export STEPUP_ROOT=${PWD}\n</code></pre> <p>When you change to the project directory (or any of its subdirectories) in your shell, the environment variables will be set automatically.</p>"},{"location":"reference/interactive/","title":"Interactive Command Reference","text":"<p>Note</p> <p>Changes as of StepUp 2.0.0:</p> <ul> <li>The command-line options related to interactive usage have changed.</li> <li>Keyboard interaction is always available, irrespective of the command-line options.</li> <li>The <code>f</code> and <code>t</code> keys have been removed.</li> </ul> <p>By default, StepUp performs a single pass execution of the workflow. You can use StepUp interactively by adding <code>-w</code> (manual re-run) or <code>-W</code> (automatic re-run) to the command line. When pressing a key on the keyboard, StepUp responds by executing a corresponding command. If the key is not associated with any command, the following help message appears:</p> <pre><code>\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 Keys \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\n   r = run     q = shutdown     d = drain     j = join     g = graph\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n</code></pre> <p>These commands are defined as follows:</p> <ul> <li><code>r = run</code>:   Runs steps that are affected by file changes registered during the watch phase.</li> <li><code>q = shutdown</code>:   StepUp waits for the workers to complete their current job and will not start new jobs.   As soon as all workers are idle, StepUp exits.   If it takes to long for the steps to complete, you can press <code>q</code> again to kill them with <code>SIGINT</code>.   Pres <code>q</code> for a third time to kill the steps with <code>SIGKILL</code>. (nuclear option)</li> <li><code>d = drain</code>:   StepUp waits for the workers to complete their current job and will not start new jobs.   As soon as all workers are idle, StepUp transitions into the watch phase.</li> <li><code>j = join</code>:   StepUp continues running jobs until no new jobs can be found to send to the workers.   As soon as all workers are idle, StepUp terminates.</li> <li><code>g = graph</code>:   Writes out the workflow graph in text format to a file named <code>graph.txt</code>.   (This human-readable file contains most of the information from <code>.stepup/workflow.mp.xz</code>)</li> </ul> <p>Note that these interactive keys also work without the <code>-w</code> or <code>-W</code> option, except for <code>r</code> which only has an effect during the watch phase.</p> <p>Note that <code>SIGINT</code> (pressing <code>Ctrl+C</code>) and <code>SIGTERM</code> (sending a <code>kill</code> signal) are also supported to stop StepUp.</p>"},{"location":"reference/stepup.core.api/","title":"stepup.core.api","text":"<p>You can expect reasonable stability of the API documented here over the future releases of StepUp. (No hard promises, since StepUp is still very young.) Other parts of StepUp, not documented here, may undergo larger changes and are not intended to be API stable.</p>"},{"location":"reference/stepup.core.api/#basic-api","title":"Basic API","text":""},{"location":"reference/stepup.core.api/#stepup.core.api.static","title":"<code>stepup.core.api.static(*paths)</code>","text":"<p>Declare static paths.</p> <p>Parameters:</p> <ul> <li> <code>*paths</code>               (<code>str | Iterable[str]</code>, default:                   <code>()</code> )           \u2013            <p>One or more static paths (files or directories), relative to the current working directory. Arguments may also be lists of strings.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>When a file does not exist or there is an error with the trailing separator.</p> </li> </ul> Notes <p>Environment variables in the <code>paths</code> will be substituted directly and amend the current step\u2019s env_vars list, if needed. These substitutions will ignore changes to <code>os.environ</code> made in the calling script.</p> Source code in <code>stepup/core/api.py</code> <pre><code>def static(*paths: str | Iterable[str]):\n    \"\"\"Declare static paths.\n\n    Parameters\n    ----------\n    *paths\n        One or more static paths (files or directories),\n        relative to the current working directory.\n        Arguments may also be lists of strings.\n\n    Raises\n    ------\n    ValueError\n        When a file does not exist or there is an error with the trailing separator.\n\n    Notes\n    -----\n    Environment variables in the `paths` will be\n    substituted directly and amend the current step's env_vars list, if needed.\n    These substitutions will ignore changes to `os.environ` made in the calling script.\n    \"\"\"\n    # Turn paths into one big list.\n    _paths = paths\n    paths = []\n    for path in _paths:\n        if isinstance(path, str):\n            paths.append(path)\n        elif isinstance(path, Iterable):\n            paths.extend(path)\n    del _paths\n\n    # Avoid empty RPC calls.\n    if len(paths) &gt; 0:\n        # Perform env var substitutions.\n        with subs_env_vars() as subs:\n            su_paths = [subs(path) for path in paths]\n        # Sanity checks\n        _check_inp_paths(su_paths)\n        # Translate paths to make them relative to the working directory of the director.\n        tr_paths = sorted(translate(su_path) for su_path in su_paths)\n        # Declare the missing and then confirm the files.\n        to_check = RPC_CLIENT.call.missing(_get_step_key(), tr_paths)\n        _confirm_missing(to_check)\n</code></pre>"},{"location":"reference/stepup.core.api/#stepup.core.api.glob","title":"<code>stepup.core.api.glob(*patterns, _required=False, _defer=False, **subs)</code>","text":"<p>Declare static paths through pattern matching.</p> <p>Parameters:</p> <ul> <li> <code>*patterns</code>               (<code>str</code>, default:                   <code>()</code> )           \u2013            <p>One or more patterns for static files or directories, relative to the current working directory. The patterns may contain (named) wildcards and one may specify the pattern for each named wildcard with the keyword arguments.</p> </li> <li> <code>_required</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>When True, an error will be raised when there are no matches.</p> </li> <li> <code>_defer</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>When True, static files are not added yet. Instead, the glob is installed in the workflow as a deferred glob. As soon as any file is needed as input and matches the pattern, it will be made static. This is not compatible with <code>_required=True</code>. Named wildcards are not supported in deferred globs.</p> </li> <li> <code>**subs</code>               (<code>str</code>, default:                   <code>{}</code> )           \u2013            <p>When using named wildcards, they will match the pattern <code>*</code> by default. Through the subs argument each name can be associated with another glob pattern. Names starting with underscores are not allowed.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>FileNotFoundError</code>             \u2013            <p>when no matches were found and _required is True.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ngm</code>           \u2013            <p>An <code>NGlobMulti</code> instance holding all the matched (combinations of) paths. This object acts as an iterator. When named wildcards are used, it iterates over <code>NGlobMatch</code> instances. When using only anonymous wildcards, it iterates over unique paths. It also features <code>ngm.matches()</code> and <code>ngm.files()</code> iterators, with which the type of iterator can be overruled. Finally, one may also use ngm in conditional expressions: It evaluates to True if and only if it contains some matches.</p> <p><code>None</code> is returned when <code>_defer=True</code>.</p> </li> </ul> Notes <p>The combinatorics allow one to construct nested loops easily in one call. For unrelated patterns, it may be more efficient to use separate <code>glob</code> calls.</p> <p>Environment variables in the <code>patterns</code> will be substituted directly and amend the current step\u2019s env_vars list, if needed. These substitutions will ignore changes to <code>os.environ</code> made in the calling script.</p> Source code in <code>stepup/core/api.py</code> <pre><code>def glob(\n    *patterns: str, _required: bool = False, _defer: bool = False, **subs: str\n) -&gt; NGlobMulti | None:\n    \"\"\"Declare static paths through pattern matching.\n\n    Parameters\n    ----------\n    *patterns\n        One or more patterns for static files or directories,\n        relative to the current working directory.\n        The patterns may contain (named) wildcards and one\n        may specify the pattern for each named wildcard with\n        the keyword arguments.\n    _required\n        When True, an error will be raised when there are no matches.\n    _defer\n        When True, static files are not added yet.\n        Instead, the glob is installed in the workflow as a deferred glob.\n        As soon as any file is needed as input and matches the pattern,\n        it will be made static.\n        This is not compatible with `_required=True`.\n        Named wildcards are not supported in deferred globs.\n    **subs\n        When using named wildcards, they will match the pattern `*` by default.\n        Through the subs argument each name can be associated with another glob pattern.\n        Names starting with underscores are not allowed.\n\n    Raises\n    ------\n    FileNotFoundError\n        when no matches were found and _required is True.\n\n    Returns\n    -------\n    ngm\n        An `NGlobMulti` instance holding all the matched (combinations of) paths.\n        This object acts as an iterator.\n        When named wildcards are used, it iterates over `NGlobMatch` instances.\n        When using only anonymous wildcards, it iterates over unique paths.\n        It also features `ngm.matches()` and `ngm.files()` iterators,\n        with which the type of iterator can be overruled.\n        Finally, one may also use ngm in conditional expressions:\n        It evaluates to True if and only if it contains some matches.\n\n        `None` is returned when `_defer=True`.\n\n    Notes\n    -----\n    The combinatorics allow one to construct nested loops easily in one call.\n    For unrelated patterns, it may be more efficient to use separate `glob` calls.\n\n    Environment variables in the `patterns` will be\n    substituted directly and amend the current step's env_vars list, if needed.\n    These substitutions will ignore changes to `os.environ` made in the calling script.\n    \"\"\"\n    if len(patterns) == 0:\n        raise ValueError(\"At least one path is required for glob.\")\n    if any(name.startswith(\"_\") for name in subs):\n        raise ValueError(\"Substitutions cannot have names starting with underscores.\")\n\n    # Substitute environment variables\n    with subs_env_vars() as subs_path:\n        su_patterns = [subs_path(pattern) for pattern in patterns]\n\n    tr_patterns = [translate(su_pattern) for su_pattern in su_patterns]\n    if _defer:\n        if _required:\n            raise ValueError(\"Combination of options not supported: _defer=True, _required=True\")\n        if len(subs) &gt; 0:\n            raise ValueError(\"Named wildcards are not supported in deferred globs.\")\n        to_check = RPC_CLIENT.call.defer(_get_step_key(), tr_patterns)\n        _check_deferred(to_check)\n        return None\n\n    # Collect all matches\n    nglob_multi = NGlobMulti.from_patterns(su_patterns, subs)\n    nglob_multi.glob()\n    if _required and len(nglob_multi.results) == 0:\n        raise FileNotFoundError(\"Could not find any matching paths on the filesystem.\")\n\n    # Send static paths\n    static_paths = nglob_multi.files()\n    if len(static_paths) &gt; 0:\n        _check_inp_paths(static_paths)\n        tr_static_paths = [translate(static_path) for static_path in static_paths]\n        to_check = RPC_CLIENT.call.missing(_get_step_key(), tr_static_paths)\n        _confirm_missing(to_check)\n\n    # Translate all the nglob matches with matching paths and send to the director.\n    tr_all_paths = [\n        translate(path)\n        for nglob_single in nglob_multi.nglob_singles\n        for paths in nglob_single.results.values()\n        for path in paths\n    ]\n    RPC_CLIENT.call.nglob(_get_step_key(), tr_patterns, subs, tr_all_paths)\n\n    # Done\n    return nglob_multi\n</code></pre>"},{"location":"reference/stepup.core.api/#stepup.core.api.step","title":"<code>stepup.core.api.step(command, *, inp=(), env=(), out=(), vol=(), workdir='./', optional=False, pool=None, block=False)</code>","text":"<p>Add a step to the build graph.</p> <p>Parameters:</p> <ul> <li> <code>command</code>               (<code>str</code>)           \u2013            <p>Command to execute (in the working directory of the director).</p> </li> <li> <code>inp</code>               (<code>Collection[str] | str</code>, default:                   <code>()</code> )           \u2013            <p>File(s) required by the step. Relative paths are assumed to be relative to <code>workdir</code>. Can be files or directories (trailing slash).</p> </li> <li> <code>env</code>               (<code>Collection[str] | str</code>, default:                   <code>()</code> )           \u2013            <p>Environment variable(s) to which the step is sensitive. If they change, or when they are (un)defined, the step digest will change, such that the step cannot be skipped.</p> </li> <li> <code>out</code>               (<code>Collection[str] | str</code>, default:                   <code>()</code> )           \u2013            <p>File(s) created by the step. Relative paths are assumed to be relative to <code>workdir</code>. These can be files or directories (trailing slash).</p> </li> <li> <code>vol</code>               (<code>Collection[str] | str</code>, default:                   <code>()</code> )           \u2013            <p>Volatile file(s) created by the step Relative paths are assumed to be relative to <code>workdir</code>. Directories are not allowed.</p> </li> <li> <code>workdir</code>               (<code>str</code>, default:                   <code>'./'</code> )           \u2013            <p>The directory where the command must be executed. A trailing slash is added when not present. If this is a relative path, it is relative to the work directory of the caller. (The default is the current directory.)</p> </li> <li> <code>optional</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>When set to True, the step is only executed when required by other mandatory steps.</p> </li> <li> <code>pool</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>If given, the execution of this step is restricted to the pool with the given name. The maximum number of parallel steps running in this pool is determined by the pool size.</p> </li> <li> <code>block</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>When set to True, the step will always remain pending. This can be used to temporarily prevent part of the workflow from being executed.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>step_info</code>           \u2013            <p>Holds relevant information of the step, useful for defining follow-up steps.</p> </li> </ul> Notes <p>Environment variables in the <code>workdir</code>, <code>inp</code>, <code>out</code> and <code>vol</code> paths and workdir will be substituted directly and amend the current step\u2019s env_vars list, if needed. These substitutions will ignore changes to <code>os.environ</code> made in the calling script.</p> <p>Before sending the step to the director the variables <code>${inp}</code>, <code>${out}</code> and <code>${vol}</code> in the command are substituted by white-space concatenated list of <code>inp</code>, <code>out</code> and <code>vol</code>, respectively. Relative paths in <code>inp</code>, <code>out</code> and <code>vol</code> are relative to the working directory of the new step.</p> Source code in <code>stepup/core/api.py</code> <pre><code>def step(\n    command: str,\n    *,\n    inp: Collection[str] | str = (),\n    env: Collection[str] | str = (),\n    out: Collection[str] | str = (),\n    vol: Collection[str] | str = (),\n    workdir: str = \"./\",\n    optional: bool = False,\n    pool: str | None = None,\n    block: bool = False,\n) -&gt; StepInfo:\n    \"\"\"Add a step to the build graph.\n\n    Parameters\n    ----------\n    command\n        Command to execute (in the working directory of the director).\n    inp\n        File(s) required by the step.\n        Relative paths are assumed to be relative to `workdir`.\n        Can be files or directories (trailing slash).\n    env\n        Environment variable(s) to which the step is sensitive.\n        If they change, or when they are (un)defined, the step digest will change,\n        such that the step cannot be skipped.\n    out\n        File(s) created by the step.\n        Relative paths are assumed to be relative to `workdir`.\n        These can be files or directories (trailing slash).\n    vol\n        Volatile file(s) created by the step\n        Relative paths are assumed to be relative to `workdir`.\n        Directories are not allowed.\n    workdir\n        The directory where the command must be executed.\n        A trailing slash is added when not present.\n        If this is a relative path, it is relative to the work directory of the caller.\n        (The default is the current directory.)\n    optional\n        When set to True, the step is only executed when required by other mandatory steps.\n    pool\n        If given, the execution of this step is restricted to the pool with the given name.\n        The maximum number of parallel steps running in this pool is determined by the pool size.\n    block\n        When set to True, the step will always remain pending.\n        This can be used to temporarily prevent part of the workflow from being executed.\n\n    Returns\n    -------\n    step_info\n        Holds relevant information of the step, useful for defining follow-up steps.\n\n    Notes\n    -----\n    Environment variables in the `workdir`, `inp`, `out` and `vol` paths and workdir will be\n    substituted directly and amend the current step's env_vars list, if needed.\n    These substitutions will ignore changes to `os.environ` made in the calling script.\n\n    Before sending the step to the director the variables `${inp}`, `${out}` and `${vol}`\n    in the command are substituted by white-space concatenated list of `inp`, `out` and\n    `vol`, respectively.\n    Relative paths in `inp`, `out` and `vol` are relative to the working directory of the new step.\n    \"\"\"\n    # Pre-process the arguments for the Director process.\n    inp_paths = _str_to_list(inp)\n    env_vars = _str_to_list(env)\n    out_paths = _str_to_list(out)\n    vol_paths = _str_to_list(vol)\n    if not workdir.endswith(\"/\"):\n        workdir = f\"{workdir}/\"\n    amended_env_vars = set()\n    with subs_env_vars() as subs:\n        su_inp_paths = [subs(inp_path) for inp_path in inp_paths]\n        su_out_paths = [subs(out_path) for out_path in out_paths]\n        su_vol_paths = [subs(vol_path) for vol_path in vol_paths]\n        su_workdir = subs(workdir)\n    amend(env=sorted(amended_env_vars))\n    tr_inp_paths = [translate(inp_path, su_workdir) for inp_path in su_inp_paths]\n    tr_out_paths = [translate(out_path, su_workdir) for out_path in su_out_paths]\n    tr_vol_paths = [translate(vol_path, su_workdir) for vol_path in su_vol_paths]\n    tr_workdir = translate(su_workdir)\n    # Substitute paths that are translated back to the current directory.\n    command = CaseSensitiveTemplate(command).safe_substitute(\n        inp=shlex.join(su_inp_paths),\n        out=shlex.join(su_out_paths),\n        vol=shlex.join(su_vol_paths),\n    )\n\n    # Finally create the step.\n    to_check = RPC_CLIENT.call.step(\n        _get_step_key(),\n        command,\n        tr_inp_paths,\n        env_vars,\n        tr_out_paths,\n        tr_vol_paths,\n        tr_workdir,\n        optional,\n        pool,\n        block,\n    )\n\n    # Check the existence of files matching deferred globs.\n    _check_deferred(to_check)\n\n    # Return a StepInfo instance to facilitate the definition of follow-up steps\n    return StepInfo(command, tr_workdir, su_inp_paths, env_vars, su_out_paths, su_vol_paths)\n</code></pre>"},{"location":"reference/stepup.core.api/#stepup.core.api.pool","title":"<code>stepup.core.api.pool(name, size)</code>","text":"<p>Define a pool with given size or change an existing pool size.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The name of the pool.</p> </li> <li> <code>size</code>               (<code>int</code>)           \u2013            <p>The pool size.</p> </li> </ul> Source code in <code>stepup/core/api.py</code> <pre><code>def pool(name: str, size: int):\n    \"\"\"Define a pool with given size or change an existing pool size.\n\n    Parameters\n    ----------\n    name\n        The name of the pool.\n    size\n        The pool size.\n    \"\"\"\n    RPC_CLIENT.call.pool(_get_step_key(), name, size)\n</code></pre>"},{"location":"reference/stepup.core.api/#stepup.core.api.amend","title":"<code>stepup.core.api.amend(*, inp=(), env=(), out=(), vol=())</code>","text":"<p>Specify additional inputs and outputs from within a running step.</p> <p>Parameters:</p> <ul> <li> <code>inp</code>               (<code>Collection[str] | str</code>, default:                   <code>()</code> )           \u2013            <p>Files required by the step. Can be files or directories (trailing slash).</p> </li> <li> <code>env</code>               (<code>Collection[str] | str</code>, default:                   <code>()</code> )           \u2013            <p>Environment variables to which the step is sensitive. If the change, or when they are (un)defined, the step digest will change, such that the step is not skipped when these variables change.</p> </li> <li> <code>out</code>               (<code>Collection[str] | str</code>, default:                   <code>()</code> )           \u2013            <p>Files created by the step. Can be files or directories (trailing slash).</p> </li> <li> <code>vol</code>               (<code>Collection[str] | str</code>, default:                   <code>()</code> )           \u2013            <p>Volatile files created by the step. Can be files or directories (trailing slash).</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>InputNotFoundError</code>             \u2013            <p>When amended inputs are not available yet. There is no need to catch this exception. Instead, just let it fail the calling script, so that it can be rescheduled for later execution. The director has been informed that some of the amended inputs were not available yet.</p> </li> </ul> Notes <p>Environment variables in the <code>inp</code>, <code>out</code> and <code>vol</code> paths are substituted in the same way as in the <code>step()</code> function. The used variables are added to the env_vars argument.</p> <p>Always call amend before using the input files and before creating the output and volatile files.</p> Source code in <code>stepup/core/api.py</code> <pre><code>def amend(\n    *,\n    inp: Collection[str] | str = (),\n    env: Collection[str] | str = (),\n    out: Collection[str] | str = (),\n    vol: Collection[str] | str = (),\n):\n    \"\"\"Specify additional inputs and outputs from within a running step.\n\n    Parameters\n    ----------\n    inp\n        Files required by the step.\n        Can be files or directories (trailing slash).\n    env\n        Environment variables to which the step is sensitive.\n        If the change, or when they are (un)defined, the step digest will change,\n        such that the step is not skipped when these variables change.\n    out\n        Files created by the step.\n        Can be files or directories (trailing slash).\n    vol\n        Volatile files created by the step.\n        Can be files or directories (trailing slash).\n\n    Raises\n    ------\n    InputNotFoundError\n        When amended inputs are not available yet.\n        There is no need to catch this exception.\n        Instead, just let it fail the calling script,\n        so that it can be rescheduled for later execution.\n        The director has been informed that some of the amended inputs were not available yet.\n\n    Notes\n    -----\n    Environment variables in the `inp`, `out` and `vol` paths are substituted in the same way\n    as in the `step()` function. The used variables are added to the env_vars argument.\n\n    Always call amend before using the input files\n    and before creating the output and volatile files.\n    \"\"\"\n    # Pre-process the arguments for the Director process.\n    inp_paths = _str_to_list(inp)\n    env_vars = _str_to_list(env)\n    out_paths = _str_to_list(out)\n    vol_paths = _str_to_list(vol)\n    if all(len(collection) == 0 for collection in [inp_paths, env_vars, out_paths, vol_paths]):\n        return\n    env_vars = set(env_vars)\n    with subs_env_vars() as subs:\n        su_inp_paths = [subs(inp_path) for inp_path in inp_paths]\n        tr_inp_paths = [translate(inp_path) for inp_path in su_inp_paths]\n        tr_out_paths = [translate(subs(out_path)) for out_path in out_paths]\n        tr_vol_paths = [translate(subs(vol_path)) for vol_path in vol_paths]\n\n    # Finally, amend for real.\n    step_key = _get_step_key()\n    amend_result = RPC_CLIENT.call.amend(\n        step_key,\n        tr_inp_paths,\n        sorted(env_vars),\n        tr_out_paths,\n        tr_vol_paths,\n    )\n    if amend_result is not None:\n        keep_going, to_check = amend_result\n        if keep_going is False:\n            raise InputNotFoundError(\"Amended inputs are not available yet.\")\n        _check_deferred(to_check, step_key)\n    # Double check that all inputs are indeed present.\n    _check_inp_paths(su_inp_paths)\n</code></pre>"},{"location":"reference/stepup.core.api/#stepup.core.api.getinfo","title":"<code>stepup.core.api.getinfo()</code>","text":"<p>Get the information of the current step.</p> <p>Returns:</p> <ul> <li> <code>step_info</code>           \u2013            <p>Holds relevant information of the step, useful for defining follow-up steps. For consistency with other functions in this module, the <code>inp</code>, <code>out</code> and <code>vol</code> paths are relative to the working directory of the step.</p> </li> </ul> Source code in <code>stepup/core/api.py</code> <pre><code>def getinfo() -&gt; StepInfo:\n    \"\"\"Get the information of the current step.\n\n    Returns\n    -------\n    step_info\n        Holds relevant information of the step, useful for defining follow-up steps.\n        For consistency with other functions in this module, the `inp`, `out` and `vol`\n        paths are relative to the working directory of the step.\n    \"\"\"\n    step_info = RPC_CLIENT.call.getinfo(_get_step_key())\n    # Update paths to make them relative to the working directory of the step.\n    step_info.inp = sorted(translate.back(inp) for inp in step_info.inp)\n    step_info.out = sorted(translate.back(out) for out in step_info.out)\n    step_info.vol = sorted(translate.back(vol) for vol in step_info.vol)\n    # Filter required directorie out of the inputs.\n    reqdirs = {myparent(path) for path in step_info.out}\n    reqdirs.update({myparent(path) for path in step_info.vol})\n    step_info.inp = [path for path in step_info.inp if path not in reqdirs]\n    return step_info\n</code></pre>"},{"location":"reference/stepup.core.api/#composite-api","title":"Composite API","text":""},{"location":"reference/stepup.core.api/#stepup.core.api.plan","title":"<code>stepup.core.api.plan(subdir, *, inp=(), env=(), out=(), vol=(), optional=False, pool=None, block=False)</code>","text":"<p>Run a <code>plan.py</code> script in a subdirectory.</p> <p>Parameters:</p> <ul> <li> <code>subdir</code>               (<code>str</code>)           \u2013            <p>The subdirectory in which another <code>plan.py</code> script can be found. The file must be executable and have <code>#!/usr/bin/env python3</code> as its first line. A trailing slash is added when not present.</p> </li> <li> <code>inp</code>               (<code>Collection[str] | str</code>, default:                   <code>()</code> )           \u2013            <p>See the <code>step()</code> function for more information. (Rarely needed for planning steps.)</p> </li> <li> <code>env</code>               (<code>Collection[str] | str</code>, default:                   <code>()</code> )           \u2013            <p>See the <code>step()</code> function for more information. (Rarely needed for planning steps.)</p> </li> <li> <code>out</code>               (<code>Collection[str] | str</code>, default:                   <code>()</code> )           \u2013            <p>See the <code>step()</code> function for more information. (Rarely needed for planning steps.)</p> </li> <li> <code>vol</code>               (<code>Collection[str] | str</code>, default:                   <code>()</code> )           \u2013            <p>See the <code>step()</code> function for more information. (Rarely needed for planning steps.)</p> </li> <li> <code>optional</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>See the <code>step()</code> function for more information. (Rarely needed for planning steps.) Use with care, since the nodes created by plan script will be unknown upfront and cannot therefore imply the necessity of an optional plan step.</p> </li> <li> <code>pool</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>See the <code>step()</code> function for more information. (Rarely needed for planning steps.)</p> </li> <li> <code>block</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>See the <code>step()</code> function for more information. (Rarely needed for planning steps.)</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>step_info</code>           \u2013            <p>Holds relevant information of the step, useful for defining follow-up steps.</p> </li> </ul> Source code in <code>stepup/core/api.py</code> <pre><code>def plan(\n    subdir: str,\n    *,\n    inp: Collection[str] | str = (),\n    env: Collection[str] | str = (),\n    out: Collection[str] | str = (),\n    vol: Collection[str] | str = (),\n    optional: bool = False,\n    pool: str | None = None,\n    block: bool = False,\n) -&gt; StepInfo:\n    \"\"\"Run a `plan.py` script in a subdirectory.\n\n    Parameters\n    ----------\n    subdir\n        The subdirectory in which another `plan.py` script can be found.\n        The file must be executable and have `#!/usr/bin/env python3` as its first line.\n        A trailing slash is added when not present.\n    inp, env, out, vol\n        See the [`step()`][stepup.core.api.step] function for more information.\n        (Rarely needed for planning steps.)\n    optional\n        See the [`step()`][stepup.core.api.step] function for more information.\n        (Rarely needed for planning steps.)\n        Use with care, since the nodes created by plan script will be unknown upfront\n        and cannot therefore imply the necessity of an optional plan step.\n    pool\n        See the [`step()`][stepup.core.api.step] function for more information.\n        (Rarely needed for planning steps.)\n    block\n        See the [`step()`][stepup.core.api.step] function for more information.\n        (Rarely needed for planning steps.)\n\n    Returns\n    -------\n    step_info\n        Holds relevant information of the step, useful for defining follow-up steps.\n    \"\"\"\n    with subs_env_vars() as subs:\n        subdir = subs(subdir)\n    return step(\n        \"./plan.py\",\n        inp=[\"plan.py\", *_str_to_list(inp)],\n        env=env,\n        out=out,\n        vol=vol,\n        workdir=subdir,\n        optional=optional,\n        pool=pool,\n        block=block,\n    )\n</code></pre>"},{"location":"reference/stepup.core.api/#stepup.core.api.copy","title":"<code>stepup.core.api.copy(src, dst, *, optional=False, block=False)</code>","text":"<p>Add a step that copies a file.</p> <p>Parameters:</p> <ul> <li> <code>src</code>               (<code>str</code>)           \u2013            <p>This must be a file. Environment variables are substituted.</p> </li> <li> <code>dst</code>               (<code>str</code>)           \u2013            <p>This can be a file or a directory. Environment variables are substituted. If it is a directory, it must have a trailing slash.</p> </li> <li> <code>optional</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>When True, the file is only copied when needed as input for another step.</p> </li> <li> <code>block</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>When True, the step will always remain pending.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>step_info</code>           \u2013            <p>Holds relevant information of the step, useful for defining follow-up steps.</p> </li> </ul> Source code in <code>stepup/core/api.py</code> <pre><code>def copy(src: str, dst: str, *, optional: bool = False, block: bool = False) -&gt; StepInfo:\n    \"\"\"Add a step that copies a file.\n\n    Parameters\n    ----------\n    src\n        This must be a file. Environment variables are substituted.\n    dst\n        This can be a file or a directory. Environment variables are substituted.\n        If it is a directory, it must have a trailing slash.\n    optional\n        When True, the file is only copied when needed as input for another step.\n    block\n        When True, the step will always remain pending.\n\n    Returns\n    -------\n    step_info\n        Holds relevant information of the step, useful for defining follow-up steps.\n    \"\"\"\n    amended_env_vars = set()\n    with subs_env_vars() as subs:\n        src = subs(src)\n        dst = subs(dst)\n    path_src = mynormpath(src)\n    path_dst = make_path_out(src, dst, None)\n    amend(env=amended_env_vars)\n    return step(\"cp -aT ${inp} ${out}\", inp=path_src, out=path_dst, optional=optional, block=block)\n</code></pre>"},{"location":"reference/stepup.core.api/#stepup.core.api.mkdir","title":"<code>stepup.core.api.mkdir(dirname, *, optional=False, block=False)</code>","text":"<p>Make a directory.</p> <p>Parameters:</p> <ul> <li> <code>dirname</code>               (<code>str</code>)           \u2013            <p>The director to create. A trailing slash is added when not present. Environment variables are substituted.</p> </li> <li> <code>optional</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>When True, the directory is only created when needed by other steps.</p> </li> <li> <code>block</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>When True, the step will always remain pending.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>step_info</code>           \u2013            <p>Holds relevant information of the step, useful for defining follow-up steps.</p> </li> </ul> Source code in <code>stepup/core/api.py</code> <pre><code>def mkdir(dirname: str, *, optional: bool = False, block: bool = False) -&gt; StepInfo:\n    \"\"\"Make a directory.\n\n    Parameters\n    ----------\n    dirname\n        The director to create.\n        A trailing slash is added when not present.\n        Environment variables are substituted.\n    optional\n        When True, the directory is only created when needed by other steps.\n    block\n        When True, the step will always remain pending.\n\n    Returns\n    -------\n    step_info\n        Holds relevant information of the step, useful for defining follow-up steps.\n    \"\"\"\n    amended_env_vars = set()\n    with subs_env_vars() as subs:\n        dirname = subs(dirname)\n    if not dirname.endswith(\"/\"):\n        dirname += \"/\"\n    dirname = mynormpath(dirname)\n    amend(env=amended_env_vars)\n    return step(f\"mkdir -p {dirname}\", out=dirname, optional=optional, block=block)\n</code></pre>"},{"location":"reference/stepup.core.api/#stepup.core.api.getenv","title":"<code>stepup.core.api.getenv(name, default=None, *, path=False, back=False, multi=False)</code>","text":"<p>Get an environment variable and amend the current step with the variable name.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The name of the environment variable, which is retrieved with <code>os.getenv</code>.</p> </li> <li> <code>default</code>               (<code>Path | str | None</code>, default:                   <code>None</code> )           \u2013            <p>The value to return when the environment variable is unset.</p> </li> <li> <code>path</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Set to True if the variable taken from the environment is assumed to be a path. A Path instance will be returned. Shell variables are substituted (once) in such paths.</p> </li> <li> <code>back</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Set to True to translate the path back to the working directory of the caller. If the path is relative, it is assumed to be relative to the StepUp\u2019s working directory. It will be translated to become relative to the working directory of the caller. This implies <code>path=True</code>.</p> </li> <li> <code>multi</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Set to True if the variable is a list of paths. The paths are split on the colon character and returned as a list of <code>Path</code> instances. This implies <code>path=True</code>.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>value</code>           \u2013            <p>The value of the environment variable. If <code>path</code> is set to <code>True</code>, this is a <code>Path</code> instance. If <code>back</code> is set to <code>True</code>, this is a translated <code>Path</code> instance. If <code>multi</code> is set to <code>True</code>, this is a list of <code>Path</code> instances. Otherwise, the result is a string.</p> </li> </ul> Notes <p>The optional arguments of this function have changed in StepUp 2.0.0.</p> Source code in <code>stepup/core/api.py</code> <pre><code>def getenv(\n    name: str,\n    default: Path | str | None = None,\n    *,\n    path: bool = False,\n    back: bool = False,\n    multi: bool = False,\n) -&gt; str | Path | list[Path]:\n    \"\"\"Get an environment variable and amend the current step with the variable name.\n\n    Parameters\n    ----------\n    name\n        The name of the environment variable, which is retrieved with `os.getenv`.\n    default\n        The value to return when the environment variable is unset.\n    path\n        Set to True if the variable taken from the environment is assumed to be a path.\n        A Path instance will be returned.\n        Shell variables are substituted (once) in such paths.\n    back\n        Set to True to translate the path back to the working directory of the caller.\n        If the path is relative, it is assumed to be relative to the StepUp's working directory.\n        It will be translated to become relative to the working directory of the caller.\n        This implies `path=True`.\n    multi\n        Set to True if the variable is a list of paths.\n        The paths are split on the colon character and returned as a list of `Path` instances.\n        This implies `path=True`.\n\n    Returns\n    -------\n    value\n        The value of the environment variable.\n        If `path` is set to `True`, this is a `Path` instance.\n        If `back` is set to `True`, this is a translated `Path` instance.\n        If `multi` is set to `True`, this is a list of `Path` instances.\n        Otherwise, the result is a string.\n\n    Notes\n    -----\n    The optional arguments of this function have changed in StepUp 2.0.0.\n    \"\"\"\n    path = path or back or multi\n    value = os.getenv(name, default)\n    # Do not amend environment variables set by the worker.\n    if name not in [\"HERE\", \"ROOT\"]:\n        amend(env=name)\n    if multi:\n        if value is None:\n            return []\n        value = [item.strip() for item in value.split(\":\")]\n        with subs_env_vars() as subs:\n            value = [subs(item) for item in value if len(item) &gt; 0]\n        if back:\n            value = [translate.back(item) for item in value if len(item) &gt; 0]\n    elif path:\n        if value is None:\n            raise ValueError(f\"Undefined shell variable: {name}. Cannot create path.\")\n        with subs_env_vars() as subs:\n            value = subs(value)\n        if back:\n            value = translate.back(value)\n    return value\n</code></pre>"},{"location":"reference/stepup.core.api/#stepup.core.api.call","title":"<code>stepup.core.api.call(executable, *, prefix=None, fmt='auto', inp=None, env=(), out=None, vol=(), workdir='./', optional=False, pool=None, block=False, pars=None, **kwargs)</code>","text":"<p>Call an executable with a set of serialized arguments.</p> <p>This function assumes that the executable implements StepUp\u2019s call protocol.</p> <p>Parameters:</p> <ul> <li> <code>executable</code>               (<code>str</code>)           \u2013            <p>The path of a local executable script to call. Environment variables are substituted. The path of the executable is assumed to be relative to this directory.</p> </li> <li> <code>prefix</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The prefix used to construct filenames of the input (serialized arguments) and optionally output file (serialized return value). If absent, the prefix is the stem of the executable.</p> </li> <li> <code>fmt</code>               (<code>str</code>, default:                   <code>'auto'</code> )           \u2013            <p>The format used for serialization of arguments (and optionally return values). Can be <code>\"auto\"</code>, <code>\"json\"</code> or <code>\"pickle\"</code>. In case <code>\"auto\"</code>, the <code>\"json\"</code> format is used, unless that fails, then <code>\"pickle\"</code> is used as the fallback option. If input or output files are given, the format is deduced from their extension.</p> </li> <li> <code>inp</code>               (<code>Sequence | str | bool | None</code>, default:                   <code>None</code> )           \u2013            <p>The path of the input file:</p> <ul> <li>If <code>None</code>: The arguments are JSON serialized and passed to the script on the command line.   If the types of the keyword arguments are incompatible with JSON,   a pickle file is created whose filename is derived from <code>prefix</code>.</li> <li>If <code>True</code>: an input file is always written to a path derived from <code>prefix</code> and <code>fmt</code>,   even if no keyword arguments are given.</li> <li>If <code>str</code>: an input file is written if some extra <code>**kwargs</code> are given,   and <code>fmt</code> is deduced from the extension.   Without keyword arguments, the input file is assumed to be the output of another step.</li> <li>If <code>Sequence</code>, the first item is used according to one of the previous points,   depending on its type.   Remaining items are add to the <code>inp</code> argument of the <code>step()</code> function,   and are added to <code>kwargs['inp']</code>.</li> </ul> </li> <li> <code>env</code>               (<code>Collection[str] | str</code>, default:                   <code>()</code> )           \u2013            <p>See the <code>step()</code> function for more information.</p> </li> <li> <code>out</code>               (<code>Sequence | str | bool | None</code>, default:                   <code>None</code> )           \u2013            <p>The path of the output file:</p> <ul> <li>If <code>None</code>: the script may write an output file. (This is the most flexible option.)   The output path is derived from <code>prefix</code> and <code>fmt</code>.   The script is called with arguments <code>--out={path_out}</code> and <code>--amend-out</code>,   so the script can decide whether to write the output file.</li> <li>If <code>str</code>: the script is called with the argument <code>--out={path_out}</code>   and is expected to create this output file unconditionally.   (No <code>amend(out=path_out)</code> is needed.)</li> <li>If <code>True</code>, similar to the previous, except that   the output path is derived from <code>prefix</code> and <code>fmt</code>.</li> <li>If <code>False</code>, the script is not called with <code>--out</code>   and is not expected to write an output file.   (This is useful to keep things minimal.)</li> <li>If <code>Sequence</code>, the first item is used according one of the previous points,   depending on its type.   Remaining items are add to the <code>out</code> argument of the <code>step()</code> function,   and are added to <code>kwargs['out']</code>.</li> </ul> </li> <li> <code>vol</code>               (<code>Collection[str] | str</code>, default:                   <code>()</code> )           \u2013            <p>See the <code>step()</code> function for more information.</p> </li> <li> <code>workdir</code>               (<code>str</code>, default:                   <code>'./'</code> )           \u2013            <p>See the <code>step()</code> function for more information.</p> </li> <li> <code>optional</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>See the <code>step()</code> function for more information.</p> </li> <li> <code>pool</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>See the <code>step()</code> function for more information.</p> </li> <li> <code>block</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>See the <code>step()</code> function for more information.</p> </li> <li> <code>pars</code>               (<code>dict[str] | None</code>, default:                   <code>None</code> )           \u2013            <p>A dictionary with additional parameters for the script. They will be merged with the arguments in <code>kwargs</code>. (This can be useful to pass arguments whose name coincide with the arguments above.)</p> </li> <li> <code>kwargs</code>           \u2013            <p>If given, these are serialized to the input file. If absent, no input file is written unless <code>inp</code> is <code>True</code>.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>step_info</code>           \u2013            <p>Holds relevant information of the step, useful for defining follow-up steps.</p> </li> </ul> Notes <p>This is an experimental feature introduced in StepUp 2.0.0. It may undergo significant revisions in future 2.x releases.</p> <p>When the <code>inp</code>, <code>env</code>, <code>out</code> and <code>vol</code> arguments contain items, they are also included in the keyword arguments passed to the script. However, they do not count as extra keyword arguments to determine if an input file must be written when <code>inp</code> is a string or a sequence of strings.</p> <p>When using the call protocol, it is recommended to add the following lines to <code>.gitignore</code>:</p> <pre><code>*_inp.json\n*_inp.pickle\n*_out.json\n*_out.pickle\n</code></pre> Source code in <code>stepup/core/api.py</code> <pre><code>def call(\n    executable: str,\n    *,\n    prefix: str | None = None,\n    fmt: str = \"auto\",\n    inp: Sequence | str | bool | None = None,\n    env: Collection[str] | str = (),\n    out: Sequence | str | bool | None = None,\n    vol: Collection[str] | str = (),\n    workdir: str = \"./\",\n    optional: bool = False,\n    pool: str | None = None,\n    block: bool = False,\n    pars: dict[str] | None = None,\n    **kwargs,\n) -&gt; StepInfo:\n    \"\"\"Call an executable with a set of serialized arguments.\n\n    This function assumes that the executable implements StepUp's\n    [call protocol](../getting_started/call.md).\n\n    Parameters\n    ----------\n    executable\n        The path of a local executable script to call.\n        Environment variables are substituted.\n        The path of the executable is assumed to be relative to this directory.\n    prefix\n        The prefix used to construct filenames of the input (serialized arguments)\n        and optionally output file (serialized return value).\n        If absent, the prefix is the stem of the executable.\n    fmt\n        The format used for serialization of arguments (and optionally return values).\n        Can be `\"auto\"`, `\"json\"` or `\"pickle\"`.\n        In case `\"auto\"`, the `\"json\"` format is used,\n        unless that fails, then `\"pickle\"` is used as the fallback option.\n        If input or output files are given, the format is deduced from their extension.\n    inp\n        The path of the input file:\n\n        - If `None`: The arguments are JSON serialized and passed to the script on the command line.\n          If the types of the keyword arguments are incompatible with JSON,\n          a pickle file is created whose filename is derived from `prefix`.\n        - If `True`: an input file is always written to a path derived from `prefix` and `fmt`,\n          even if no keyword arguments are given.\n        - If `str`: an input file is written if some extra `**kwargs` are given,\n          and `fmt` is deduced from the extension.\n          Without keyword arguments, the input file is assumed to be the output of another step.\n        - If `Sequence`, the first item is used according to one of the previous points,\n          depending on its type.\n          Remaining items are add to the `inp` argument of the `step()` function,\n          and are added to `kwargs['inp']`.\n    env\n        See the [`step()`][stepup.core.api.step] function for more information.\n    out\n        The path of the output file:\n\n        - If `None`: the script may write an output file. (This is the most flexible option.)\n          The output path is derived from `prefix` and `fmt`.\n          The script is called with arguments `--out={path_out}` and `--amend-out`,\n          so the script can decide whether to write the output file.\n        - If `str`: the script is called with the argument `--out={path_out}`\n          and is expected to create this output file unconditionally.\n          (No `amend(out=path_out)` is needed.)\n        - If `True`, similar to the previous, except that\n          the output path is derived from `prefix` and `fmt`.\n        - If `False`, the script is not called with `--out`\n          and is not expected to write an output file.\n          (This is useful to keep things minimal.)\n        - If `Sequence`, the first item is used according one of the previous points,\n          depending on its type.\n          Remaining items are add to the `out` argument of the `step()` function,\n          and are added to `kwargs['out']`.\n\n    vol\n        See the [`step()`][stepup.core.api.step] function for more information.\n    workdir\n        See the [`step()`][stepup.core.api.step] function for more information.\n    optional\n        See the [`step()`][stepup.core.api.step] function for more information.\n    pool\n        See the [`step()`][stepup.core.api.step] function for more information.\n    block\n        See the [`step()`][stepup.core.api.step] function for more information.\n    pars\n        A dictionary with additional parameters for the script.\n        They will be merged with the arguments in `kwargs`.\n        (This can be useful to pass arguments whose name coincide with the arguments above.)\n    kwargs\n        If given, these are serialized to the input file.\n        If absent, no input file is written unless `inp` is `True`.\n\n    Returns\n    -------\n    step_info\n        Holds relevant information of the step, useful for defining follow-up steps.\n\n    Notes\n    -----\n    This is an experimental feature introduced in StepUp 2.0.0.\n    It may undergo significant revisions in future 2.x releases.\n\n    When the `inp`, `env`, `out` and `vol` arguments contain items,\n    they are also included in the keyword arguments passed to the script.\n    However, they do not count as extra keyword arguments to determine if an input file\n    must be written when `inp` is a string or a sequence of strings.\n\n    When using the call protocol, it is recommended to add the following lines to `.gitignore`:\n\n    ```\n    *_inp.json\n    *_inp.pickle\n    *_out.json\n    *_out.pickle\n    ```\n    \"\"\"\n    # Preprocess inp and out in case they are lists.\n    if not isinstance(inp, str) and isinstance(inp, Sequence):\n        other_inp = inp[1:]\n        inp = inp[0]\n    else:\n        other_inp = []\n    if not isinstance(out, str) and isinstance(out, Sequence):\n        other_out = out[1:]\n        out = out[0]\n    else:\n        other_out = []\n\n    if fmt not in [\"auto\", \"json\", \"pickle\"]:\n        raise ValueError(f\"Invalid format for serialization of arguments: {fmt}.\")\n    if inp not in [None, True] and not isinstance(inp, str):\n        raise ValueError(\"Invalid value for _inp. Must be None, True, str or Sequence[str].\")\n    if not (out in [None, True, False] or isinstance(out, str)):\n        raise ValueError(\"Invalid value for _out. Must be None, True, False, str or Sequence[str].\")\n    if prefix is None:\n        prefix = Path(executable).stem\n    with subs_env_vars() as subs:\n        executable = subs(executable)\n        workdir = subs(workdir)\n\n    # Determine the format from given filenames\n    if (isinstance(inp, str) or isinstance(out, str)) and fmt != \"auto\":\n        raise ValueError(\"When specifying input or output files, the format cannot be set.\")\n    if fmt == \"auto\":\n        if isinstance(inp, str):\n            fmt = Path(inp).suffix[1:]\n        elif isinstance(out, str):\n            fmt = Path(out).suffix[1:]\n\n    # Write the input file\n    serial = None\n    if pars is not None:\n        kwargs.update(pars)\n    if len(other_inp) &gt; 0:\n        kwargs.setdefault(\"inp\", []).extend(other_inp)\n    if len(other_out) &gt; 0:\n        kwargs.setdefault(\"out\", []).extend(other_out)\n    if len(kwargs) &gt; 0:\n        if fmt in [\"json\", \"auto\"]:\n            try:\n                serial = json.dumps(kwargs, indent=None if inp is None else 2)\n                fmt = \"json\"\n            except TypeError:\n                if fmt == \"auto\":\n                    fmt = \"pickle\"\n                else:\n                    raise\n        if fmt == \"pickle\":\n            serial = pickle.dumps(kwargs)\n\n    if fmt == \"auto\":\n        fmt = \"json\"\n    if fmt not in [\"json\", \"pickle\"]:\n        raise ValueError(f\"Invalid format for serialization of arguments: {fmt}.\")\n\n    # Prepare arguments for the step function\n    step_kwargs = {\n        \"inp\": [*other_inp],\n        \"env\": env,\n        \"out\": [*other_out],\n        \"vol\": vol,\n        \"workdir\": workdir,\n        \"optional\": optional,\n        \"pool\": pool,\n        \"block\": block,\n    }\n\n    # Input handling\n    command = format_command(executable)\n    path_inp = f\"{prefix}_inp.{fmt}\" if ((fmt == \"pickle\" and inp is None) or inp is True) else inp\n    if serial is not None:\n        # Provide input some way.\n        if path_inp is None:\n            command += \" \" + shlex.quote(serial)\n        else:\n            amend(out=path_inp)\n            if isinstance(serial, str):\n                with open(path_inp, \"w\") as fh:\n                    fh.write(serial)\n            else:\n                with open(path_inp, \"bw\") as fh:\n                    fh.write(serial)\n    if isinstance(path_inp, str):\n        # There is an input file, either created here or elsewhere.\n        step_kwargs[\"inp\"].insert(0, path_inp)\n        command += f\" --inp={shlex.quote(path_inp)}\"\n\n    # Output handling\n    path_out = f\"{prefix}_out.{fmt}\" if (out is None or out is True) else out\n    if isinstance(path_out, str):\n        # The output file is created here.\n        command += f\" --out={shlex.quote(path_out)}\"\n        if out is None:\n            command += \" --amend-out\"\n        else:\n            step_kwargs[\"out\"].insert(0, path_out)\n\n    # Finally, create a step\n    step_kwargs.setdefault(\"inp\", []).append(executable)\n    return step(command, **step_kwargs)\n</code></pre>"},{"location":"reference/stepup.core.api/#stepup.core.api.script","title":"<code>stepup.core.api.script(executable, *, step_info=None, inp=(), env=(), out=(), vol=(), workdir='./', optional=False, pool=None, block=False)</code>","text":"<p>Run the executable with a single argument <code>plan</code> in a working directory.</p> <p>This function assumes that the executable implements StepUp\u2019s script protocol.</p> <p>Parameters:</p> <ul> <li> <code>executable</code>               (<code>str</code>)           \u2013            <p>The path of a local executable that will be called with the argument <code>plan</code>. The file must be executable. The path of the script is assumed to be relative to this directory.</p> </li> <li> <code>step_info</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>When given, the steps generated in the plan part of the executable are written to this <code>step_info</code> file. (See stepup.core.stepinfo module for the file format.) This filename is relative to the work directory.</p> </li> <li> <code>inp</code>               (<code>Collection[str] | str</code>, default:                   <code>()</code> )           \u2013            <p>See the <code>step()</code> function for more information.</p> </li> <li> <code>env</code>               (<code>Collection[str] | str</code>, default:                   <code>()</code> )           \u2013            <p>See the <code>step()</code> function for more information.</p> </li> <li> <code>out</code>               (<code>Collection[str] | str</code>, default:                   <code>()</code> )           \u2013            <p>See the <code>step()</code> function for more information.</p> </li> <li> <code>vol</code>               (<code>Collection[str] | str</code>, default:                   <code>()</code> )           \u2013            <p>See the <code>step()</code> function for more information.</p> </li> <li> <code>workdir</code>               (<code>str</code>, default:                   <code>'./'</code> )           \u2013            <p>See the <code>step()</code> function for more information.</p> </li> <li> <code>optional</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>See the <code>step()</code> function for more information.</p> </li> <li> <code>pool</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>See the <code>step()</code> function for more information.</p> </li> <li> <code>block</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>See the <code>step()</code> function for more information.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>step_info</code>           \u2013            <p>Holds relevant information of the step, useful for defining follow-up steps.</p> </li> </ul> Notes <ul> <li>The arguments <code>inp</code>, <code>env</code>, <code>out</code>, <code>vol</code> and <code>pool</code> are rarely needed for script steps.   They only apply to the plan stage of the script, not the run stage.</li> <li>The <code>inp</code> argument may be useful when the planning is configured by some input files.</li> <li>The optional argument never applies to the plan stage,   and is passed on the the run stage.</li> </ul> Source code in <code>stepup/core/api.py</code> <pre><code>def script(\n    executable: str,\n    *,\n    step_info: str | None = None,\n    inp: Collection[str] | str = (),\n    env: Collection[str] | str = (),\n    out: Collection[str] | str = (),\n    vol: Collection[str] | str = (),\n    workdir: str = \"./\",\n    optional: bool = False,\n    pool: str | None = None,\n    block: bool = False,\n) -&gt; StepInfo:\n    \"\"\"Run the executable with a single argument `plan` in a working directory.\n\n    This function assumes that the executable implements StepUp's\n    [script protocol](../getting_started/script_single.md).\n\n    Parameters\n    ----------\n    executable\n        The path of a local executable that will be called with the argument `plan`.\n        The file must be executable.\n        The path of the script is assumed to be relative to this directory.\n    step_info\n        When given, the steps generated in the plan part of the executable are written\n        to this `step_info` file. (See [stepup.core.stepinfo][] module for the file format.)\n        This filename is relative to the work directory.\n    inp, env, out, vol\n        See the [`step()`][stepup.core.api.step] function for more information.\n    workdir\n        See the [`step()`][stepup.core.api.step] function for more information.\n    optional\n        See the [`step()`][stepup.core.api.step] function for more information.\n    pool\n        See the [`step()`][stepup.core.api.step] function for more information.\n    block\n        See the [`step()`][stepup.core.api.step] function for more information.\n\n    Returns\n    -------\n    step_info\n        Holds relevant information of the step, useful for defining follow-up steps.\n\n    Notes\n    -----\n    - The arguments `inp`, `env`, `out`, `vol` and `pool` are rarely needed for script steps.\n      They only apply to the plan stage of the script, not the run stage.\n    - The `inp` argument may be useful when the planning is configured by some input files.\n    - The optional argument never applies to the plan stage,\n      and is passed on the the run stage.\n    \"\"\"\n    with subs_env_vars() as subs:\n        executable = subs(executable)\n        workdir = subs(workdir)\n    command = format_command(executable) + \" plan\"\n    out = _str_to_list(out)\n    if step_info is not None:\n        command += \" --step-info=\" + shlex.quote(step_info)\n        out.append(step_info)\n    if optional:\n        command += \" --optional\"\n    inp = _str_to_list(inp)\n    inp.append(executable)\n    return step(\n        command, inp=inp, env=env, out=out, vol=vol, workdir=workdir, pool=pool, block=block\n    )\n</code></pre>"},{"location":"reference/stepup.core.api/#utilities-for-api-extensions","title":"Utilities for API extensions","text":""},{"location":"reference/stepup.core.api/#stepup.core.api.subs_env_vars","title":"<code>stepup.core.api.subs_env_vars()</code>","text":"<p>A context manager for substituting environment variables and tracking the used variables.</p> <p>The context manager yields a function, <code>subs</code>, which takes a string with variables and returns the substituted form. All used variables are recorded and sent to the director with <code>amend(env=...)</code>. For example:</p> <pre><code>with subs_env_vars() as subs:\n    path_inp = subs(path_inp)\n    path_out = subs(path_out)\n</code></pre> <p>This function may be used in other API functions to substitute environment variables in all relevant paths.</p> Source code in <code>stepup/core/api.py</code> <pre><code>@contextlib.contextmanager\ndef subs_env_vars() -&gt; Iterator[Callable[[str | None], str | None]]:\n    \"\"\"A context manager for substituting environment variables and tracking the used variables.\n\n    The context manager yields a function, `subs`, which takes a string with variables and\n    returns the substituted form.\n    All used variables are recorded and sent to the director with `amend(env=...)`.\n    For example:\n\n    ```python\n    with subs_env_vars() as subs:\n        path_inp = subs(path_inp)\n        path_out = subs(path_out)\n    ```\n\n    This function may be used in other API functions to substitute environment variables in\n    all relevant paths.\n    \"\"\"\n    env_vars = set()\n\n    def subs(path: str | None) -&gt; Path | None:\n        if path is None:\n            return None\n        template = CaseSensitiveTemplate(path)\n        if not template.is_valid():\n            raise ValueError(\"The path contains invalid shell variable identifiers.\")\n        mapping = {}\n        for name in template.get_identifiers():\n            if name.startswith(\"*\"):\n                mapping[name] = f\"${{{name}}}\"\n            else:\n                value = os.getenv(name)\n                if value is None:\n                    raise ValueError(f\"Undefined shell variable: {name}\")\n                mapping[name] = value\n                env_vars.add(name)\n        result = path if len(mapping) == 0 else template.substitute(mapping)\n        return mynormpath(result)\n\n    yield subs\n    amend(env=env_vars)\n</code></pre>"},{"location":"reference/stepup.core.call/","title":"stepup.core.call","text":"<p>Driver function to facilitate writing scripts that adhere to StepUp\u2019s call protocol.</p> <p>See Call Protocol for more details.</p>"},{"location":"reference/stepup.core.call/#stepup.core.call.driver","title":"<code>driver(obj=None)</code>","text":"<p>Implement call protocol.</p> <p>The most common usage is to call <code>driver()</code> from a script that defines a <code>run()</code> function, e.g.:</p> <pre><code>#!/usr/bin/env python3\nfrom stepup.core.call import driver\n\ndef run(a: int, b: int) -&gt; int:\n    return a + b\n\nif __name__ == \"__main__\":\n    driver()\n</code></pre> <p>Parameters:</p> <ul> <li> <code>obj</code>               (<code>Any</code>, default:                   <code>None</code> )           \u2013            <p>When not provided, the namespace of the module where <code>driver</code> is defined will be searched for the name \u2018run\u2019 to implement the call protocol. When an object is given as a parameter, its attributes are searched instead.</p> </li> </ul> Source code in <code>stepup/core/call.py</code> <pre><code>def driver(obj: Any = None):\n    \"\"\"Implement call protocol.\n\n    The most common usage is to call `driver()` from a script that defines a `run()` function, e.g.:\n\n    ```python\n    #!/usr/bin/env python3\n    from stepup.core.call import driver\n\n    def run(a: int, b: int) -&gt; int:\n        return a + b\n\n    if __name__ == \"__main__\":\n        driver()\n    ```\n\n    Parameters\n    ----------\n    obj\n        When not provided, the namespace of the module where `driver` is defined\n        will be searched for the name 'run' to implement the call protocol.\n        When an object is given as a parameter, its attributes are searched instead.\n    \"\"\"\n    frame = inspect.currentframe().f_back\n    script_path = Path(frame.f_locals[\"__file__\"]).relpath()\n    if obj is None:\n        # Get the calling module and use it as obj\n        module_name = frame.f_locals[\"__name__\"]\n        obj = sys.modules.get(module_name)\n        if obj is None:\n            raise ValueError(\n                f\"The driver must be called from an imported module, got {module_name}\"\n            )\n    args = parse_args(script_path)\n\n    # Load the keyword arguments\n    if args.json_inp is not None:\n        kwargs = json.loads(args.json_inp)\n    elif args.path_inp is None:\n        kwargs = {}\n    elif args.path_inp.suffix == \".json\":\n        with open(args.path_inp) as fh:\n            kwargs = json.load(fh)\n    elif args.path_inp.suffix == \".pickle\":\n        with open(args.path_inp, \"rb\") as fh:\n            kwargs = pickle.load(fh)\n    else:\n        raise NotImplementedError(f\"Unsupported input file format: {args.path_inp.suffix}\")\n\n    # Call the run function\n    run = getattr(obj, \"run\", None)\n    if run is None:\n        raise AttributeError(\"The module must define a 'run' function\")\n    # Filter kwargs to only include those accepted by the run function\n    run_signature = inspect.signature(run)\n    filtered_kwargs = {k: v for k, v in kwargs.items() if k in run_signature.parameters}\n    # Turn inp, out and vol kwargs into lists of Path instances.\n    for key in (\"inp\", \"out\", \"vol\"):\n        key_paths = filtered_kwargs.get(key)\n        if isinstance(key_paths, str):\n            filtered_kwargs[key] = Path(key_paths)\n        elif isinstance(key_paths, list):\n            filtered_kwargs[key] = [Path(p) for p in key_paths]\n    # Call the run function with the filtered kwargs.\n    result = run(**filtered_kwargs)\n\n    # Use a local import because the API is only needed when the driver is called.\n    from .api import amend\n\n    # Amend inputs using imported modules.\n    # This goes a bit against good practice, in the sense that amending should be done early.\n    # It is acceptable here because the driver would fail anyway if the imports are not available.\n    # By amending after calling the driver, we also pick up local imports, if any.\n    out = []\n    if not (result is None or args.path_out is None) and args.amend_out:\n        out.append(args.path_out)\n    amend(inp=_get_local_import_paths(script_path), out=out)\n\n    # Save the result if not None\n    if result is not None:\n        if args.path_out is None:\n            raise ValueError(\"The output path is mandatory when the run function returns a value.\")\n        if args.path_out.suffix == \".json\":\n            with open(args.path_out, \"w\") as fh:\n                json.dump(result, fh)\n                fh.write(\"\\n\")\n        elif args.path_out.suffix == \".pickle\":\n            with open(args.path_out, \"wb\") as fh:\n                pickle.dump(result, fh)\n        else:\n            raise NotImplementedError(f\"Unsupported output file format: {args.path_out.suffix}\")\n</code></pre>"},{"location":"reference/stepup.core.interact/","title":"stepup.core.interact","text":"<p>Application Programming Interface (API) for interactive use of the director process.</p> <p>Most of these functions are used for writing tests. They can also be employed to create keyboard shortcuts within your IDE.</p> <p>For example, one may bind the following command to an IDE\u2019s keyboard shortcut:</p> <pre><code>STEPUP_DIRECTOR_SOCKET=$(python -c \"import stepup.core.director; print(stepup.core.director.get_socket())\") python -c 'from stepup.core.interact import run; run()'\n</code></pre> <p>This command must be executed in the top-level directory where a <code>stepup</code> command is running in interactive mode.</p> <p>You can better understand how the above example works by breaking it down into two parts:</p> <ul> <li>The command <code>python -c \"import stepup.core.director; print(stepup.core.director.get_socket())\"</code>   prints the path to the socket where the director listens for instructions.   This is a randomized temporary path that is created when <code>stepup</code> is started.   (For technical reasons, this path cannot be deterministic   and must be read from <code>.stepup/log/director</code>.)   By wrapping this command in <code>STEPUP_DIRECTOR_SOCKET=$(...)</code>, the path will be   assigned to an environment variable <code>STEPUP_DIRECTOR_SOCKET</code>,   which will be available for the second Python call.</li> <li> <p>The part <code>python -c 'from stepup.core.interact import run; run()'</code>   has the same effect as pressing <code>r</code> in the terminal where StepUp is running.   The variable <code>STEPUP_DIRECTOR_SOCKET</code> tells which instance of StepUp to interact with.</p> <p>(When StepUp runs <code>plan.py</code> scripts, they also use this environment variable to interact with the director process. Because these are subprocesses of the director, the <code>STEPUP_DIRECTOR_SOCKET</code> is set by the director.)</p> </li> </ul>"},{"location":"reference/stepup.core.interact/#stepup.core.interact--configuration-of-a-task-in-vscode","title":"Configuration of a Task in VSCode","text":"<p>You can define a Custom Task in VSCode to start the run phase of a StepUp instance running in a terminal.</p> <p>For this example, we will assume the following:</p> <ul> <li>You have an <code>.envrc</code> file that defines the environment variable <code>STEPUP_ROOT</code>   and you have configured and installed direnv.</li> <li>You have an interactive StepUp instance running in a terminal (with <code>stepup -w</code>).</li> <li>You want to use the <code>ctrl+'</code> keybinding to start the run phase   while you are editing a file in the StepUp project.</li> </ul> <p>Add the following to your user <code>tasks.json</code> file:</p> <pre><code>{\n  \"version\": \"2.0.0\",\n  \"tasks\": [\n    {\n      \"label\": \"StepUp run\",\n      \"type\": \"shell\",\n      \"command\": \"eval \\\"$(direnv export bash)\\\"; STEPUP_DIRECTOR_SOCKET=$(python -c 'import stepup.core.director; print(stepup.core.director.get_socket())') python -c 'from stepup.core.interact import run; run()'\",\n      \"options\": {\n        \"cwd\": \"${fileDirname}\"\n      },\n      \"presentation\": {\n        \"echo\": true,\n        \"reveal\": \"silent\",\n        \"focus\": false,\n        \"panel\": \"shared\",\n        \"showReuseMessage\": false,\n        \"clear\": true\n      }\n    }\n  ]\n}\n</code></pre> <p>This will create a task that executes the command in the directory of the file you are editing. With <code>eval \"$(direnv export bash)\"</code>, the environment variables from your <code>.envrc</code> file are loaded. The rest of the <code>command</code> field is the same as the command we used in the first example.</p> <p>The following <code>keybindings.json</code> file will bind <code>ctrl+'</code> to run the task:</p> <pre><code>[\n  {\n    \"key\": \"ctrl+'\",\n    \"command\": \"workbench.action.tasks.runTask\",\n    \"args\": \"StepUp run\"\n  }\n]\n</code></pre> <p>VSCode will automatically save the file when you run the task with this keybinding.</p> <p>Instead of this shortcut, you can also use <code>stepup -W</code>, which will automatically rerun the build as soon as you delete, save or add a relevant file.</p>"},{"location":"reference/stepup.core.interact/#stepup.core.interact.graph","title":"<code>graph(prefix)</code>","text":"<p>Write the workflow graph files in text and dot formats.</p> Source code in <code>stepup/core/interact.py</code> <pre><code>def graph(prefix: str):\n    \"\"\"Write the workflow graph files in text and dot formats.\"\"\"\n    return RPC_CLIENT.call.graph(prefix)\n</code></pre>"},{"location":"reference/stepup.core.interact/#stepup.core.interact.join","title":"<code>join()</code>","text":"<p>Wait for the runner to become idle and stop the director.</p> <p>This is the same as <code>wait()</code> followed by <code>shutdown()</code>.</p> Source code in <code>stepup/core/interact.py</code> <pre><code>def join():\n    \"\"\"Wait for the runner to become idle and stop the director.\n\n    This is the same as `wait()` followed by `shutdown()`.\"\"\"\n    RPC_CLIENT.call.join(_rpc_timeout=-1)\n</code></pre>"},{"location":"reference/stepup.core.interact/#stepup.core.interact.run","title":"<code>run()</code>","text":"<p>Exit the watch phase and start running steps whose inputs have changed.</p> Source code in <code>stepup/core/interact.py</code> <pre><code>def run():\n    \"\"\"Exit the watch phase and start running steps whose inputs have changed.\"\"\"\n    RPC_CLIENT.call.run()\n</code></pre>"},{"location":"reference/stepup.core.interact/#stepup.core.interact.wait","title":"<code>wait()</code>","text":"<p>Block until the runner has become idle.</p> Source code in <code>stepup/core/interact.py</code> <pre><code>def wait():\n    \"\"\"Block until the runner has become idle.\"\"\"\n    RPC_CLIENT.call.wait(_rpc_timeout=-1)\n</code></pre>"},{"location":"reference/stepup.core.interact/#stepup.core.interact.watch_delete","title":"<code>watch_delete(path)</code>","text":"<p>Block until the watcher has observed the deletion of the file.</p> Source code in <code>stepup/core/interact.py</code> <pre><code>def watch_delete(path: str):\n    \"\"\"Block until the watcher has observed the deletion of the file.\"\"\"\n    RPC_CLIENT.call.watch_delete(path, _rpc_timeout=-1)\n</code></pre>"},{"location":"reference/stepup.core.interact/#stepup.core.interact.watch_update","title":"<code>watch_update(path)</code>","text":"<p>Block until the watcher has observed an update of the file.</p> Source code in <code>stepup/core/interact.py</code> <pre><code>def watch_update(path: str):\n    \"\"\"Block until the watcher has observed an update of the file.\"\"\"\n    RPC_CLIENT.call.watch_update(path, _rpc_timeout=-1)\n</code></pre>"},{"location":"reference/stepup.core.nglob/","title":"stepup.core.nglob","text":"<p>Glob with named back-reference support.</p> <p>Named glob (NGlob) patterns are an advanced form of pattern matching that supports back referencing of previously matched substrings.</p> <p>It has the following use cases:</p> <ul> <li> <p>Single named wildcard:     By default, the wildcard <code>${*name}</code> is a placeholder for any string.     One may also specify a pattern for <code>${*name}</code> through optional arguments.     For example:</p> <pre><code>ngs = NGlobSingle(\"feedback_${*idx}.md\", idx=\"[0-9][0-9][0-9]\")\nngs.glob()\nprint(ngs.results)\n</code></pre> <p>Unlike ordinary wildcards, named wildcards never match an empty string.</p> </li> <li> <p>Consistency within one pattern:     If a pattern uses the same named globs multiple times,     the matching substring must also be consistent.     For example:</p> <pre><code>ngs = NGlobSingle(\"archive_${*idx}/feedback_${*idx}.md\", idx=\"[0-9][0-9][0-9]\")\nngs.glob()\nprint(ngs.results)\n</code></pre> <p>These would match:</p> <ul> <li><code>archive_042/feedback_042.md</code></li> <li><code>archive_777/feedback_777.md</code></li> </ul> <p>This won\u2019t match:</p> <ul> <li><code>archive_042/feedback_777.md</code></li> </ul> </li> <li> <p>Consistency across multiple patterns:     One can define multiple patterns and enforce consistency between their matches.     For example:</p> <pre><code>ngm = NGlobMulti(\"feedback_${*idx}.md\", \"report_${*idx}.pdf\", idx=\"[0-9][0-9][0-9]\")\nngm.glob()\nprint(ngm.results)\n</code></pre> <p>This will produce pairs of matches (provided the files are present). For example, the following would match:</p> <ul> <li><code>feedback_001.md</code> with <code>report_001.pdf</code></li> <li><code>feedback_123.md</code> with <code>report_123.pdf</code></li> </ul> <p>The following won\u2019t be in the results, despite the fact that the files exist:</p> <ul> <li><code>feedback_001.md</code> with <code>report_123.pdf</code></li> </ul> </li> <li> <p>Conventional (recursive) glob wildcards are also allowed and are called \u201canonymous wildcards\u201d   to clarify the distinction from named wildcards.</p> </li> </ul>"},{"location":"reference/stepup.core.nglob/#stepup.core.nglob.NGlobMatch","title":"<code>NGlobMatch</code>","text":"<p>A set of matches corresponding sharing consistent values for named wildcards.</p> <p>The matching files can be accessed by integer indexing or through the <code>files</code> attribute:</p> <pre><code>assert match[0] == match.files[0]\n</code></pre> <p>The substring matching the named wildcards can be accessed as attributes. For example, the substring matching a named wildcard <code>foo</code> is accessed as follows:</p> <pre><code>print(match.foo)\n</code></pre> <p>When you expect only a single matching file, then the <code>single</code> attribute can be used. It will raise an exception when there are zero or multiple matches:</p> <pre><code>print(match.single)\n</code></pre> <p>In the unfortunate case that your named wildcards are named <code>single</code>, <code>files</code> or <code>mapping</code>, you can access their values through the <code>mapping</code> attribute:</p> <pre><code>print(match.mapping[\"single\"])\n</code></pre> Source code in <code>stepup/core/nglob.py</code> <pre><code>@attrs.define\nclass NGlobMatch:\n    \"\"\"A set of matches corresponding sharing consistent values for named wildcards.\n\n    The matching files can be accessed by integer indexing or through the `files` attribute:\n\n    ```python\n    assert match[0] == match.files[0]\n    ```\n\n    The substring matching the named wildcards can be accessed as attributes.\n    For example, the substring matching a named wildcard `foo` is accessed as follows:\n\n    ```python\n    print(match.foo)\n    ```\n\n    When you expect only a single matching file, then the `single` attribute can be used.\n    It will raise an exception when there are zero or multiple matches:\n\n    ```python\n    print(match.single)\n    ```\n\n    In the unfortunate case that your named wildcards are named `single`, `files` or `mapping`,\n    you can access their values through the `mapping` attribute:\n\n    ```python\n    print(match.mapping[\"single\"])\n    ```\n    \"\"\"\n\n    _mapping: dict[str, str]\n    _files: list[Path | list[Path]]\n\n    def __getitem__(self, idx) -&gt; Path | list[Path]:\n        return self._files[idx]\n\n    def __getattr__(self, name) -&gt; str:\n        try:\n            return self._mapping[name]\n        except KeyError as exc:\n            raise AttributeError(f\"'NGlobMatch' object has no attribute '{name}'\") from exc\n\n    @property\n    def mapping(self) -&gt; dict[str, str]:\n        \"\"\"Dictionary with `(wildcard_name, substring)` items.\"\"\"\n        return self._mapping\n\n    @property\n    def files(self) -&gt; list[Path | list[Path]]:\n        \"\"\"Matching files, all having consistent substrings matching the named wildcards.\n\n        Each item corresponds to a pattern in `NGlobMulti.patterns`.\n        If a pattern has anonymous wildcards,\n        the item itself is a list of all files matching the pattern,\n        If the pattern contains no anonymous wildcards,\n        the corresponding item in the returned list is a single path.\n        \"\"\"\n        return self._files\n\n    @property\n    def single(self) -&gt; Path:\n        \"\"\"A single path if there is exactly one match, raises an error otherwise.\"\"\"\n        if len(self._files) == 0:\n            raise ValueError(\"No files matched.\")\n        if len(self._files) &gt; 1:\n            raise ValueError(\"Multiple files matched.\")\n        result = self._files[0]\n        if isinstance(result, list):\n            if len(result) == 0:\n                raise ValueError(\"No files matched.\")\n            if len(result) &gt; 1:\n                raise ValueError(\"Multiple files matched.\")\n            result = result[0]\n        return result\n</code></pre>"},{"location":"reference/stepup.core.nglob/#stepup.core.nglob.NGlobMatch.files","title":"<code>files</code>  <code>property</code>","text":"<p>Matching files, all having consistent substrings matching the named wildcards.</p> <p>Each item corresponds to a pattern in <code>NGlobMulti.patterns</code>. If a pattern has anonymous wildcards, the item itself is a list of all files matching the pattern, If the pattern contains no anonymous wildcards, the corresponding item in the returned list is a single path.</p>"},{"location":"reference/stepup.core.nglob/#stepup.core.nglob.NGlobMatch.mapping","title":"<code>mapping</code>  <code>property</code>","text":"<p>Dictionary with <code>(wildcard_name, substring)</code> items.</p>"},{"location":"reference/stepup.core.nglob/#stepup.core.nglob.NGlobMatch.single","title":"<code>single</code>  <code>property</code>","text":"<p>A single path if there is exactly one match, raises an error otherwise.</p>"},{"location":"reference/stepup.core.nglob/#stepup.core.nglob.NGlobMulti","title":"<code>NGlobMulti</code>","text":"<p>A sequence of Named Glob patterns for which consistent matches are collected.</p> Source code in <code>stepup/core/nglob.py</code> <pre><code>@attrs.define\nclass NGlobMulti:\n    \"\"\"A sequence of Named Glob patterns for which consistent matches are collected.\"\"\"\n\n    _nglob_singles: tuple[NGlobSingle, ...] = attrs.field()\n    _subs: dict[str, str] = attrs.field(init=False)\n    _used_names: tuple[str, ...] = attrs.field(init=False)\n    _has_wildcards: bool = attrs.field(init=False)\n    _results: dict[tuple[str, ...], list[set[Path]]] = attrs.field(init=False, factory=dict)\n\n    @_subs.default\n    def _default_subs(self):\n        if len(self._nglob_singles) == 0:\n            return {}\n        subs = self._nglob_singles[0].subs\n        for other in self._nglob_singles[1:]:\n            if other.subs != subs:\n                raise ValueError(\"Searches in one NGlobMulti must use the same substitutions\")\n            other._subs = subs\n        return subs\n\n    @_used_names.default\n    def _default_used_names(self) -&gt; tuple[str, ...]:\n        result = set()\n        for ngs in self._nglob_singles:\n            result.update(ngs.used_names)\n        return tuple(sorted(result))\n\n    @_has_wildcards.default\n    def _default_has_wildcards(self) -&gt; bool:\n        for ngs in self._nglob_singles:\n            if has_anonymous_wildcards(ngs.pattern):\n                return True\n        for name in self._used_names:\n            pattern = self._subs.get(name)\n            if pattern is None:\n                return True\n            if has_anonymous_wildcards(pattern):\n                return True\n        return False\n\n    @classmethod\n    def from_patterns(cls, patterns: Iterable[str], subs: dict[str, str] | None = None) -&gt; Self:\n        \"\"\"Create a new instance for given patterns without any results.\n\n        Parameters\n        ----------\n        patterns\n            Named Glob patterns.\n            Results will be constrained to have consistently matching substrings\n            for the named wildcards appearing in all the patterns.\n        subs\n            Optional anonymous glob patterns for the named patterns.\n            When a name is not present, the wildcard `*` is used for this name.\n        \"\"\"\n        if isinstance(patterns, str):\n            raise TypeError(\"The patterns argument cannot be a string\")\n        if not all(isinstance(pattern, str) for pattern in patterns):\n            raise TypeError(f\"The patterns must be a list of strings, got {patterns}\")\n        if subs is None:\n            subs = {}\n        else:\n            if not all(isinstance(name, str) for name in subs):\n                raise TypeError(f\"The subs keys must be a list of strings, got {patterns}\")\n            if not all(isinstance(value, str) for value in subs.values()):\n                raise TypeError(f\"The subs values must be a list of strings, got {patterns}\")\n        return cls(tuple(NGlobSingle(str(pattern), subs) for pattern in patterns))\n\n    @property\n    def nglob_singles(self) -&gt; tuple[NGlobSingle, ...]:\n        \"\"\"The list of NGlobSingle instances, one for each pattern.\n\n        These instances collect (partial) matches before any consistency is imposed between\n        the substrings matching the same name in different patterns.\n        \"\"\"\n        return self._nglob_singles\n\n    @property\n    def patterns(self):\n        \"\"\"The list of Named Glob patterns.\"\"\"\n        return [ngs.pattern for ngs in self._nglob_singles]\n\n    @property\n    def subs(self) -&gt; dict[str, str]:\n        \"\"\"User-defined glob patterns for the named wildcards.\n\n        When a name is not present, `*` is used.\n        \"\"\"\n        return self._subs\n\n    @property\n    def used_names(self) -&gt; tuple[str, ...]:\n        \"\"\"The names used across all the named glob patterns.\"\"\"\n        return self._used_names\n\n    @property\n    def has_wildcards(self) -&gt; bool:\n        \"\"\"True if any named or anonymous wildcards are present in the patterns.\"\"\"\n        return self._has_wildcards\n\n    @property\n    def results(self) -&gt; dict[tuple[str, ...], list[set[Path]]]:\n        \"\"\"A dictionary with all matches collected so far.\n\n        A key in this dictionary is a tuple of substrings named wildcards,\n        using the same order as the `used_names` attribute.\n\n        A value is a list of sets of paths.\n        Each item in the list is a set of matching filenames for the corresponding\n        pattern from the `patterns` attribute, whose named wildcards match the substrings\n        of the key.\n\n        The results can be extended with the `extend` and `glob` methods.\n        Conversely, results can be removed with the `reduce` method.\n        \"\"\"\n        return self._results\n\n    def _iter_consistent(\n        self, criteria: dict[str, str], full_paths: list | int\n    ) -&gt; Iterator[tuple[str, ...], list[list[Path]]]:\n        \"\"\"Iterate over (partial) matching substrings and corresponding paths.\n\n        Parameters\n        ----------\n        criteria\n            A dictionary mapping named wildcards to matching substrings.\n        full_paths\n            If this is a list, it contains lists of paths matching the patterns\n            in of the `patterns` attribute with substrings consistent with those in\n            the criteria argument.\n            Note that this is a recursive iterator, so full_paths may contain fewer\n            items than there are patterns when the recursion has not reached it full\n            depth yet.\n            If this is an integer, it is in index referring to the item in the `patterns`\n            to identify the current pattern being processed.\n        \"\"\"\n        start = full_paths if isinstance(full_paths, int) else len(full_paths)\n        if start == len(self._nglob_singles):\n            # We're in the deepest recursion: yield a result.\n            yield tuple(criteria[name] for name in self._used_names), full_paths\n        else:\n            # Recursion in progress...\n            ngs = self._nglob_singles[start]\n            for new_values, paths in ngs.results.items():\n                next_criteria = criteria.copy()\n                # Check if named wildcards are consistent with the matching paths so far.\n                for name, new_value in zip(ngs.used_names, new_values, strict=False):\n                    value = next_criteria.get(name)\n                    if value is None:\n                        next_criteria[name] = new_value\n                    elif value != new_value:\n                        # Inconsistent matches for named wildcards in different patterns.\n                        # This cannot produce a useful result.\n                        next_criteria = None\n                        break\n                if next_criteria is not None:\n                    # Consistency can still be imposed, so enter the next recursion...\n                    next_full_paths = (\n                        start + 1 if isinstance(full_paths, int) else [*full_paths, paths]\n                    )\n                    yield from self._iter_consistent(next_criteria, next_full_paths)\n\n    def _extend_consistent(self, i: int, values: tuple[str, ...]):\n        \"\"\"Extend the results of this instance, given an added combination of matching substrings.\n\n        Parameters\n        ----------\n        i\n            The integer index of the pattern in the `patterns` attribute being processed.\n        values\n            A new set of substrings matching the named wildcards.\n        \"\"\"\n        criteria = dict(zip(self._nglob_singles[i].used_names, values, strict=False))\n        new_items = list(self._iter_consistent(criteria, []))\n        for full_values, full_paths in new_items:\n            self._results[full_values] = full_paths\n\n    def _reduce_consistent(self, i: int, values: tuple[str, ...]):\n        \"\"\"Return the results of this instance, given a removed combination of matching substrings.\n        Parameters\n        ----------\n        i\n            The integer index of the pattern in the `patterns` attribute being processed.\n        values\n            A new set of substrings matching the named wildcards.\n        \"\"\"\n        criteria = dict(zip(self._nglob_singles[i].used_names, values, strict=False))\n        old_items = list(self._iter_consistent(criteria, 0))\n        for full_values, _ in old_items:\n            del self._results[full_values]\n\n    def extend(self, paths: Iterable[str]):\n        \"\"\"Try to extend the results by searching for matches in the given list of paths.\"\"\"\n        if isinstance(paths, str):\n            raise TypeError(\"The paths argument cannot be a string.\")\n        for i, ngs in enumerate(self._nglob_singles):\n            for values in ngs.extend(paths):\n                self._extend_consistent(i, values)\n\n    def reduce(self, paths: Iterable[str]):\n        \"\"\"Drop results by eliminating the provided paths.\"\"\"\n        if isinstance(paths, str):\n            raise TypeError(\"The paths argument cannot be a string.\")\n        for i, ngs in enumerate(self._nglob_singles):\n            for values in ngs.reduce(paths):\n                self._reduce_consistent(i, values)\n\n    def glob(self):\n        \"\"\"Extend the results with paths found by the built-in glob function.\"\"\"\n        for i, ngs in enumerate(self._nglob_singles):\n            for values in ngs.glob():\n                self._extend_consistent(i, values)\n\n    def deepcopy(self):\n        \"\"\"Return an independent copy.\"\"\"\n        return copy.deepcopy(self)\n\n    def equals(self, other: \"NGlobMulti\") -&gt; bool:\n        \"\"\"Compare the results.\"\"\"\n        return self._results == other._results\n\n    # Convenience methods\n\n    def matches(self) -&gt; Iterator[NGlobMatch]:\n        \"\"\"Iterate over combinations of files that consistently match all patterns.\n\n        This offers a more convenient interface of the `results` attribute.\n\n        Yields\n        ------\n        nglob_match\n            An instance of NGlobMatch, which contains the substrings matching the named wildcards\n            and the corresponding lists of paths.\n        \"\"\"\n        for values, path_sets in sorted(self._results.items()):\n            mapping = dict(zip(self._used_names, values, strict=False))\n            files = [\n                (sorted(paths) if has_anonymous_wildcards(ngs.pattern) else next(iter(paths)))\n                for ngs, paths in zip(self._nglob_singles, path_sets, strict=False)\n            ]\n            yield NGlobMatch(mapping, files)\n\n    def files(self) -&gt; tuple[Path, ...]:\n        \"\"\"Return a tuple of sorted files that match the individual patterns.\n\n        No constraints between multiple patterns are imposed and files may belong to partial\n        and inconsistent full matches.\n        \"\"\"\n        result = set()\n        for ngs in self._nglob_singles:\n            for path_set in ngs.results.values():\n                result.update(path_set)\n        return tuple(sorted(result))\n\n    def single(self) -&gt; Path:\n        \"\"\"Return the single matching path.\n\n        Raises\n        ------\n        ValueError\n            If there is not exactly one match.\n        \"\"\"\n        files = self.files()\n        if len(files) != 1:\n            raise ValueError(f\"There are {len(files)} matches, not just one.\")\n        return files[0]\n\n    def __bool__(self):\n        \"\"\"True when there are some items in the `results` attribute.\"\"\"\n        return len(self.results) &gt; 0\n\n    def __iter__(self) -&gt; Iterator[str | NGlobMatch]:\n        \"\"\"Iterates over `self.matches` if there are named wildcards, else over `self.files`.\"\"\"\n        if len(self._used_names) &gt; 0:\n            return self.matches()\n        return iter(self.files())\n\n    def may_match(self, path):\n        \"\"\"Return True if the path matches one of the NGlobSingle instances.\n\n        This means that it may be a path contributing to a consistent match of NGlobMulti.\n        When added, it will show up in the result of the `files` method,\n        and it may affect the outcome of the `matches` method.\n        \"\"\"\n        return any(ngs.regex.fullmatch(path) for ngs in self._nglob_singles)\n\n    def may_change(self, deleted: set[str], added: set[str]) -&gt; bool:\n        \"\"\"Determine whether the results may change (later) after deleting or adding files.\n\n        Parameters\n        ----------\n        deleted\n            Set of files to be deleted.\n        added\n            Set of files to be added.\n\n        Returns\n        -------\n        may_change\n            True if the NGlobMulti results may change.\n            (It may require additional additions and deletions to get any effect,\n            but cannot be excluded that the provided deletions and updates play a role in it.)\n        \"\"\"\n        added_new = added.copy()\n        for ngs in self._nglob_singles:\n            for paths in ngs.results.values():\n                if not deleted.isdisjoint(paths):\n                    return True\n                added_new.difference_update(paths)\n        for ngs in self._nglob_singles:\n            for path in added_new:\n                if ngs.regex.fullmatch(path):\n                    return True\n        return False\n\n    def will_change(self, deleted: Collection[str], added: Collection[str]) -&gt; Self | None:\n        \"\"\"Determine whether the results will change after deleting or adding files.\n\n        Parameters\n        ----------\n        deleted\n            Set of files to be deleted.\n        added\n            Set of files to be added.\n\n        Returns\n        -------\n        evolved\n            a new modified copy with the changes if any.\n            None otherwise.\n        \"\"\"\n        evolved = self.deepcopy()\n        evolved.extend(added)\n        evolved.reduce(deleted)\n        return None if evolved.equals(self) else evolved\n</code></pre>"},{"location":"reference/stepup.core.nglob/#stepup.core.nglob.NGlobMulti.has_wildcards","title":"<code>has_wildcards</code>  <code>property</code>","text":"<p>True if any named or anonymous wildcards are present in the patterns.</p>"},{"location":"reference/stepup.core.nglob/#stepup.core.nglob.NGlobMulti.nglob_singles","title":"<code>nglob_singles</code>  <code>property</code>","text":"<p>The list of NGlobSingle instances, one for each pattern.</p> <p>These instances collect (partial) matches before any consistency is imposed between the substrings matching the same name in different patterns.</p>"},{"location":"reference/stepup.core.nglob/#stepup.core.nglob.NGlobMulti.patterns","title":"<code>patterns</code>  <code>property</code>","text":"<p>The list of Named Glob patterns.</p>"},{"location":"reference/stepup.core.nglob/#stepup.core.nglob.NGlobMulti.results","title":"<code>results</code>  <code>property</code>","text":"<p>A dictionary with all matches collected so far.</p> <p>A key in this dictionary is a tuple of substrings named wildcards, using the same order as the <code>used_names</code> attribute.</p> <p>A value is a list of sets of paths. Each item in the list is a set of matching filenames for the corresponding pattern from the <code>patterns</code> attribute, whose named wildcards match the substrings of the key.</p> <p>The results can be extended with the <code>extend</code> and <code>glob</code> methods. Conversely, results can be removed with the <code>reduce</code> method.</p>"},{"location":"reference/stepup.core.nglob/#stepup.core.nglob.NGlobMulti.subs","title":"<code>subs</code>  <code>property</code>","text":"<p>User-defined glob patterns for the named wildcards.</p> <p>When a name is not present, <code>*</code> is used.</p>"},{"location":"reference/stepup.core.nglob/#stepup.core.nglob.NGlobMulti.used_names","title":"<code>used_names</code>  <code>property</code>","text":"<p>The names used across all the named glob patterns.</p>"},{"location":"reference/stepup.core.nglob/#stepup.core.nglob.NGlobMulti.__bool__","title":"<code>__bool__()</code>","text":"<p>True when there are some items in the <code>results</code> attribute.</p> Source code in <code>stepup/core/nglob.py</code> <pre><code>def __bool__(self):\n    \"\"\"True when there are some items in the `results` attribute.\"\"\"\n    return len(self.results) &gt; 0\n</code></pre>"},{"location":"reference/stepup.core.nglob/#stepup.core.nglob.NGlobMulti.__iter__","title":"<code>__iter__()</code>","text":"<p>Iterates over <code>self.matches</code> if there are named wildcards, else over <code>self.files</code>.</p> Source code in <code>stepup/core/nglob.py</code> <pre><code>def __iter__(self) -&gt; Iterator[str | NGlobMatch]:\n    \"\"\"Iterates over `self.matches` if there are named wildcards, else over `self.files`.\"\"\"\n    if len(self._used_names) &gt; 0:\n        return self.matches()\n    return iter(self.files())\n</code></pre>"},{"location":"reference/stepup.core.nglob/#stepup.core.nglob.NGlobMulti.deepcopy","title":"<code>deepcopy()</code>","text":"<p>Return an independent copy.</p> Source code in <code>stepup/core/nglob.py</code> <pre><code>def deepcopy(self):\n    \"\"\"Return an independent copy.\"\"\"\n    return copy.deepcopy(self)\n</code></pre>"},{"location":"reference/stepup.core.nglob/#stepup.core.nglob.NGlobMulti.equals","title":"<code>equals(other)</code>","text":"<p>Compare the results.</p> Source code in <code>stepup/core/nglob.py</code> <pre><code>def equals(self, other: \"NGlobMulti\") -&gt; bool:\n    \"\"\"Compare the results.\"\"\"\n    return self._results == other._results\n</code></pre>"},{"location":"reference/stepup.core.nglob/#stepup.core.nglob.NGlobMulti.extend","title":"<code>extend(paths)</code>","text":"<p>Try to extend the results by searching for matches in the given list of paths.</p> Source code in <code>stepup/core/nglob.py</code> <pre><code>def extend(self, paths: Iterable[str]):\n    \"\"\"Try to extend the results by searching for matches in the given list of paths.\"\"\"\n    if isinstance(paths, str):\n        raise TypeError(\"The paths argument cannot be a string.\")\n    for i, ngs in enumerate(self._nglob_singles):\n        for values in ngs.extend(paths):\n            self._extend_consistent(i, values)\n</code></pre>"},{"location":"reference/stepup.core.nglob/#stepup.core.nglob.NGlobMulti.files","title":"<code>files()</code>","text":"<p>Return a tuple of sorted files that match the individual patterns.</p> <p>No constraints between multiple patterns are imposed and files may belong to partial and inconsistent full matches.</p> Source code in <code>stepup/core/nglob.py</code> <pre><code>def files(self) -&gt; tuple[Path, ...]:\n    \"\"\"Return a tuple of sorted files that match the individual patterns.\n\n    No constraints between multiple patterns are imposed and files may belong to partial\n    and inconsistent full matches.\n    \"\"\"\n    result = set()\n    for ngs in self._nglob_singles:\n        for path_set in ngs.results.values():\n            result.update(path_set)\n    return tuple(sorted(result))\n</code></pre>"},{"location":"reference/stepup.core.nglob/#stepup.core.nglob.NGlobMulti.from_patterns","title":"<code>from_patterns(patterns, subs=None)</code>  <code>classmethod</code>","text":"<p>Create a new instance for given patterns without any results.</p> <p>Parameters:</p> <ul> <li> <code>patterns</code>               (<code>Iterable[str]</code>)           \u2013            <p>Named Glob patterns. Results will be constrained to have consistently matching substrings for the named wildcards appearing in all the patterns.</p> </li> <li> <code>subs</code>               (<code>dict[str, str] | None</code>, default:                   <code>None</code> )           \u2013            <p>Optional anonymous glob patterns for the named patterns. When a name is not present, the wildcard <code>*</code> is used for this name.</p> </li> </ul> Source code in <code>stepup/core/nglob.py</code> <pre><code>@classmethod\ndef from_patterns(cls, patterns: Iterable[str], subs: dict[str, str] | None = None) -&gt; Self:\n    \"\"\"Create a new instance for given patterns without any results.\n\n    Parameters\n    ----------\n    patterns\n        Named Glob patterns.\n        Results will be constrained to have consistently matching substrings\n        for the named wildcards appearing in all the patterns.\n    subs\n        Optional anonymous glob patterns for the named patterns.\n        When a name is not present, the wildcard `*` is used for this name.\n    \"\"\"\n    if isinstance(patterns, str):\n        raise TypeError(\"The patterns argument cannot be a string\")\n    if not all(isinstance(pattern, str) for pattern in patterns):\n        raise TypeError(f\"The patterns must be a list of strings, got {patterns}\")\n    if subs is None:\n        subs = {}\n    else:\n        if not all(isinstance(name, str) for name in subs):\n            raise TypeError(f\"The subs keys must be a list of strings, got {patterns}\")\n        if not all(isinstance(value, str) for value in subs.values()):\n            raise TypeError(f\"The subs values must be a list of strings, got {patterns}\")\n    return cls(tuple(NGlobSingle(str(pattern), subs) for pattern in patterns))\n</code></pre>"},{"location":"reference/stepup.core.nglob/#stepup.core.nglob.NGlobMulti.glob","title":"<code>glob()</code>","text":"<p>Extend the results with paths found by the built-in glob function.</p> Source code in <code>stepup/core/nglob.py</code> <pre><code>def glob(self):\n    \"\"\"Extend the results with paths found by the built-in glob function.\"\"\"\n    for i, ngs in enumerate(self._nglob_singles):\n        for values in ngs.glob():\n            self._extend_consistent(i, values)\n</code></pre>"},{"location":"reference/stepup.core.nglob/#stepup.core.nglob.NGlobMulti.matches","title":"<code>matches()</code>","text":"<p>Iterate over combinations of files that consistently match all patterns.</p> <p>This offers a more convenient interface of the <code>results</code> attribute.</p> <p>Yields:</p> <ul> <li> <code>nglob_match</code>           \u2013            <p>An instance of NGlobMatch, which contains the substrings matching the named wildcards and the corresponding lists of paths.</p> </li> </ul> Source code in <code>stepup/core/nglob.py</code> <pre><code>def matches(self) -&gt; Iterator[NGlobMatch]:\n    \"\"\"Iterate over combinations of files that consistently match all patterns.\n\n    This offers a more convenient interface of the `results` attribute.\n\n    Yields\n    ------\n    nglob_match\n        An instance of NGlobMatch, which contains the substrings matching the named wildcards\n        and the corresponding lists of paths.\n    \"\"\"\n    for values, path_sets in sorted(self._results.items()):\n        mapping = dict(zip(self._used_names, values, strict=False))\n        files = [\n            (sorted(paths) if has_anonymous_wildcards(ngs.pattern) else next(iter(paths)))\n            for ngs, paths in zip(self._nglob_singles, path_sets, strict=False)\n        ]\n        yield NGlobMatch(mapping, files)\n</code></pre>"},{"location":"reference/stepup.core.nglob/#stepup.core.nglob.NGlobMulti.may_change","title":"<code>may_change(deleted, added)</code>","text":"<p>Determine whether the results may change (later) after deleting or adding files.</p> <p>Parameters:</p> <ul> <li> <code>deleted</code>               (<code>set[str]</code>)           \u2013            <p>Set of files to be deleted.</p> </li> <li> <code>added</code>               (<code>set[str]</code>)           \u2013            <p>Set of files to be added.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>may_change</code>           \u2013            <p>True if the NGlobMulti results may change. (It may require additional additions and deletions to get any effect, but cannot be excluded that the provided deletions and updates play a role in it.)</p> </li> </ul> Source code in <code>stepup/core/nglob.py</code> <pre><code>def may_change(self, deleted: set[str], added: set[str]) -&gt; bool:\n    \"\"\"Determine whether the results may change (later) after deleting or adding files.\n\n    Parameters\n    ----------\n    deleted\n        Set of files to be deleted.\n    added\n        Set of files to be added.\n\n    Returns\n    -------\n    may_change\n        True if the NGlobMulti results may change.\n        (It may require additional additions and deletions to get any effect,\n        but cannot be excluded that the provided deletions and updates play a role in it.)\n    \"\"\"\n    added_new = added.copy()\n    for ngs in self._nglob_singles:\n        for paths in ngs.results.values():\n            if not deleted.isdisjoint(paths):\n                return True\n            added_new.difference_update(paths)\n    for ngs in self._nglob_singles:\n        for path in added_new:\n            if ngs.regex.fullmatch(path):\n                return True\n    return False\n</code></pre>"},{"location":"reference/stepup.core.nglob/#stepup.core.nglob.NGlobMulti.may_match","title":"<code>may_match(path)</code>","text":"<p>Return True if the path matches one of the NGlobSingle instances.</p> <p>This means that it may be a path contributing to a consistent match of NGlobMulti. When added, it will show up in the result of the <code>files</code> method, and it may affect the outcome of the <code>matches</code> method.</p> Source code in <code>stepup/core/nglob.py</code> <pre><code>def may_match(self, path):\n    \"\"\"Return True if the path matches one of the NGlobSingle instances.\n\n    This means that it may be a path contributing to a consistent match of NGlobMulti.\n    When added, it will show up in the result of the `files` method,\n    and it may affect the outcome of the `matches` method.\n    \"\"\"\n    return any(ngs.regex.fullmatch(path) for ngs in self._nglob_singles)\n</code></pre>"},{"location":"reference/stepup.core.nglob/#stepup.core.nglob.NGlobMulti.reduce","title":"<code>reduce(paths)</code>","text":"<p>Drop results by eliminating the provided paths.</p> Source code in <code>stepup/core/nglob.py</code> <pre><code>def reduce(self, paths: Iterable[str]):\n    \"\"\"Drop results by eliminating the provided paths.\"\"\"\n    if isinstance(paths, str):\n        raise TypeError(\"The paths argument cannot be a string.\")\n    for i, ngs in enumerate(self._nglob_singles):\n        for values in ngs.reduce(paths):\n            self._reduce_consistent(i, values)\n</code></pre>"},{"location":"reference/stepup.core.nglob/#stepup.core.nglob.NGlobMulti.single","title":"<code>single()</code>","text":"<p>Return the single matching path.</p> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If there is not exactly one match.</p> </li> </ul> Source code in <code>stepup/core/nglob.py</code> <pre><code>def single(self) -&gt; Path:\n    \"\"\"Return the single matching path.\n\n    Raises\n    ------\n    ValueError\n        If there is not exactly one match.\n    \"\"\"\n    files = self.files()\n    if len(files) != 1:\n        raise ValueError(f\"There are {len(files)} matches, not just one.\")\n    return files[0]\n</code></pre>"},{"location":"reference/stepup.core.nglob/#stepup.core.nglob.NGlobMulti.will_change","title":"<code>will_change(deleted, added)</code>","text":"<p>Determine whether the results will change after deleting or adding files.</p> <p>Parameters:</p> <ul> <li> <code>deleted</code>               (<code>Collection[str]</code>)           \u2013            <p>Set of files to be deleted.</p> </li> <li> <code>added</code>               (<code>Collection[str]</code>)           \u2013            <p>Set of files to be added.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>evolved</code>           \u2013            <p>a new modified copy with the changes if any. None otherwise.</p> </li> </ul> Source code in <code>stepup/core/nglob.py</code> <pre><code>def will_change(self, deleted: Collection[str], added: Collection[str]) -&gt; Self | None:\n    \"\"\"Determine whether the results will change after deleting or adding files.\n\n    Parameters\n    ----------\n    deleted\n        Set of files to be deleted.\n    added\n        Set of files to be added.\n\n    Returns\n    -------\n    evolved\n        a new modified copy with the changes if any.\n        None otherwise.\n    \"\"\"\n    evolved = self.deepcopy()\n    evolved.extend(added)\n    evolved.reduce(deleted)\n    return None if evolved.equals(self) else evolved\n</code></pre>"},{"location":"reference/stepup.core.nglob/#stepup.core.nglob.NGlobSingle","title":"<code>NGlobSingle</code>","text":"<p>Named glob with a single pattern.</p> Source code in <code>stepup/core/nglob.py</code> <pre><code>@attrs.define\nclass NGlobSingle:\n    \"\"\"Named glob with a single pattern.\"\"\"\n\n    _pattern: str = attrs.field()\n    _subs: dict[str, str] = attrs.field(factory=dict)\n    _results: dict[tuple[str, ...], set[Path]] = attrs.field(factory=dict)\n    _used_names: tuple[str, ...] = attrs.field(init=False)\n    _glob_pattern: str = attrs.field(init=False)\n    _regex: re.Pattern = attrs.field(init=False)\n\n    @_used_names.default\n    def _default_used_names(self) -&gt; tuple[str, ...]:\n        return tuple(sorted(set(iter_wildcard_names(self._pattern))))\n\n    @_glob_pattern.default\n    def _default_glob(self) -&gt; str:\n        return convert_nglob_to_glob(self._pattern, self._subs)\n\n    @_regex.default\n    def _default_regex(self) -&gt; re.Pattern:\n        return re.compile(convert_nglob_to_regex(self._pattern, self._subs))\n\n    @property\n    def pattern(self) -&gt; str:\n        \"\"\"The Named Glob pattern used to match filenames.\"\"\"\n        return self._pattern\n\n    @property\n    def subs(self) -&gt; dict[str, str]:\n        \"\"\"User-defined glob patterns for the named wildcards.\n\n        When a name is not present, `*` is used.\n        \"\"\"\n        return self._subs\n\n    @property\n    def results(self) -&gt; dict[tuple[str, ...], set[Path]]:\n        \"\"\"All matching files, grouped by substrings matching the named wildcards.\n\n        The keys of the `results` dictionary are tuples with the substrings,\n        matching the respective named wildcards in the `used_names` tuple.\n        The values are sets with matching paths.\n        \"\"\"\n        return self._results\n\n    @property\n    def used_names(self) -&gt; tuple[str, ...]:\n        \"\"\"A tuple of named wildcards present in the pattern.\"\"\"\n        return self._used_names\n\n    @property\n    def glob_pattern(self) -&gt; str:\n        \"\"\"The conversion of the named glob to a (more general) conventional glob pattern.\"\"\"\n        return self._glob_pattern\n\n    @property\n    def regex(self) -&gt; re.Pattern:\n        \"\"\"The conversion of the named glob to a regular expression.\"\"\"\n        return self._regex\n\n    def _loop_matches(\n        self, paths: Iterable[str]\n    ) -&gt; Iterator[tuple[tuple[str, ...], set[Path], Path]]:\n        \"\"\"Low-level iterator used by the `extend` and `reduce` methods.\n\n        The paths are tested one by one against the regular expression.\n        In case of a hit, it yields a tuple with the following three items:\n\n        - `values`: the substrings matching the named wildcards.\n        - `path_set`: the current set of paths associated with the combination of substrings.\n        - `path`: a `Path` instance of the matching path.\n        \"\"\"\n        for path in paths:\n            match_ = self._regex.fullmatch(path)\n            if match_ is not None:\n                mapping = match_.groupdict()\n                values = tuple(mapping[name] for name in self._used_names)\n                paths = self._results.get(values)\n                if paths is None:\n                    paths = set()\n                    self._results[values] = paths\n                yield values, paths, Path(path)\n                if len(paths) == 0:\n                    del self._results[values]\n\n    def extend(self, paths: Iterable[str]) -&gt; Iterator[tuple[str, ...]]:\n        \"\"\"Add matching paths from the given list paths.\n\n        Yields\n        ------\n        values\n            A tuple with substring matching the named wildcards,\n            only this combination of names was not present yet.\n        \"\"\"\n        for values, path_set, path in self._loop_matches(paths):\n            if len(path_set) == 0:\n                yield values\n            path_set.add(path)\n\n    def reduce(self, paths: Iterable[str]) -&gt; Iterator[tuple[str, ...]]:\n        \"\"\"Remove matching paths from given list paths.\n\n        Yields\n        ------\n        values\n            A tuple with deleted substring matching the named wildcards,\n            only if the last matching paths were removed.\n        \"\"\"\n        for values, path_set, path in self._loop_matches(paths):\n            if len(path_set) &gt; 0:\n                path_set.discard(path)\n                if len(path_set) == 0:\n                    yield values\n\n    def glob(self) -&gt; Iterator[tuple[str, ...]]:\n        \"\"\"Extend the results with paths obtained through Python's built-in glob module.\n\n        Yields\n        ------\n        values\n            A tuple with substring matching the named wildcards,\n            only this combination of names was not present yet.\n        \"\"\"\n        paths = []\n        for path in glob.iglob(self._glob_pattern, recursive=True, include_hidden=True):\n            path = Path(path)\n            if path.is_dir():\n                path = path / \"\"\n            paths.append(path)\n        yield from self.extend(paths)\n</code></pre>"},{"location":"reference/stepup.core.nglob/#stepup.core.nglob.NGlobSingle.glob_pattern","title":"<code>glob_pattern</code>  <code>property</code>","text":"<p>The conversion of the named glob to a (more general) conventional glob pattern.</p>"},{"location":"reference/stepup.core.nglob/#stepup.core.nglob.NGlobSingle.pattern","title":"<code>pattern</code>  <code>property</code>","text":"<p>The Named Glob pattern used to match filenames.</p>"},{"location":"reference/stepup.core.nglob/#stepup.core.nglob.NGlobSingle.regex","title":"<code>regex</code>  <code>property</code>","text":"<p>The conversion of the named glob to a regular expression.</p>"},{"location":"reference/stepup.core.nglob/#stepup.core.nglob.NGlobSingle.results","title":"<code>results</code>  <code>property</code>","text":"<p>All matching files, grouped by substrings matching the named wildcards.</p> <p>The keys of the <code>results</code> dictionary are tuples with the substrings, matching the respective named wildcards in the <code>used_names</code> tuple. The values are sets with matching paths.</p>"},{"location":"reference/stepup.core.nglob/#stepup.core.nglob.NGlobSingle.subs","title":"<code>subs</code>  <code>property</code>","text":"<p>User-defined glob patterns for the named wildcards.</p> <p>When a name is not present, <code>*</code> is used.</p>"},{"location":"reference/stepup.core.nglob/#stepup.core.nglob.NGlobSingle.used_names","title":"<code>used_names</code>  <code>property</code>","text":"<p>A tuple of named wildcards present in the pattern.</p>"},{"location":"reference/stepup.core.nglob/#stepup.core.nglob.NGlobSingle.extend","title":"<code>extend(paths)</code>","text":"<p>Add matching paths from the given list paths.</p> <p>Yields:</p> <ul> <li> <code>values</code>           \u2013            <p>A tuple with substring matching the named wildcards, only this combination of names was not present yet.</p> </li> </ul> Source code in <code>stepup/core/nglob.py</code> <pre><code>def extend(self, paths: Iterable[str]) -&gt; Iterator[tuple[str, ...]]:\n    \"\"\"Add matching paths from the given list paths.\n\n    Yields\n    ------\n    values\n        A tuple with substring matching the named wildcards,\n        only this combination of names was not present yet.\n    \"\"\"\n    for values, path_set, path in self._loop_matches(paths):\n        if len(path_set) == 0:\n            yield values\n        path_set.add(path)\n</code></pre>"},{"location":"reference/stepup.core.nglob/#stepup.core.nglob.NGlobSingle.glob","title":"<code>glob()</code>","text":"<p>Extend the results with paths obtained through Python\u2019s built-in glob module.</p> <p>Yields:</p> <ul> <li> <code>values</code>           \u2013            <p>A tuple with substring matching the named wildcards, only this combination of names was not present yet.</p> </li> </ul> Source code in <code>stepup/core/nglob.py</code> <pre><code>def glob(self) -&gt; Iterator[tuple[str, ...]]:\n    \"\"\"Extend the results with paths obtained through Python's built-in glob module.\n\n    Yields\n    ------\n    values\n        A tuple with substring matching the named wildcards,\n        only this combination of names was not present yet.\n    \"\"\"\n    paths = []\n    for path in glob.iglob(self._glob_pattern, recursive=True, include_hidden=True):\n        path = Path(path)\n        if path.is_dir():\n            path = path / \"\"\n        paths.append(path)\n    yield from self.extend(paths)\n</code></pre>"},{"location":"reference/stepup.core.nglob/#stepup.core.nglob.NGlobSingle.reduce","title":"<code>reduce(paths)</code>","text":"<p>Remove matching paths from given list paths.</p> <p>Yields:</p> <ul> <li> <code>values</code>           \u2013            <p>A tuple with deleted substring matching the named wildcards, only if the last matching paths were removed.</p> </li> </ul> Source code in <code>stepup/core/nglob.py</code> <pre><code>def reduce(self, paths: Iterable[str]) -&gt; Iterator[tuple[str, ...]]:\n    \"\"\"Remove matching paths from given list paths.\n\n    Yields\n    ------\n    values\n        A tuple with deleted substring matching the named wildcards,\n        only if the last matching paths were removed.\n    \"\"\"\n    for values, path_set, path in self._loop_matches(paths):\n        if len(path_set) &gt; 0:\n            path_set.discard(path)\n            if len(path_set) == 0:\n                yield values\n</code></pre>"},{"location":"reference/stepup.core.nglob/#stepup.core.nglob.convert_nglob_to_glob","title":"<code>convert_nglob_to_glob(pattern, subs=None)</code>","text":"<p>Convert nglob wildcards to ordinary ones, compatible with builtin glob and fnmatch modules.</p> <p>Parameters:</p> <ul> <li> <code>pattern</code>               (<code>str</code>)           \u2013            <p>A string with named wildcards.</p> </li> <li> <code>subs</code>               (<code>dict[str, str] | None</code>, default:                   <code>None</code> )           \u2013            <p>A dictionary mapping names to glob patterns. If a name is not present, <code>*</code> is used as default.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>pattern</code>           \u2013            <p>A conventional wildcard string, without the constraint that named wildcards must correspond. Where possible, neighboring wildcards are merged into one.</p> </li> </ul> Source code in <code>stepup/core/nglob.py</code> <pre><code>def convert_nglob_to_glob(pattern: str, subs: dict[str, str] | None = None) -&gt; str:\n    \"\"\"Convert nglob wildcards to ordinary ones, compatible with builtin glob and fnmatch modules.\n\n    Parameters\n    ----------\n    pattern\n        A string with named wildcards.\n    subs\n        A dictionary mapping names to glob patterns.\n        If a name is not present, `*` is used as default.\n\n    Returns\n    -------\n    pattern\n        A conventional wildcard string, without the constraint that named wildcards must correspond.\n        Where possible, neighboring wildcards are merged into one.\n    \"\"\"\n    if subs is None:\n        subs = {}\n    # Split in text, wildcard and named wildcard fragments.\n    parts = []\n    # The odd-numbered indices match a (named) wildcard.\n    for i, part in enumerate(RE_NAMED_WILD.split(pattern)):\n        if i % 2 == 1 and part.startswith(\"${*\"):\n            # Split the substituted named wildcards once more.\n            parts.extend(RE_NAMED_WILD.split(subs.get(part[3:-1], \"*\")))\n        else:\n            # No substitution, so no additional splitting required.\n            parts.append(part)\n    # Remove empty strings due to neighboring wildcards with no normal text in between.\n    parts = [part for part in parts if part != \"\"]\n    # Make sure no asterisks are glued together and a few other simplifications.\n    texts = []\n    for part in parts:\n        if len(texts) == 0 or part == \"?\":\n            texts.append(part)\n        elif part == \"*\":\n            if texts[-1] not in [\"*\", \"**\"]:\n                texts.append(\"*\")\n        elif part == \"**\":\n            if texts[-1] in [\"*\"]:\n                texts[-1] = \"**\"\n            elif texts[-1] != \"**\":\n                texts.append(\"**\")\n        elif part == \"**/\":\n            if texts[-1] in [\"*\"] or texts[-1] == \"**\":\n                texts[-1] = \"**/\"\n            elif texts[-1] != \"**/\":\n                texts.append(\"**/\")\n        else:\n            texts.append(part)\n    return \"\".join(texts)\n</code></pre>"},{"location":"reference/stepup.core.nglob/#stepup.core.nglob.convert_nglob_to_regex","title":"<code>convert_nglob_to_regex(pattern, subs=None, allow_names=True)</code>","text":"<p>Convert a named glob pattern to a regular expressions.</p> <p>Parameters:</p> <ul> <li> <code>pattern</code>               (<code>str</code>)           \u2013            <p>A string with named wildcards.</p> </li> <li> <code>subs</code>               (<code>dict[str, str] | None</code>, default:                   <code>None</code> )           \u2013            <p>A dictionary mapping names to glob patterns. If a name is not present, <code>*</code> is used as default.</p> </li> <li> <code>allow_names</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>When set to <code>False</code>, named wildcards are not allowed.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>regex</code>           \u2013            <p>A regular expression string to test if a string matches the pattern. It also contains symbolic groups to extract values corresponding to named wildcards and to impose consistency when the same name appears multiple times.</p> </li> </ul> Source code in <code>stepup/core/nglob.py</code> <pre><code>def convert_nglob_to_regex(\n    pattern: str, subs: dict[str, str] | None = None, allow_names: bool = True\n) -&gt; str:\n    \"\"\"Convert a named glob pattern to a regular expressions.\n\n    Parameters\n    ----------\n    pattern\n        A string with named wildcards.\n    subs\n        A dictionary mapping names to glob patterns.\n        If a name is not present, `*` is used as default.\n    allow_names\n        When set to `False`, named wildcards are not allowed.\n\n    Returns\n    -------\n    regex\n        A regular expression string to test if a string matches the pattern.\n        It also contains symbolic groups to extract values\n        corresponding to named wildcards\n        and to impose consistency when the same name appears multiple times.\n    \"\"\"\n    if subs is None:\n        subs = {}\n    parts = []\n    # Last non-empty part matched by re.split\n    last = None\n    # Names encountered so far\n    encountered = set()\n    for i, part in enumerate(RE_NAMED_WILD.split(pattern)):\n        if i % 2 == 0:\n            if len(part) &gt; 0:\n                # Not a wildcard: escape regex characters.\n                parts.append(re.escape(part))\n        else:\n            # A (named) wildcard: replace with corresponding regex.\n            replace = False\n            regex = None\n            if part == \"?\":\n                regex = r\"[^/]\"\n            elif part == \"*\":\n                if last not in [\"*\", \"**\"]:\n                    regex = r\"[^/]*\"\n            elif part == \"**\":\n                if last != \"**\":\n                    regex = r\".*\"\n                    if last in [\"*\"]:\n                        replace = True\n            elif part == \"**/\":\n                if last != \"**/\":\n                    regex = r\"(?:.*/|)\"\n                    if last in [\"*\", \"**\"]:\n                        replace = True\n            elif part.startswith(\"[\") and part.endswith(\"]\"):\n                regex = rf\"[^{part[2:-1]}]\" if part[1] == \"!\" else rf\"[{part[1:-1]}]\"\n            elif part.startswith(\"${*\") and part.endswith(\"}\"):\n                if not allow_names:\n                    raise ValueError(f\"Named wildcards not allowed in {pattern}\")\n                name = part[3:-1]\n                if name in encountered:\n                    regex = rf\"(?P={name})\"\n                else:\n                    part_regex = convert_nglob_to_regex(subs.get(name, \"*\"), {}, False)\n                    regex = rf\"(?P&lt;{name}&gt;{part_regex})\"\n                    encountered.add(name)\n            else:\n                raise ValueError(f\"Cannot convert wildcard to regex: {part}\")\n            if regex is not None and len(regex) &gt; 0:\n                if replace:\n                    parts[-1] = regex\n                else:\n                    parts.append(regex)\n        if len(part) &gt; 0:\n            last = part\n\n    if allow_names:\n        # Post-process anonymous wildcards:\n        # - when enclosed by separators, '*' and '**; do not match empty strings.\n        for ipart, part in enumerate(parts):\n            if (\n                ipart &gt; 0\n                and ipart &lt; len(parts) - 1\n                and part.endswith(\"*\")\n                and parts[ipart - 1].endswith(\"/\")\n                and parts[ipart + 1].startswith(\"/\")\n            ):\n                parts[ipart] = f\"{part[:-1]}+\"\n        # - when the pattern ends with '*', it must also match paths with a trailing separator.\n        if parts[-1] == r\"[^/]*\":\n            if len(parts) &gt;= 2 and parts[-2].endswith(\"/\"):\n                parts[-1] = r\"[^/]+\"\n            parts.append(\"/?\")\n\n    return \"\".join(parts)\n</code></pre>"},{"location":"reference/stepup.core.nglob/#stepup.core.nglob.has_anonymous_wildcards","title":"<code>has_anonymous_wildcards(pattern)</code>","text":"<p>Test if a glob pattern has anonymous wildcards.</p> Source code in <code>stepup/core/nglob.py</code> <pre><code>def has_anonymous_wildcards(pattern: str) -&gt; bool:\n    \"\"\"Test if a glob pattern has anonymous wildcards.\"\"\"\n    for ipart, part in enumerate(RE_NAMED_WILD.split(pattern)):\n        if ipart % 2 == 1 and not part.startswith(\"${*\"):\n            return True\n    return False\n</code></pre>"},{"location":"reference/stepup.core.nglob/#stepup.core.nglob.has_wildcards","title":"<code>has_wildcards(pattern)</code>","text":"<p>Test if a glob pattern has anonymous or named wildcards.</p> Source code in <code>stepup/core/nglob.py</code> <pre><code>def has_wildcards(pattern: str) -&gt; bool:\n    \"\"\"Test if a glob pattern has anonymous or named wildcards.\"\"\"\n    return RE_NAMED_WILD.search(pattern) is not None\n</code></pre>"},{"location":"reference/stepup.core.nglob/#stepup.core.nglob.iter_wildcard_names","title":"<code>iter_wildcard_names(pattern)</code>","text":"<p>Iterate over the names of the named wildcards in a Named Glob pattern.</p> Source code in <code>stepup/core/nglob.py</code> <pre><code>def iter_wildcard_names(pattern: str) -&gt; Iterator[str]:\n    \"\"\"Iterate over the names of the named wildcards in a Named Glob pattern.\"\"\"\n    for ipart, part in enumerate(RE_NAMED_WILD.split(pattern)):\n        if ipart % 2 == 1 and part.startswith(\"${*\"):\n            yield part[3:-1]\n</code></pre>"},{"location":"reference/stepup.core.script/","title":"stepup.core.script","text":"<p>Driver function to facilitate writing scripts that adhere to StepUp\u2019s script protocol.</p> <p>See Script Protocol for more details.</p>"},{"location":"reference/stepup.core.script/#stepup.core.script.driver","title":"<code>driver(obj=None)</code>","text":"<p>Implement script protocol.</p> <p>The most common usage is to call <code>driver()</code> from a script that defines <code>info()</code> and <code>run()</code> function, e.g.:</p> <pre><code>#!/usr/bin/env python3\nfrom stepup.core.script import driver\n\ndef info():\n    return {\"inp\": [\"input.txt\"], \"out\": [\"output.txt\"]}\n\ndef run(inp: str, out: str):\n    with open(inp) as fh:\n        text = fh.read()\n    with open(out, \"w\") as fh:\n        fh.write(text.upper())\n\nif __name__ == \"__main__\":\n    driver()\n</code></pre> <p>Parameters:</p> <ul> <li> <code>obj</code>               (<code>Any</code>, default:                   <code>None</code> )           \u2013            <p>When not provided, the namespace of the module where <code>driver</code> is defined will be searched for names like \u2018info\u2019 and \u2018run\u2019 to implement the script protocol. When an object is given as a parameter, its attributes are searched instead.</p> </li> </ul> Source code in <code>stepup/core/script.py</code> <pre><code>def driver(obj: Any = None):\n    \"\"\"Implement script protocol.\n\n    The most common usage is to call `driver()` from a script\n    that defines `info()` and `run()` function, e.g.:\n\n    ```python\n    #!/usr/bin/env python3\n    from stepup.core.script import driver\n\n    def info():\n        return {\"inp\": [\"input.txt\"], \"out\": [\"output.txt\"]}\n\n    def run(inp: str, out: str):\n        with open(inp) as fh:\n            text = fh.read()\n        with open(out, \"w\") as fh:\n            fh.write(text.upper())\n\n    if __name__ == \"__main__\":\n        driver()\n    ```\n\n    Parameters\n    ----------\n    obj\n        When not provided, the namespace of the module where `driver` is defined\n        will be searched for names like 'info' and 'run' to implement the script protocol.\n        When an object is given as a parameter, its attributes are searched instead.\n    \"\"\"\n    frame = inspect.currentframe().f_back\n    script_path = Path(frame.f_locals[\"__file__\"]).relpath()\n    if obj is None:\n        # Get the calling module and use it as obj\n        module_name = frame.f_locals[\"__name__\"]\n        obj = sys.modules.get(module_name)\n        if obj is None:\n            raise ValueError(\n                f\"The driver must be called from an imported module, got {module_name}\"\n            )\n    args = parse_args(script_path)\n    wrapper = ScriptWrapper(obj, script_path)\n    if args.cmd == \"plan\":\n        _driver_plan(script_path, args, wrapper)\n    elif args.cmd == \"cases\":\n        _driver_cases(script_path, wrapper)\n    elif args.cmd == \"run\":\n        _driver_run(script_path, args, wrapper)\n    else:\n        raise NotImplementedError\n</code></pre>"},{"location":"reference/stepup.core.stepinfo/","title":"stepup.core.stepinfo","text":"<p>Information about a step in a StepUp build, intended for defining follow-up steps.</p>"},{"location":"reference/stepup.core.stepinfo/#stepup.core.stepinfo.StepInfo","title":"<code>StepInfo</code>","text":"<p>The <code>step()</code> function returns an instance of this class to help defining follow-up steps.</p> <p>This object will not contain any information that is amended while the step is executed. It only holds information known at the time the step is defined.</p> <p>All paths and environment variables are stored in sorted order to ensure consistency.</p> Source code in <code>stepup/core/stepinfo.py</code> <pre><code>@attrs.define\nclass StepInfo:\n    \"\"\"The `step()` function returns an instance of this class to help defining follow-up steps.\n\n    This object will not contain any information that is amended while the step is executed.\n    It only holds information known at the time the step is defined.\n\n    All paths and environment variables are stored in sorted order to ensure consistency.\n    \"\"\"\n\n    command: str = attrs.field(converter=str)\n    \"\"\"The command of the step.\"\"\"\n\n    workdir: Path = attrs.field(converter=Path)\n    \"\"\"The work directory of the step.\n\n    If relative, it is relative to the StepUp root.\"\"\"\n\n    inp: list[Path] = attrs.field(converter=_convert_to_paths)\n    \"\"\"List of input paths of the step.\n\n    If relative, they are relative to the work directory.\n    \"\"\"\n\n    env: list[str] = attrs.field(converter=_convert_to_strs)\n    \"\"\"List of environment values used by the step.\"\"\"\n\n    out: list[Path] = attrs.field(converter=_convert_to_paths)\n    \"\"\"List of output paths of the step.\n\n    If relative, they are relative to the work directory.\n    \"\"\"\n\n    vol: list[Path] = attrs.field(converter=_convert_to_paths)\n    \"\"\"List of volatile output paths of the step.\n\n    If relative, they are relative to the work directory.\n    \"\"\"\n\n    def filter_inp(self, *patterns: str, **subs: str):\n        \"\"\"Return an `NGlobMulti` object with matching results from `self.inp`.\"\"\"\n        ngm = NGlobMulti.from_patterns(patterns, subs)\n        ngm.extend(self.inp)\n        return ngm\n\n    def filter_out(self, *patterns: str, **subs: str):\n        \"\"\"Return an `NGlobMulti` object with matching results from `self.out`.\"\"\"\n        ngm = NGlobMulti.from_patterns(patterns, subs)\n        ngm.extend(self.out)\n        return ngm\n\n    def filter_vol(self, *patterns: str, **subs: str):\n        \"\"\"Return an `NGlobMulti` object with matching results from `self.vol`.\"\"\"\n        ngm = NGlobMulti.from_patterns(patterns, subs)\n        ngm.extend(self.vol)\n        return ngm\n</code></pre>"},{"location":"reference/stepup.core.stepinfo/#stepup.core.stepinfo.StepInfo.command","title":"<code>command = attrs.field(converter=str)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The command of the step.</p>"},{"location":"reference/stepup.core.stepinfo/#stepup.core.stepinfo.StepInfo.env","title":"<code>env = attrs.field(converter=_convert_to_strs)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>List of environment values used by the step.</p>"},{"location":"reference/stepup.core.stepinfo/#stepup.core.stepinfo.StepInfo.inp","title":"<code>inp = attrs.field(converter=_convert_to_paths)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>List of input paths of the step.</p> <p>If relative, they are relative to the work directory.</p>"},{"location":"reference/stepup.core.stepinfo/#stepup.core.stepinfo.StepInfo.out","title":"<code>out = attrs.field(converter=_convert_to_paths)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>List of output paths of the step.</p> <p>If relative, they are relative to the work directory.</p>"},{"location":"reference/stepup.core.stepinfo/#stepup.core.stepinfo.StepInfo.vol","title":"<code>vol = attrs.field(converter=_convert_to_paths)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>List of volatile output paths of the step.</p> <p>If relative, they are relative to the work directory.</p>"},{"location":"reference/stepup.core.stepinfo/#stepup.core.stepinfo.StepInfo.workdir","title":"<code>workdir = attrs.field(converter=Path)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The work directory of the step.</p> <p>If relative, it is relative to the StepUp root.</p>"},{"location":"reference/stepup.core.stepinfo/#stepup.core.stepinfo.StepInfo.filter_inp","title":"<code>filter_inp(*patterns, **subs)</code>","text":"<p>Return an <code>NGlobMulti</code> object with matching results from <code>self.inp</code>.</p> Source code in <code>stepup/core/stepinfo.py</code> <pre><code>def filter_inp(self, *patterns: str, **subs: str):\n    \"\"\"Return an `NGlobMulti` object with matching results from `self.inp`.\"\"\"\n    ngm = NGlobMulti.from_patterns(patterns, subs)\n    ngm.extend(self.inp)\n    return ngm\n</code></pre>"},{"location":"reference/stepup.core.stepinfo/#stepup.core.stepinfo.StepInfo.filter_out","title":"<code>filter_out(*patterns, **subs)</code>","text":"<p>Return an <code>NGlobMulti</code> object with matching results from <code>self.out</code>.</p> Source code in <code>stepup/core/stepinfo.py</code> <pre><code>def filter_out(self, *patterns: str, **subs: str):\n    \"\"\"Return an `NGlobMulti` object with matching results from `self.out`.\"\"\"\n    ngm = NGlobMulti.from_patterns(patterns, subs)\n    ngm.extend(self.out)\n    return ngm\n</code></pre>"},{"location":"reference/stepup.core.stepinfo/#stepup.core.stepinfo.StepInfo.filter_vol","title":"<code>filter_vol(*patterns, **subs)</code>","text":"<p>Return an <code>NGlobMulti</code> object with matching results from <code>self.vol</code>.</p> Source code in <code>stepup/core/stepinfo.py</code> <pre><code>def filter_vol(self, *patterns: str, **subs: str):\n    \"\"\"Return an `NGlobMulti` object with matching results from `self.vol`.\"\"\"\n    ngm = NGlobMulti.from_patterns(patterns, subs)\n    ngm.extend(self.vol)\n    return ngm\n</code></pre>"},{"location":"reference/stepup.core.stepinfo/#stepup.core.stepinfo.dump_step_info","title":"<code>dump_step_info(filename, step_info)</code>","text":"<p>Dump one or more step info objects to a JSON file.</p> <p>The file will contain a single JSON object or a JSON array of such objects.</p> Source code in <code>stepup/core/stepinfo.py</code> <pre><code>def dump_step_info(filename: str, step_info: StepInfo | list[StepInfo]):\n    \"\"\"Dump one or more step info objects to a JSON file.\n\n    The file will contain a single JSON object or a JSON array of such objects.\n    \"\"\"\n    with open(filename, \"w\") as fh:\n        data = (\n            attrs.asdict(step_info)\n            if isinstance(step_info, StepInfo)\n            else [attrs.asdict(si) for si in step_info]\n        )\n        json.dump(data, fh, indent=2)\n        fh.write(\"\\n\")\n</code></pre>"},{"location":"reference/stepup.core.stepinfo/#stepup.core.stepinfo.load_step_info","title":"<code>load_step_info(filename)</code>","text":"<p>Load one or more step info object from a JSON file.</p> <p>The file should contain a single JSON object or a JSON array of such objects.</p> Source code in <code>stepup/core/stepinfo.py</code> <pre><code>def load_step_info(filename: str) -&gt; StepInfo | list[StepInfo]:\n    \"\"\"Load one or more step info object from a JSON file.\n\n    The file should contain a single JSON object or a JSON array of such objects.\n    \"\"\"\n    with open(filename) as fh:\n        data = json.load(fh)\n        return StepInfo(**data) if isinstance(data, dict) else [StepInfo(**item) for item in data]\n</code></pre>"}]}